
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Business
 * 
 */
export type Business = $Result.DefaultSelection<Prisma.$BusinessPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Worker
 * 
 */
export type Worker = $Result.DefaultSelection<Prisma.$WorkerPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderProduct
 * 
 */
export type OrderProduct = $Result.DefaultSelection<Prisma.$OrderProductPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model RepostedProduct
 * 
 */
export type RepostedProduct = $Result.DefaultSelection<Prisma.$RepostedProductPayload>
/**
 * Model ReOwnedProduct
 * 
 */
export type ReOwnedProduct = $Result.DefaultSelection<Prisma.$ReOwnedProductPayload>
/**
 * Model KYC
 * 
 */
export type KYC = $Result.DefaultSelection<Prisma.$KYCPayload>
/**
 * Model AccountRecharge
 * 
 */
export type AccountRecharge = $Result.DefaultSelection<Prisma.$AccountRechargePayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = $Result.DefaultSelection<Prisma.$PaymentTransactionPayload>
/**
 * Model Ad
 * 
 */
export type Ad = $Result.DefaultSelection<Prisma.$AdPayload>
/**
 * Model FreelanceService
 * 
 */
export type FreelanceService = $Result.DefaultSelection<Prisma.$FreelanceServicePayload>
/**
 * Model FreelanceOrder
 * 
 */
export type FreelanceOrder = $Result.DefaultSelection<Prisma.$FreelanceOrderPayload>
/**
 * Model Referral
 * 
 */
export type Referral = $Result.DefaultSelection<Prisma.$ReferralPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const RechargeMethod: {
  MTN_MONEY: 'MTN_MONEY',
  AIRTEL_MONEY: 'AIRTEL_MONEY',
  ORANGE_MONEY: 'ORANGE_MONEY',
  MPESA: 'MPESA'
};

export type RechargeMethod = (typeof RechargeMethod)[keyof typeof RechargeMethod]


export const Country: {
  DRC: 'DRC',
  KENYA: 'KENYA',
  UGANDA: 'UGANDA',
  RWANDA: 'RWANDA',
  BURUNDI: 'BURUNDI',
  TANZANIA: 'TANZANIA'
};

export type Country = (typeof Country)[keyof typeof Country]


export const KycStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type KycStatus = (typeof KycStatus)[keyof typeof KycStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  TOKEN: 'TOKEN',
  MOBILE_MONEY: 'MOBILE_MONEY'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const FreelanceStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type FreelanceStatus = (typeof FreelanceStatus)[keyof typeof FreelanceStatus]

}

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type RechargeMethod = $Enums.RechargeMethod

export const RechargeMethod: typeof $Enums.RechargeMethod

export type Country = $Enums.Country

export const Country: typeof $Enums.Country

export type KycStatus = $Enums.KycStatus

export const KycStatus: typeof $Enums.KycStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type FreelanceStatus = $Enums.FreelanceStatus

export const FreelanceStatus: typeof $Enums.FreelanceStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Businesses
 * const businesses = await prisma.business.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Businesses
   * const businesses = await prisma.business.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.business`: Exposes CRUD operations for the **Business** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Businesses
    * const businesses = await prisma.business.findMany()
    * ```
    */
  get business(): Prisma.BusinessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.worker`: Exposes CRUD operations for the **Worker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workers
    * const workers = await prisma.worker.findMany()
    * ```
    */
  get worker(): Prisma.WorkerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderProduct`: Exposes CRUD operations for the **OrderProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderProducts
    * const orderProducts = await prisma.orderProduct.findMany()
    * ```
    */
  get orderProduct(): Prisma.OrderProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.repostedProduct`: Exposes CRUD operations for the **RepostedProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RepostedProducts
    * const repostedProducts = await prisma.repostedProduct.findMany()
    * ```
    */
  get repostedProduct(): Prisma.RepostedProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reOwnedProduct`: Exposes CRUD operations for the **ReOwnedProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReOwnedProducts
    * const reOwnedProducts = await prisma.reOwnedProduct.findMany()
    * ```
    */
  get reOwnedProduct(): Prisma.ReOwnedProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kYC`: Exposes CRUD operations for the **KYC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KYCS
    * const kYCS = await prisma.kYC.findMany()
    * ```
    */
  get kYC(): Prisma.KYCDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountRecharge`: Exposes CRUD operations for the **AccountRecharge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountRecharges
    * const accountRecharges = await prisma.accountRecharge.findMany()
    * ```
    */
  get accountRecharge(): Prisma.AccountRechargeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ad`: Exposes CRUD operations for the **Ad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ads
    * const ads = await prisma.ad.findMany()
    * ```
    */
  get ad(): Prisma.AdDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelanceService`: Exposes CRUD operations for the **FreelanceService** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelanceServices
    * const freelanceServices = await prisma.freelanceService.findMany()
    * ```
    */
  get freelanceService(): Prisma.FreelanceServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.freelanceOrder`: Exposes CRUD operations for the **FreelanceOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FreelanceOrders
    * const freelanceOrders = await prisma.freelanceOrder.findMany()
    * ```
    */
  get freelanceOrder(): Prisma.FreelanceOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.referral`: Exposes CRUD operations for the **Referral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Referrals
    * const referrals = await prisma.referral.findMany()
    * ```
    */
  get referral(): Prisma.ReferralDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Business: 'Business',
    Client: 'Client',
    Worker: 'Worker',
    Product: 'Product',
    Media: 'Media',
    Order: 'Order',
    OrderProduct: 'OrderProduct',
    Review: 'Review',
    Chat: 'Chat',
    ChatMessage: 'ChatMessage',
    RepostedProduct: 'RepostedProduct',
    ReOwnedProduct: 'ReOwnedProduct',
    KYC: 'KYC',
    AccountRecharge: 'AccountRecharge',
    Token: 'Token',
    PaymentTransaction: 'PaymentTransaction',
    Ad: 'Ad',
    FreelanceService: 'FreelanceService',
    FreelanceOrder: 'FreelanceOrder',
    Referral: 'Referral'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "business" | "client" | "worker" | "product" | "media" | "order" | "orderProduct" | "review" | "chat" | "chatMessage" | "repostedProduct" | "reOwnedProduct" | "kYC" | "accountRecharge" | "token" | "paymentTransaction" | "ad" | "freelanceService" | "freelanceOrder" | "referral"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Business: {
        payload: Prisma.$BusinessPayload<ExtArgs>
        fields: Prisma.BusinessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findFirst: {
            args: Prisma.BusinessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          findMany: {
            args: Prisma.BusinessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          create: {
            args: Prisma.BusinessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          createMany: {
            args: Prisma.BusinessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          delete: {
            args: Prisma.BusinessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          update: {
            args: Prisma.BusinessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          deleteMany: {
            args: Prisma.BusinessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessPayload>
          }
          aggregate: {
            args: Prisma.BusinessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusiness>
          }
          groupBy: {
            args: Prisma.BusinessGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Worker: {
        payload: Prisma.$WorkerPayload<ExtArgs>
        fields: Prisma.WorkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findFirst: {
            args: Prisma.WorkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          findMany: {
            args: Prisma.WorkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          create: {
            args: Prisma.WorkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          createMany: {
            args: Prisma.WorkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          delete: {
            args: Prisma.WorkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          update: {
            args: Prisma.WorkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          deleteMany: {
            args: Prisma.WorkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>[]
          }
          upsert: {
            args: Prisma.WorkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkerPayload>
          }
          aggregate: {
            args: Prisma.WorkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorker>
          }
          groupBy: {
            args: Prisma.WorkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkerCountArgs<ExtArgs>
            result: $Utils.Optional<WorkerCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderProduct: {
        payload: Prisma.$OrderProductPayload<ExtArgs>
        fields: Prisma.OrderProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          findFirst: {
            args: Prisma.OrderProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          findMany: {
            args: Prisma.OrderProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          create: {
            args: Prisma.OrderProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          createMany: {
            args: Prisma.OrderProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          delete: {
            args: Prisma.OrderProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          update: {
            args: Prisma.OrderProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          deleteMany: {
            args: Prisma.OrderProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>[]
          }
          upsert: {
            args: Prisma.OrderProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderProductPayload>
          }
          aggregate: {
            args: Prisma.OrderProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderProduct>
          }
          groupBy: {
            args: Prisma.OrderProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderProductCountArgs<ExtArgs>
            result: $Utils.Optional<OrderProductCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      RepostedProduct: {
        payload: Prisma.$RepostedProductPayload<ExtArgs>
        fields: Prisma.RepostedProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RepostedProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RepostedProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>
          }
          findFirst: {
            args: Prisma.RepostedProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RepostedProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>
          }
          findMany: {
            args: Prisma.RepostedProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>[]
          }
          create: {
            args: Prisma.RepostedProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>
          }
          createMany: {
            args: Prisma.RepostedProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RepostedProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>[]
          }
          delete: {
            args: Prisma.RepostedProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>
          }
          update: {
            args: Prisma.RepostedProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>
          }
          deleteMany: {
            args: Prisma.RepostedProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RepostedProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RepostedProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>[]
          }
          upsert: {
            args: Prisma.RepostedProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RepostedProductPayload>
          }
          aggregate: {
            args: Prisma.RepostedProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRepostedProduct>
          }
          groupBy: {
            args: Prisma.RepostedProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<RepostedProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.RepostedProductCountArgs<ExtArgs>
            result: $Utils.Optional<RepostedProductCountAggregateOutputType> | number
          }
        }
      }
      ReOwnedProduct: {
        payload: Prisma.$ReOwnedProductPayload<ExtArgs>
        fields: Prisma.ReOwnedProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReOwnedProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReOwnedProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>
          }
          findFirst: {
            args: Prisma.ReOwnedProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReOwnedProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>
          }
          findMany: {
            args: Prisma.ReOwnedProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>[]
          }
          create: {
            args: Prisma.ReOwnedProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>
          }
          createMany: {
            args: Prisma.ReOwnedProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReOwnedProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>[]
          }
          delete: {
            args: Prisma.ReOwnedProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>
          }
          update: {
            args: Prisma.ReOwnedProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>
          }
          deleteMany: {
            args: Prisma.ReOwnedProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReOwnedProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReOwnedProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>[]
          }
          upsert: {
            args: Prisma.ReOwnedProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReOwnedProductPayload>
          }
          aggregate: {
            args: Prisma.ReOwnedProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReOwnedProduct>
          }
          groupBy: {
            args: Prisma.ReOwnedProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReOwnedProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReOwnedProductCountArgs<ExtArgs>
            result: $Utils.Optional<ReOwnedProductCountAggregateOutputType> | number
          }
        }
      }
      KYC: {
        payload: Prisma.$KYCPayload<ExtArgs>
        fields: Prisma.KYCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KYCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KYCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          findFirst: {
            args: Prisma.KYCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KYCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          findMany: {
            args: Prisma.KYCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          create: {
            args: Prisma.KYCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          createMany: {
            args: Prisma.KYCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KYCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          delete: {
            args: Prisma.KYCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          update: {
            args: Prisma.KYCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          deleteMany: {
            args: Prisma.KYCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KYCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KYCUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>[]
          }
          upsert: {
            args: Prisma.KYCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KYCPayload>
          }
          aggregate: {
            args: Prisma.KYCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKYC>
          }
          groupBy: {
            args: Prisma.KYCGroupByArgs<ExtArgs>
            result: $Utils.Optional<KYCGroupByOutputType>[]
          }
          count: {
            args: Prisma.KYCCountArgs<ExtArgs>
            result: $Utils.Optional<KYCCountAggregateOutputType> | number
          }
        }
      }
      AccountRecharge: {
        payload: Prisma.$AccountRechargePayload<ExtArgs>
        fields: Prisma.AccountRechargeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountRechargeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountRechargeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>
          }
          findFirst: {
            args: Prisma.AccountRechargeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountRechargeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>
          }
          findMany: {
            args: Prisma.AccountRechargeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>[]
          }
          create: {
            args: Prisma.AccountRechargeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>
          }
          createMany: {
            args: Prisma.AccountRechargeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountRechargeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>[]
          }
          delete: {
            args: Prisma.AccountRechargeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>
          }
          update: {
            args: Prisma.AccountRechargeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>
          }
          deleteMany: {
            args: Prisma.AccountRechargeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountRechargeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountRechargeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>[]
          }
          upsert: {
            args: Prisma.AccountRechargeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountRechargePayload>
          }
          aggregate: {
            args: Prisma.AccountRechargeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountRecharge>
          }
          groupBy: {
            args: Prisma.AccountRechargeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountRechargeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountRechargeCountArgs<ExtArgs>
            result: $Utils.Optional<AccountRechargeCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: Prisma.$PaymentTransactionPayload<ExtArgs>
        fields: Prisma.PaymentTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
      Ad: {
        payload: Prisma.$AdPayload<ExtArgs>
        fields: Prisma.AdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findFirst: {
            args: Prisma.AdFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          findMany: {
            args: Prisma.AdFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          create: {
            args: Prisma.AdCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          createMany: {
            args: Prisma.AdCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          delete: {
            args: Prisma.AdDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          update: {
            args: Prisma.AdUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          deleteMany: {
            args: Prisma.AdDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>[]
          }
          upsert: {
            args: Prisma.AdUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdPayload>
          }
          aggregate: {
            args: Prisma.AdAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAd>
          }
          groupBy: {
            args: Prisma.AdGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdCountArgs<ExtArgs>
            result: $Utils.Optional<AdCountAggregateOutputType> | number
          }
        }
      }
      FreelanceService: {
        payload: Prisma.$FreelanceServicePayload<ExtArgs>
        fields: Prisma.FreelanceServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelanceServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelanceServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>
          }
          findFirst: {
            args: Prisma.FreelanceServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelanceServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>
          }
          findMany: {
            args: Prisma.FreelanceServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>[]
          }
          create: {
            args: Prisma.FreelanceServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>
          }
          createMany: {
            args: Prisma.FreelanceServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelanceServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>[]
          }
          delete: {
            args: Prisma.FreelanceServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>
          }
          update: {
            args: Prisma.FreelanceServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>
          }
          deleteMany: {
            args: Prisma.FreelanceServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelanceServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreelanceServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>[]
          }
          upsert: {
            args: Prisma.FreelanceServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceServicePayload>
          }
          aggregate: {
            args: Prisma.FreelanceServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelanceService>
          }
          groupBy: {
            args: Prisma.FreelanceServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelanceServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelanceServiceCountArgs<ExtArgs>
            result: $Utils.Optional<FreelanceServiceCountAggregateOutputType> | number
          }
        }
      }
      FreelanceOrder: {
        payload: Prisma.$FreelanceOrderPayload<ExtArgs>
        fields: Prisma.FreelanceOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FreelanceOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FreelanceOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>
          }
          findFirst: {
            args: Prisma.FreelanceOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FreelanceOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>
          }
          findMany: {
            args: Prisma.FreelanceOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>[]
          }
          create: {
            args: Prisma.FreelanceOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>
          }
          createMany: {
            args: Prisma.FreelanceOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FreelanceOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>[]
          }
          delete: {
            args: Prisma.FreelanceOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>
          }
          update: {
            args: Prisma.FreelanceOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>
          }
          deleteMany: {
            args: Prisma.FreelanceOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FreelanceOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FreelanceOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>[]
          }
          upsert: {
            args: Prisma.FreelanceOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FreelanceOrderPayload>
          }
          aggregate: {
            args: Prisma.FreelanceOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFreelanceOrder>
          }
          groupBy: {
            args: Prisma.FreelanceOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FreelanceOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FreelanceOrderCountArgs<ExtArgs>
            result: $Utils.Optional<FreelanceOrderCountAggregateOutputType> | number
          }
        }
      }
      Referral: {
        payload: Prisma.$ReferralPayload<ExtArgs>
        fields: Prisma.ReferralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReferralFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReferralFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findFirst: {
            args: Prisma.ReferralFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReferralFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          findMany: {
            args: Prisma.ReferralFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          create: {
            args: Prisma.ReferralCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          createMany: {
            args: Prisma.ReferralCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReferralCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          delete: {
            args: Prisma.ReferralDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          update: {
            args: Prisma.ReferralUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          deleteMany: {
            args: Prisma.ReferralDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReferralUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReferralUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>[]
          }
          upsert: {
            args: Prisma.ReferralUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReferralPayload>
          }
          aggregate: {
            args: Prisma.ReferralAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferral>
          }
          groupBy: {
            args: Prisma.ReferralGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReferralCountArgs<ExtArgs>
            result: $Utils.Optional<ReferralCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    business?: BusinessOmit
    client?: ClientOmit
    worker?: WorkerOmit
    product?: ProductOmit
    media?: MediaOmit
    order?: OrderOmit
    orderProduct?: OrderProductOmit
    review?: ReviewOmit
    chat?: ChatOmit
    chatMessage?: ChatMessageOmit
    repostedProduct?: RepostedProductOmit
    reOwnedProduct?: ReOwnedProductOmit
    kYC?: KYCOmit
    accountRecharge?: AccountRechargeOmit
    token?: TokenOmit
    paymentTransaction?: PaymentTransactionOmit
    ad?: AdOmit
    freelanceService?: FreelanceServiceOmit
    freelanceOrder?: FreelanceOrderOmit
    referral?: ReferralOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BusinessCountOutputType
   */

  export type BusinessCountOutputType = {
    products: number
    workers: number
    repostedItems: number
    reownedItems: number
    recharges: number
    ads: number
    freelanceServices: number
    freelanceOrders: number
    referralsMade: number
    referralsReceived: number
    chats: number
  }

  export type BusinessCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | BusinessCountOutputTypeCountProductsArgs
    workers?: boolean | BusinessCountOutputTypeCountWorkersArgs
    repostedItems?: boolean | BusinessCountOutputTypeCountRepostedItemsArgs
    reownedItems?: boolean | BusinessCountOutputTypeCountReownedItemsArgs
    recharges?: boolean | BusinessCountOutputTypeCountRechargesArgs
    ads?: boolean | BusinessCountOutputTypeCountAdsArgs
    freelanceServices?: boolean | BusinessCountOutputTypeCountFreelanceServicesArgs
    freelanceOrders?: boolean | BusinessCountOutputTypeCountFreelanceOrdersArgs
    referralsMade?: boolean | BusinessCountOutputTypeCountReferralsMadeArgs
    referralsReceived?: boolean | BusinessCountOutputTypeCountReferralsReceivedArgs
    chats?: boolean | BusinessCountOutputTypeCountChatsArgs
  }

  // Custom InputTypes
  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessCountOutputType
     */
    select?: BusinessCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountWorkersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountRepostedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepostedProductWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountReownedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReOwnedProductWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountRechargeWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountFreelanceServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceServiceWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountFreelanceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceOrderWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountReferralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountReferralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * BusinessCountOutputType without action
   */
  export type BusinessCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    orders: number
    reviews: number
    chats: number
    recharges: number
    freelanceOrders: number
    referralsMade: number
    referralsReceived: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ClientCountOutputTypeCountOrdersArgs
    reviews?: boolean | ClientCountOutputTypeCountReviewsArgs
    chats?: boolean | ClientCountOutputTypeCountChatsArgs
    recharges?: boolean | ClientCountOutputTypeCountRechargesArgs
    freelanceOrders?: boolean | ClientCountOutputTypeCountFreelanceOrdersArgs
    referralsMade?: boolean | ClientCountOutputTypeCountReferralsMadeArgs
    referralsReceived?: boolean | ClientCountOutputTypeCountReferralsReceivedArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountRechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountRechargeWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountFreelanceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceOrderWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReferralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReferralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
  }


  /**
   * Count Type WorkerCountOutputType
   */

  export type WorkerCountOutputType = {
    chats: number
  }

  export type WorkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | WorkerCountOutputTypeCountChatsArgs
  }

  // Custom InputTypes
  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkerCountOutputType
     */
    select?: WorkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkerCountOutputType without action
   */
  export type WorkerCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    medias: number
    reviews: number
    orders: number
    chats: number
    reposts: number
    reowns: number
    ads: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medias?: boolean | ProductCountOutputTypeCountMediasArgs
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs
    orders?: boolean | ProductCountOutputTypeCountOrdersArgs
    chats?: boolean | ProductCountOutputTypeCountChatsArgs
    reposts?: boolean | ProductCountOutputTypeCountRepostsArgs
    reowns?: boolean | ProductCountOutputTypeCountReownsArgs
    ads?: boolean | ProductCountOutputTypeCountAdsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountRepostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepostedProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReOwnedProductWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountAdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    products: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | OrderCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
  }


  /**
   * Count Type ChatCountOutputType
   */

  export type ChatCountOutputType = {
    messages: number
  }

  export type ChatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatCountOutputType
     */
    select?: ChatCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatCountOutputType without action
   */
  export type ChatCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type FreelanceServiceCountOutputType
   */

  export type FreelanceServiceCountOutputType = {
    orders: number
  }

  export type FreelanceServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | FreelanceServiceCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * FreelanceServiceCountOutputType without action
   */
  export type FreelanceServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceServiceCountOutputType
     */
    select?: FreelanceServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FreelanceServiceCountOutputType without action
   */
  export type FreelanceServiceCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceOrderWhereInput
  }


  /**
   * Count Type FreelanceOrderCountOutputType
   */

  export type FreelanceOrderCountOutputType = {
    businesses: number
  }

  export type FreelanceOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businesses?: boolean | FreelanceOrderCountOutputTypeCountBusinessesArgs
  }

  // Custom InputTypes
  /**
   * FreelanceOrderCountOutputType without action
   */
  export type FreelanceOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrderCountOutputType
     */
    select?: FreelanceOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FreelanceOrderCountOutputType without action
   */
  export type FreelanceOrderCountOutputTypeCountBusinessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Business
   */

  export type AggregateBusiness = {
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  export type BusinessMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    description: string | null
    address: string | null
    phone: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    description: string | null
    address: string | null
    phone: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessCountAggregateOutputType = {
    id: number
    name: number
    email: number
    description: number
    address: number
    phone: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    description?: true
    address?: true
    phone?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    description?: true
    address?: true
    phone?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    description?: true
    address?: true
    phone?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Business to aggregate.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Businesses
    **/
    _count?: true | BusinessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessMaxAggregateInputType
  }

  export type GetBusinessAggregateType<T extends BusinessAggregateArgs> = {
        [P in keyof T & keyof AggregateBusiness]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusiness[P]>
      : GetScalarType<T[P], AggregateBusiness[P]>
  }




  export type BusinessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithAggregationInput | BusinessOrderByWithAggregationInput[]
    by: BusinessScalarFieldEnum[] | BusinessScalarFieldEnum
    having?: BusinessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessCountAggregateInputType | true
    _min?: BusinessMinAggregateInputType
    _max?: BusinessMaxAggregateInputType
  }

  export type BusinessGroupByOutputType = {
    id: string
    name: string
    email: string
    description: string | null
    address: string | null
    phone: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: BusinessCountAggregateOutputType | null
    _min: BusinessMinAggregateOutputType | null
    _max: BusinessMaxAggregateOutputType | null
  }

  type GetBusinessGroupByPayload<T extends BusinessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessGroupByOutputType[P]>
        }
      >
    >


  export type BusinessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kyc?: boolean | Business$kycArgs<ExtArgs>
    products?: boolean | Business$productsArgs<ExtArgs>
    workers?: boolean | Business$workersArgs<ExtArgs>
    repostedItems?: boolean | Business$repostedItemsArgs<ExtArgs>
    reownedItems?: boolean | Business$reownedItemsArgs<ExtArgs>
    recharges?: boolean | Business$rechargesArgs<ExtArgs>
    ads?: boolean | Business$adsArgs<ExtArgs>
    freelanceServices?: boolean | Business$freelanceServicesArgs<ExtArgs>
    freelanceOrders?: boolean | Business$freelanceOrdersArgs<ExtArgs>
    referralsMade?: boolean | Business$referralsMadeArgs<ExtArgs>
    referralsReceived?: boolean | Business$referralsReceivedArgs<ExtArgs>
    chats?: boolean | Business$chatsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["business"]>

  export type BusinessSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    description?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "description" | "address" | "phone" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["business"]>
  export type BusinessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc?: boolean | Business$kycArgs<ExtArgs>
    products?: boolean | Business$productsArgs<ExtArgs>
    workers?: boolean | Business$workersArgs<ExtArgs>
    repostedItems?: boolean | Business$repostedItemsArgs<ExtArgs>
    reownedItems?: boolean | Business$reownedItemsArgs<ExtArgs>
    recharges?: boolean | Business$rechargesArgs<ExtArgs>
    ads?: boolean | Business$adsArgs<ExtArgs>
    freelanceServices?: boolean | Business$freelanceServicesArgs<ExtArgs>
    freelanceOrders?: boolean | Business$freelanceOrdersArgs<ExtArgs>
    referralsMade?: boolean | Business$referralsMadeArgs<ExtArgs>
    referralsReceived?: boolean | Business$referralsReceivedArgs<ExtArgs>
    chats?: boolean | Business$chatsArgs<ExtArgs>
    _count?: boolean | BusinessCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BusinessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Business"
    objects: {
      kyc: Prisma.$KYCPayload<ExtArgs> | null
      products: Prisma.$ProductPayload<ExtArgs>[]
      workers: Prisma.$WorkerPayload<ExtArgs>[]
      repostedItems: Prisma.$RepostedProductPayload<ExtArgs>[]
      reownedItems: Prisma.$ReOwnedProductPayload<ExtArgs>[]
      recharges: Prisma.$AccountRechargePayload<ExtArgs>[]
      ads: Prisma.$AdPayload<ExtArgs>[]
      freelanceServices: Prisma.$FreelanceServicePayload<ExtArgs>[]
      freelanceOrders: Prisma.$FreelanceOrderPayload<ExtArgs>[]
      referralsMade: Prisma.$ReferralPayload<ExtArgs>[]
      referralsReceived: Prisma.$ReferralPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      description: string | null
      address: string | null
      phone: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["business"]>
    composites: {}
  }

  type BusinessGetPayload<S extends boolean | null | undefined | BusinessDefaultArgs> = $Result.GetResult<Prisma.$BusinessPayload, S>

  type BusinessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessCountAggregateInputType | true
    }

  export interface BusinessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Business'], meta: { name: 'Business' } }
    /**
     * Find zero or one Business that matches the filter.
     * @param {BusinessFindUniqueArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessFindUniqueArgs>(args: SelectSubset<T, BusinessFindUniqueArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Business that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessFindUniqueOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessFindFirstArgs>(args?: SelectSubset<T, BusinessFindFirstArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Business that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindFirstOrThrowArgs} args - Arguments to find a Business
     * @example
     * // Get one Business
     * const business = await prisma.business.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Businesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Businesses
     * const businesses = await prisma.business.findMany()
     * 
     * // Get first 10 Businesses
     * const businesses = await prisma.business.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessWithIdOnly = await prisma.business.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessFindManyArgs>(args?: SelectSubset<T, BusinessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Business.
     * @param {BusinessCreateArgs} args - Arguments to create a Business.
     * @example
     * // Create one Business
     * const Business = await prisma.business.create({
     *   data: {
     *     // ... data to create a Business
     *   }
     * })
     * 
     */
    create<T extends BusinessCreateArgs>(args: SelectSubset<T, BusinessCreateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Businesses.
     * @param {BusinessCreateManyArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessCreateManyArgs>(args?: SelectSubset<T, BusinessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Businesses and returns the data saved in the database.
     * @param {BusinessCreateManyAndReturnArgs} args - Arguments to create many Businesses.
     * @example
     * // Create many Businesses
     * const business = await prisma.business.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Business.
     * @param {BusinessDeleteArgs} args - Arguments to delete one Business.
     * @example
     * // Delete one Business
     * const Business = await prisma.business.delete({
     *   where: {
     *     // ... filter to delete one Business
     *   }
     * })
     * 
     */
    delete<T extends BusinessDeleteArgs>(args: SelectSubset<T, BusinessDeleteArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Business.
     * @param {BusinessUpdateArgs} args - Arguments to update one Business.
     * @example
     * // Update one Business
     * const business = await prisma.business.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUpdateArgs>(args: SelectSubset<T, BusinessUpdateArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Businesses.
     * @param {BusinessDeleteManyArgs} args - Arguments to filter Businesses to delete.
     * @example
     * // Delete a few Businesses
     * const { count } = await prisma.business.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessDeleteManyArgs>(args?: SelectSubset<T, BusinessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUpdateManyArgs>(args: SelectSubset<T, BusinessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Businesses and returns the data updated in the database.
     * @param {BusinessUpdateManyAndReturnArgs} args - Arguments to update many Businesses.
     * @example
     * // Update many Businesses
     * const business = await prisma.business.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Businesses and only return the `id`
     * const businessWithIdOnly = await prisma.business.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Business.
     * @param {BusinessUpsertArgs} args - Arguments to update or create a Business.
     * @example
     * // Update or create a Business
     * const business = await prisma.business.upsert({
     *   create: {
     *     // ... data to create a Business
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Business we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUpsertArgs>(args: SelectSubset<T, BusinessUpsertArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Businesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessCountArgs} args - Arguments to filter Businesses to count.
     * @example
     * // Count the number of Businesses
     * const count = await prisma.business.count({
     *   where: {
     *     // ... the filter for the Businesses we want to count
     *   }
     * })
    **/
    count<T extends BusinessCountArgs>(
      args?: Subset<T, BusinessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessAggregateArgs>(args: Subset<T, BusinessAggregateArgs>): Prisma.PrismaPromise<GetBusinessAggregateType<T>>

    /**
     * Group by Business.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessGroupByArgs['orderBy'] }
        : { orderBy?: BusinessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Business model
   */
  readonly fields: BusinessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Business.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc<T extends Business$kycArgs<ExtArgs> = {}>(args?: Subset<T, Business$kycArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends Business$productsArgs<ExtArgs> = {}>(args?: Subset<T, Business$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workers<T extends Business$workersArgs<ExtArgs> = {}>(args?: Subset<T, Business$workersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    repostedItems<T extends Business$repostedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Business$repostedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reownedItems<T extends Business$reownedItemsArgs<ExtArgs> = {}>(args?: Subset<T, Business$reownedItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recharges<T extends Business$rechargesArgs<ExtArgs> = {}>(args?: Subset<T, Business$rechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ads<T extends Business$adsArgs<ExtArgs> = {}>(args?: Subset<T, Business$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelanceServices<T extends Business$freelanceServicesArgs<ExtArgs> = {}>(args?: Subset<T, Business$freelanceServicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelanceOrders<T extends Business$freelanceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Business$freelanceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsMade<T extends Business$referralsMadeArgs<ExtArgs> = {}>(args?: Subset<T, Business$referralsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsReceived<T extends Business$referralsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Business$referralsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends Business$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Business$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Business model
   */
  interface BusinessFieldRefs {
    readonly id: FieldRef<"Business", 'String'>
    readonly name: FieldRef<"Business", 'String'>
    readonly email: FieldRef<"Business", 'String'>
    readonly description: FieldRef<"Business", 'String'>
    readonly address: FieldRef<"Business", 'String'>
    readonly phone: FieldRef<"Business", 'String'>
    readonly isVerified: FieldRef<"Business", 'Boolean'>
    readonly createdAt: FieldRef<"Business", 'DateTime'>
    readonly updatedAt: FieldRef<"Business", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Business findUnique
   */
  export type BusinessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findUniqueOrThrow
   */
  export type BusinessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business findFirst
   */
  export type BusinessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findFirstOrThrow
   */
  export type BusinessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Business to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Businesses.
     */
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business findMany
   */
  export type BusinessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter, which Businesses to fetch.
     */
    where?: BusinessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Businesses to fetch.
     */
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Businesses.
     */
    cursor?: BusinessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Businesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Businesses.
     */
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * Business create
   */
  export type BusinessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to create a Business.
     */
    data: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
  }

  /**
   * Business createMany
   */
  export type BusinessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business createManyAndReturn
   */
  export type BusinessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to create many Businesses.
     */
    data: BusinessCreateManyInput | BusinessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Business update
   */
  export type BusinessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The data needed to update a Business.
     */
    data: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
    /**
     * Choose, which Business to update.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business updateMany
   */
  export type BusinessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
  }

  /**
   * Business updateManyAndReturn
   */
  export type BusinessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * The data used to update Businesses.
     */
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyInput>
    /**
     * Filter which Businesses to update
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to update.
     */
    limit?: number
  }

  /**
   * Business upsert
   */
  export type BusinessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * The filter to search for the Business to update in case it exists.
     */
    where: BusinessWhereUniqueInput
    /**
     * In case the Business found by the `where` argument doesn't exist, create a new Business with this data.
     */
    create: XOR<BusinessCreateInput, BusinessUncheckedCreateInput>
    /**
     * In case the Business was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUpdateInput, BusinessUncheckedUpdateInput>
  }

  /**
   * Business delete
   */
  export type BusinessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    /**
     * Filter which Business to delete.
     */
    where: BusinessWhereUniqueInput
  }

  /**
   * Business deleteMany
   */
  export type BusinessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Businesses to delete
     */
    where?: BusinessWhereInput
    /**
     * Limit how many Businesses to delete.
     */
    limit?: number
  }

  /**
   * Business.kyc
   */
  export type Business$kycArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    where?: KYCWhereInput
  }

  /**
   * Business.products
   */
  export type Business$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Business.workers
   */
  export type Business$workersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    cursor?: WorkerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Business.repostedItems
   */
  export type Business$repostedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    where?: RepostedProductWhereInput
    orderBy?: RepostedProductOrderByWithRelationInput | RepostedProductOrderByWithRelationInput[]
    cursor?: RepostedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepostedProductScalarFieldEnum | RepostedProductScalarFieldEnum[]
  }

  /**
   * Business.reownedItems
   */
  export type Business$reownedItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    where?: ReOwnedProductWhereInput
    orderBy?: ReOwnedProductOrderByWithRelationInput | ReOwnedProductOrderByWithRelationInput[]
    cursor?: ReOwnedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReOwnedProductScalarFieldEnum | ReOwnedProductScalarFieldEnum[]
  }

  /**
   * Business.recharges
   */
  export type Business$rechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    where?: AccountRechargeWhereInput
    orderBy?: AccountRechargeOrderByWithRelationInput | AccountRechargeOrderByWithRelationInput[]
    cursor?: AccountRechargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountRechargeScalarFieldEnum | AccountRechargeScalarFieldEnum[]
  }

  /**
   * Business.ads
   */
  export type Business$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Business.freelanceServices
   */
  export type Business$freelanceServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    where?: FreelanceServiceWhereInput
    orderBy?: FreelanceServiceOrderByWithRelationInput | FreelanceServiceOrderByWithRelationInput[]
    cursor?: FreelanceServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceServiceScalarFieldEnum | FreelanceServiceScalarFieldEnum[]
  }

  /**
   * Business.freelanceOrders
   */
  export type Business$freelanceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    where?: FreelanceOrderWhereInput
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    cursor?: FreelanceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceOrderScalarFieldEnum | FreelanceOrderScalarFieldEnum[]
  }

  /**
   * Business.referralsMade
   */
  export type Business$referralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Business.referralsReceived
   */
  export type Business$referralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Business.chats
   */
  export type Business$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Business without action
   */
  export type BusinessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    fullName: string | null
    address: string | null
    phone: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    fullName: string | null
    address: string | null
    phone: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    username: number
    email: number
    fullName: number
    address: number
    phone: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    fullName?: true
    address?: true
    phone?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    fullName?: true
    address?: true
    phone?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    fullName?: true
    address?: true
    phone?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    username: string
    email: string
    fullName: string | null
    address: string | null
    phone: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    fullName?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    kyc?: boolean | Client$kycArgs<ExtArgs>
    orders?: boolean | Client$ordersArgs<ExtArgs>
    reviews?: boolean | Client$reviewsArgs<ExtArgs>
    chats?: boolean | Client$chatsArgs<ExtArgs>
    recharges?: boolean | Client$rechargesArgs<ExtArgs>
    freelanceOrders?: boolean | Client$freelanceOrdersArgs<ExtArgs>
    referralsMade?: boolean | Client$referralsMadeArgs<ExtArgs>
    referralsReceived?: boolean | Client$referralsReceivedArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    fullName?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    fullName?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    fullName?: boolean
    address?: boolean
    phone?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "fullName" | "address" | "phone" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kyc?: boolean | Client$kycArgs<ExtArgs>
    orders?: boolean | Client$ordersArgs<ExtArgs>
    reviews?: boolean | Client$reviewsArgs<ExtArgs>
    chats?: boolean | Client$chatsArgs<ExtArgs>
    recharges?: boolean | Client$rechargesArgs<ExtArgs>
    freelanceOrders?: boolean | Client$freelanceOrdersArgs<ExtArgs>
    referralsMade?: boolean | Client$referralsMadeArgs<ExtArgs>
    referralsReceived?: boolean | Client$referralsReceivedArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      kyc: Prisma.$KYCPayload<ExtArgs> | null
      orders: Prisma.$OrderPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      recharges: Prisma.$AccountRechargePayload<ExtArgs>[]
      freelanceOrders: Prisma.$FreelanceOrderPayload<ExtArgs>[]
      referralsMade: Prisma.$ReferralPayload<ExtArgs>[]
      referralsReceived: Prisma.$ReferralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      fullName: string | null
      address: string | null
      phone: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kyc<T extends Client$kycArgs<ExtArgs> = {}>(args?: Subset<T, Client$kycArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    orders<T extends Client$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Client$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Client$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Client$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends Client$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Client$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recharges<T extends Client$rechargesArgs<ExtArgs> = {}>(args?: Subset<T, Client$rechargesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    freelanceOrders<T extends Client$freelanceOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Client$freelanceOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsMade<T extends Client$referralsMadeArgs<ExtArgs> = {}>(args?: Subset<T, Client$referralsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    referralsReceived<T extends Client$referralsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Client$referralsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly username: FieldRef<"Client", 'String'>
    readonly email: FieldRef<"Client", 'String'>
    readonly fullName: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly isVerified: FieldRef<"Client", 'Boolean'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.kyc
   */
  export type Client$kycArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    where?: KYCWhereInput
  }

  /**
   * Client.orders
   */
  export type Client$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Client.reviews
   */
  export type Client$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Client.chats
   */
  export type Client$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Client.recharges
   */
  export type Client$rechargesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    where?: AccountRechargeWhereInput
    orderBy?: AccountRechargeOrderByWithRelationInput | AccountRechargeOrderByWithRelationInput[]
    cursor?: AccountRechargeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountRechargeScalarFieldEnum | AccountRechargeScalarFieldEnum[]
  }

  /**
   * Client.freelanceOrders
   */
  export type Client$freelanceOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    where?: FreelanceOrderWhereInput
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    cursor?: FreelanceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceOrderScalarFieldEnum | FreelanceOrderScalarFieldEnum[]
  }

  /**
   * Client.referralsMade
   */
  export type Client$referralsMadeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Client.referralsReceived
   */
  export type Client$referralsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    cursor?: ReferralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Worker
   */

  export type AggregateWorker = {
    _count: WorkerCountAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  export type WorkerMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    role: string | null
    phone: string | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkerMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    role: string | null
    phone: string | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkerCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    role: number
    phone: number
    businessId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkerMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    role?: true
    phone?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkerMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    role?: true
    phone?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkerCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    role?: true
    phone?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Worker to aggregate.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workers
    **/
    _count?: true | WorkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkerMaxAggregateInputType
  }

  export type GetWorkerAggregateType<T extends WorkerAggregateArgs> = {
        [P in keyof T & keyof AggregateWorker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorker[P]>
      : GetScalarType<T[P], AggregateWorker[P]>
  }




  export type WorkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkerWhereInput
    orderBy?: WorkerOrderByWithAggregationInput | WorkerOrderByWithAggregationInput[]
    by: WorkerScalarFieldEnum[] | WorkerScalarFieldEnum
    having?: WorkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkerCountAggregateInputType | true
    _min?: WorkerMinAggregateInputType
    _max?: WorkerMaxAggregateInputType
  }

  export type WorkerGroupByOutputType = {
    id: string
    email: string
    fullName: string | null
    role: string | null
    phone: string | null
    businessId: string
    createdAt: Date
    updatedAt: Date
    _count: WorkerCountAggregateOutputType | null
    _min: WorkerMinAggregateOutputType | null
    _max: WorkerMaxAggregateOutputType | null
  }

  type GetWorkerGroupByPayload<T extends WorkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkerGroupByOutputType[P]>
            : GetScalarType<T[P], WorkerGroupByOutputType[P]>
        }
      >
    >


  export type WorkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    role?: boolean
    phone?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    kyc?: boolean | Worker$kycArgs<ExtArgs>
    chats?: boolean | Worker$chatsArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    role?: boolean
    phone?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    role?: boolean
    phone?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["worker"]>

  export type WorkerSelectScalar = {
    id?: boolean
    email?: boolean
    fullName?: boolean
    role?: boolean
    phone?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "fullName" | "role" | "phone" | "businessId" | "createdAt" | "updatedAt", ExtArgs["result"]["worker"]>
  export type WorkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    kyc?: boolean | Worker$kycArgs<ExtArgs>
    chats?: boolean | Worker$chatsArgs<ExtArgs>
    _count?: boolean | WorkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type WorkerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $WorkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Worker"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      kyc: Prisma.$KYCPayload<ExtArgs> | null
      chats: Prisma.$ChatPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      fullName: string | null
      role: string | null
      phone: string | null
      businessId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["worker"]>
    composites: {}
  }

  type WorkerGetPayload<S extends boolean | null | undefined | WorkerDefaultArgs> = $Result.GetResult<Prisma.$WorkerPayload, S>

  type WorkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkerCountAggregateInputType | true
    }

  export interface WorkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Worker'], meta: { name: 'Worker' } }
    /**
     * Find zero or one Worker that matches the filter.
     * @param {WorkerFindUniqueArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkerFindUniqueArgs>(args: SelectSubset<T, WorkerFindUniqueArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Worker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkerFindUniqueOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkerFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Worker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkerFindFirstArgs>(args?: SelectSubset<T, WorkerFindFirstArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Worker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindFirstOrThrowArgs} args - Arguments to find a Worker
     * @example
     * // Get one Worker
     * const worker = await prisma.worker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkerFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workers
     * const workers = await prisma.worker.findMany()
     * 
     * // Get first 10 Workers
     * const workers = await prisma.worker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workerWithIdOnly = await prisma.worker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkerFindManyArgs>(args?: SelectSubset<T, WorkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Worker.
     * @param {WorkerCreateArgs} args - Arguments to create a Worker.
     * @example
     * // Create one Worker
     * const Worker = await prisma.worker.create({
     *   data: {
     *     // ... data to create a Worker
     *   }
     * })
     * 
     */
    create<T extends WorkerCreateArgs>(args: SelectSubset<T, WorkerCreateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workers.
     * @param {WorkerCreateManyArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkerCreateManyArgs>(args?: SelectSubset<T, WorkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workers and returns the data saved in the database.
     * @param {WorkerCreateManyAndReturnArgs} args - Arguments to create many Workers.
     * @example
     * // Create many Workers
     * const worker = await prisma.worker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkerCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Worker.
     * @param {WorkerDeleteArgs} args - Arguments to delete one Worker.
     * @example
     * // Delete one Worker
     * const Worker = await prisma.worker.delete({
     *   where: {
     *     // ... filter to delete one Worker
     *   }
     * })
     * 
     */
    delete<T extends WorkerDeleteArgs>(args: SelectSubset<T, WorkerDeleteArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Worker.
     * @param {WorkerUpdateArgs} args - Arguments to update one Worker.
     * @example
     * // Update one Worker
     * const worker = await prisma.worker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkerUpdateArgs>(args: SelectSubset<T, WorkerUpdateArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workers.
     * @param {WorkerDeleteManyArgs} args - Arguments to filter Workers to delete.
     * @example
     * // Delete a few Workers
     * const { count } = await prisma.worker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkerDeleteManyArgs>(args?: SelectSubset<T, WorkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkerUpdateManyArgs>(args: SelectSubset<T, WorkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workers and returns the data updated in the database.
     * @param {WorkerUpdateManyAndReturnArgs} args - Arguments to update many Workers.
     * @example
     * // Update many Workers
     * const worker = await prisma.worker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workers and only return the `id`
     * const workerWithIdOnly = await prisma.worker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkerUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Worker.
     * @param {WorkerUpsertArgs} args - Arguments to update or create a Worker.
     * @example
     * // Update or create a Worker
     * const worker = await prisma.worker.upsert({
     *   create: {
     *     // ... data to create a Worker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Worker we want to update
     *   }
     * })
     */
    upsert<T extends WorkerUpsertArgs>(args: SelectSubset<T, WorkerUpsertArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerCountArgs} args - Arguments to filter Workers to count.
     * @example
     * // Count the number of Workers
     * const count = await prisma.worker.count({
     *   where: {
     *     // ... the filter for the Workers we want to count
     *   }
     * })
    **/
    count<T extends WorkerCountArgs>(
      args?: Subset<T, WorkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkerAggregateArgs>(args: Subset<T, WorkerAggregateArgs>): Prisma.PrismaPromise<GetWorkerAggregateType<T>>

    /**
     * Group by Worker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkerGroupByArgs['orderBy'] }
        : { orderBy?: WorkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Worker model
   */
  readonly fields: WorkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Worker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    kyc<T extends Worker$kycArgs<ExtArgs> = {}>(args?: Subset<T, Worker$kycArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    chats<T extends Worker$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Worker$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Worker model
   */
  interface WorkerFieldRefs {
    readonly id: FieldRef<"Worker", 'String'>
    readonly email: FieldRef<"Worker", 'String'>
    readonly fullName: FieldRef<"Worker", 'String'>
    readonly role: FieldRef<"Worker", 'String'>
    readonly phone: FieldRef<"Worker", 'String'>
    readonly businessId: FieldRef<"Worker", 'String'>
    readonly createdAt: FieldRef<"Worker", 'DateTime'>
    readonly updatedAt: FieldRef<"Worker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Worker findUnique
   */
  export type WorkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findUniqueOrThrow
   */
  export type WorkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker findFirst
   */
  export type WorkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findFirstOrThrow
   */
  export type WorkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Worker to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workers.
     */
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker findMany
   */
  export type WorkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter, which Workers to fetch.
     */
    where?: WorkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workers to fetch.
     */
    orderBy?: WorkerOrderByWithRelationInput | WorkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workers.
     */
    cursor?: WorkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workers.
     */
    skip?: number
    distinct?: WorkerScalarFieldEnum | WorkerScalarFieldEnum[]
  }

  /**
   * Worker create
   */
  export type WorkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Worker.
     */
    data: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
  }

  /**
   * Worker createMany
   */
  export type WorkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Worker createManyAndReturn
   */
  export type WorkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * The data used to create many Workers.
     */
    data: WorkerCreateManyInput | WorkerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worker update
   */
  export type WorkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Worker.
     */
    data: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
    /**
     * Choose, which Worker to update.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker updateMany
   */
  export type WorkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to update.
     */
    limit?: number
  }

  /**
   * Worker updateManyAndReturn
   */
  export type WorkerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * The data used to update Workers.
     */
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyInput>
    /**
     * Filter which Workers to update
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Worker upsert
   */
  export type WorkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Worker to update in case it exists.
     */
    where: WorkerWhereUniqueInput
    /**
     * In case the Worker found by the `where` argument doesn't exist, create a new Worker with this data.
     */
    create: XOR<WorkerCreateInput, WorkerUncheckedCreateInput>
    /**
     * In case the Worker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkerUpdateInput, WorkerUncheckedUpdateInput>
  }

  /**
   * Worker delete
   */
  export type WorkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    /**
     * Filter which Worker to delete.
     */
    where: WorkerWhereUniqueInput
  }

  /**
   * Worker deleteMany
   */
  export type WorkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workers to delete
     */
    where?: WorkerWhereInput
    /**
     * Limit how many Workers to delete.
     */
    limit?: number
  }

  /**
   * Worker.kyc
   */
  export type Worker$kycArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    where?: KYCWhereInput
  }

  /**
   * Worker.chats
   */
  export type Worker$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Worker without action
   */
  export type WorkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    price: number | null
    stock: number | null
    category: string | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    price: number | null
    stock: number | null
    category: string | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    title: number
    description: number
    price: number
    stock: number
    category: number
    businessId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    title: string
    description: string | null
    price: number
    stock: number
    category: string | null
    businessId: string
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    medias?: boolean | Product$mediasArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    chats?: boolean | Product$chatsArgs<ExtArgs>
    reposts?: boolean | Product$repostsArgs<ExtArgs>
    reowns?: boolean | Product$reownsArgs<ExtArgs>
    ads?: boolean | Product$adsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "price" | "stock" | "category" | "businessId" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    medias?: boolean | Product$mediasArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    orders?: boolean | Product$ordersArgs<ExtArgs>
    chats?: boolean | Product$chatsArgs<ExtArgs>
    reposts?: boolean | Product$repostsArgs<ExtArgs>
    reowns?: boolean | Product$reownsArgs<ExtArgs>
    ads?: boolean | Product$adsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      medias: Prisma.$MediaPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      orders: Prisma.$OrderProductPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      reposts: Prisma.$RepostedProductPayload<ExtArgs>[]
      reowns: Prisma.$ReOwnedProductPayload<ExtArgs>[]
      ads: Prisma.$AdPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      price: number
      stock: number
      category: string | null
      businessId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medias<T extends Product$mediasArgs<ExtArgs> = {}>(args?: Subset<T, Product$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orders<T extends Product$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Product$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chats<T extends Product$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Product$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reposts<T extends Product$repostsArgs<ExtArgs> = {}>(args?: Subset<T, Product$repostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reowns<T extends Product$reownsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reownsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ads<T extends Product$adsArgs<ExtArgs> = {}>(args?: Subset<T, Product$adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly title: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly category: FieldRef<"Product", 'String'>
    readonly businessId: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.medias
   */
  export type Product$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    cursor?: MediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Product.orders
   */
  export type Product$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * Product.chats
   */
  export type Product$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Product.reposts
   */
  export type Product$repostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    where?: RepostedProductWhereInput
    orderBy?: RepostedProductOrderByWithRelationInput | RepostedProductOrderByWithRelationInput[]
    cursor?: RepostedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RepostedProductScalarFieldEnum | RepostedProductScalarFieldEnum[]
  }

  /**
   * Product.reowns
   */
  export type Product$reownsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    where?: ReOwnedProductWhereInput
    orderBy?: ReOwnedProductOrderByWithRelationInput | ReOwnedProductOrderByWithRelationInput[]
    cursor?: ReOwnedProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReOwnedProductScalarFieldEnum | ReOwnedProductScalarFieldEnum[]
  }

  /**
   * Product.ads
   */
  export type Product$adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    where?: AdWhereInput
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    cursor?: AdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    url: string | null
    type: $Enums.MediaType | null
    productId: string | null
    createdAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    url: string | null
    type: $Enums.MediaType | null
    productId: string | null
    createdAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    url: number
    type: number
    productId: number
    createdAt: number
    _all: number
  }


  export type MediaMinAggregateInputType = {
    id?: true
    url?: true
    type?: true
    productId?: true
    createdAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    url?: true
    type?: true
    productId?: true
    createdAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    url?: true
    type?: true
    productId?: true
    createdAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    url: string
    type: $Enums.MediaType
    productId: string
    createdAt: Date
    _count: MediaCountAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    productId?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    productId?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    type?: boolean
    productId?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    url?: boolean
    type?: boolean
    productId?: boolean
    createdAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "type" | "productId" | "createdAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      url: string
      type: $Enums.MediaType
      productId: string
      createdAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly type: FieldRef<"Media", 'MediaType'>
    readonly productId: FieldRef<"Media", 'String'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    deliveryFee: number | null
  }

  export type OrderSumAggregateOutputType = {
    deliveryFee: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    deliveryFee: number | null
    deliveryAddress: string | null
    qrCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    deliveryFee: number | null
    deliveryAddress: string | null
    qrCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    clientId: number
    deliveryFee: number
    deliveryAddress: number
    qrCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    deliveryFee?: true
  }

  export type OrderSumAggregateInputType = {
    deliveryFee?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    clientId?: true
    deliveryFee?: true
    deliveryAddress?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    clientId?: true
    deliveryFee?: true
    deliveryAddress?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    clientId?: true
    deliveryFee?: true
    deliveryAddress?: true
    qrCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    clientId: string
    deliveryFee: number
    deliveryAddress: string | null
    qrCode: string | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    deliveryFee?: boolean
    deliveryAddress?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    deliveryFee?: boolean
    deliveryAddress?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    deliveryFee?: boolean
    deliveryAddress?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    clientId?: boolean
    deliveryFee?: boolean
    deliveryAddress?: boolean
    qrCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "deliveryFee" | "deliveryAddress" | "qrCode" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    products?: boolean | Order$productsArgs<ExtArgs>
    payment?: boolean | Order$paymentArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      products: Prisma.$OrderProductPayload<ExtArgs>[]
      payment: Prisma.$PaymentTransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      deliveryFee: number
      deliveryAddress: string | null
      qrCode: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    products<T extends Order$productsArgs<ExtArgs> = {}>(args?: Subset<T, Order$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payment<T extends Order$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Order$paymentArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly clientId: FieldRef<"Order", 'String'>
    readonly deliveryFee: FieldRef<"Order", 'Float'>
    readonly deliveryAddress: FieldRef<"Order", 'String'>
    readonly qrCode: FieldRef<"Order", 'String'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.products
   */
  export type Order$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    cursor?: OrderProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * Order.payment
   */
  export type Order$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderProduct
   */

  export type AggregateOrderProduct = {
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  export type OrderProductAvgAggregateOutputType = {
    quantity: number | null
  }

  export type OrderProductSumAggregateOutputType = {
    quantity: number | null
  }

  export type OrderProductMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
  }

  export type OrderProductMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    productId: string | null
    quantity: number | null
  }

  export type OrderProductCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    _all: number
  }


  export type OrderProductAvgAggregateInputType = {
    quantity?: true
  }

  export type OrderProductSumAggregateInputType = {
    quantity?: true
  }

  export type OrderProductMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
  }

  export type OrderProductMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
  }

  export type OrderProductCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    _all?: true
  }

  export type OrderProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProduct to aggregate.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderProducts
    **/
    _count?: true | OrderProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderProductMaxAggregateInputType
  }

  export type GetOrderProductAggregateType<T extends OrderProductAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderProduct[P]>
      : GetScalarType<T[P], AggregateOrderProduct[P]>
  }




  export type OrderProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderProductWhereInput
    orderBy?: OrderProductOrderByWithAggregationInput | OrderProductOrderByWithAggregationInput[]
    by: OrderProductScalarFieldEnum[] | OrderProductScalarFieldEnum
    having?: OrderProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderProductCountAggregateInputType | true
    _avg?: OrderProductAvgAggregateInputType
    _sum?: OrderProductSumAggregateInputType
    _min?: OrderProductMinAggregateInputType
    _max?: OrderProductMaxAggregateInputType
  }

  export type OrderProductGroupByOutputType = {
    id: string
    orderId: string
    productId: string
    quantity: number
    _count: OrderProductCountAggregateOutputType | null
    _avg: OrderProductAvgAggregateOutputType | null
    _sum: OrderProductSumAggregateOutputType | null
    _min: OrderProductMinAggregateOutputType | null
    _max: OrderProductMaxAggregateOutputType | null
  }

  type GetOrderProductGroupByPayload<T extends OrderProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
            : GetScalarType<T[P], OrderProductGroupByOutputType[P]>
        }
      >
    >


  export type OrderProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderProduct"]>

  export type OrderProductSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
  }

  export type OrderProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "productId" | "quantity", ExtArgs["result"]["orderProduct"]>
  export type OrderProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type OrderProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderProduct"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      productId: string
      quantity: number
    }, ExtArgs["result"]["orderProduct"]>
    composites: {}
  }

  type OrderProductGetPayload<S extends boolean | null | undefined | OrderProductDefaultArgs> = $Result.GetResult<Prisma.$OrderProductPayload, S>

  type OrderProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderProductCountAggregateInputType | true
    }

  export interface OrderProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderProduct'], meta: { name: 'OrderProduct' } }
    /**
     * Find zero or one OrderProduct that matches the filter.
     * @param {OrderProductFindUniqueArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderProductFindUniqueArgs>(args: SelectSubset<T, OrderProductFindUniqueArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderProductFindUniqueOrThrowArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderProductFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderProductFindFirstArgs>(args?: SelectSubset<T, OrderProductFindFirstArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindFirstOrThrowArgs} args - Arguments to find a OrderProduct
     * @example
     * // Get one OrderProduct
     * const orderProduct = await prisma.orderProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderProductFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany()
     * 
     * // Get first 10 OrderProducts
     * const orderProducts = await prisma.orderProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderProductFindManyArgs>(args?: SelectSubset<T, OrderProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderProduct.
     * @param {OrderProductCreateArgs} args - Arguments to create a OrderProduct.
     * @example
     * // Create one OrderProduct
     * const OrderProduct = await prisma.orderProduct.create({
     *   data: {
     *     // ... data to create a OrderProduct
     *   }
     * })
     * 
     */
    create<T extends OrderProductCreateArgs>(args: SelectSubset<T, OrderProductCreateArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderProducts.
     * @param {OrderProductCreateManyArgs} args - Arguments to create many OrderProducts.
     * @example
     * // Create many OrderProducts
     * const orderProduct = await prisma.orderProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderProductCreateManyArgs>(args?: SelectSubset<T, OrderProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderProducts and returns the data saved in the database.
     * @param {OrderProductCreateManyAndReturnArgs} args - Arguments to create many OrderProducts.
     * @example
     * // Create many OrderProducts
     * const orderProduct = await prisma.orderProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderProducts and only return the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderProductCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderProduct.
     * @param {OrderProductDeleteArgs} args - Arguments to delete one OrderProduct.
     * @example
     * // Delete one OrderProduct
     * const OrderProduct = await prisma.orderProduct.delete({
     *   where: {
     *     // ... filter to delete one OrderProduct
     *   }
     * })
     * 
     */
    delete<T extends OrderProductDeleteArgs>(args: SelectSubset<T, OrderProductDeleteArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderProduct.
     * @param {OrderProductUpdateArgs} args - Arguments to update one OrderProduct.
     * @example
     * // Update one OrderProduct
     * const orderProduct = await prisma.orderProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderProductUpdateArgs>(args: SelectSubset<T, OrderProductUpdateArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderProducts.
     * @param {OrderProductDeleteManyArgs} args - Arguments to filter OrderProducts to delete.
     * @example
     * // Delete a few OrderProducts
     * const { count } = await prisma.orderProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderProductDeleteManyArgs>(args?: SelectSubset<T, OrderProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderProducts
     * const orderProduct = await prisma.orderProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderProductUpdateManyArgs>(args: SelectSubset<T, OrderProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderProducts and returns the data updated in the database.
     * @param {OrderProductUpdateManyAndReturnArgs} args - Arguments to update many OrderProducts.
     * @example
     * // Update many OrderProducts
     * const orderProduct = await prisma.orderProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderProducts and only return the `id`
     * const orderProductWithIdOnly = await prisma.orderProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderProductUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderProduct.
     * @param {OrderProductUpsertArgs} args - Arguments to update or create a OrderProduct.
     * @example
     * // Update or create a OrderProduct
     * const orderProduct = await prisma.orderProduct.upsert({
     *   create: {
     *     // ... data to create a OrderProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderProduct we want to update
     *   }
     * })
     */
    upsert<T extends OrderProductUpsertArgs>(args: SelectSubset<T, OrderProductUpsertArgs<ExtArgs>>): Prisma__OrderProductClient<$Result.GetResult<Prisma.$OrderProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductCountArgs} args - Arguments to filter OrderProducts to count.
     * @example
     * // Count the number of OrderProducts
     * const count = await prisma.orderProduct.count({
     *   where: {
     *     // ... the filter for the OrderProducts we want to count
     *   }
     * })
    **/
    count<T extends OrderProductCountArgs>(
      args?: Subset<T, OrderProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderProductAggregateArgs>(args: Subset<T, OrderProductAggregateArgs>): Prisma.PrismaPromise<GetOrderProductAggregateType<T>>

    /**
     * Group by OrderProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderProductGroupByArgs['orderBy'] }
        : { orderBy?: OrderProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderProduct model
   */
  readonly fields: OrderProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderProduct model
   */
  interface OrderProductFieldRefs {
    readonly id: FieldRef<"OrderProduct", 'String'>
    readonly orderId: FieldRef<"OrderProduct", 'String'>
    readonly productId: FieldRef<"OrderProduct", 'String'>
    readonly quantity: FieldRef<"OrderProduct", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderProduct findUnique
   */
  export type OrderProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct findUniqueOrThrow
   */
  export type OrderProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct findFirst
   */
  export type OrderProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     */
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * OrderProduct findFirstOrThrow
   */
  export type OrderProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProduct to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderProducts.
     */
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * OrderProduct findMany
   */
  export type OrderProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter, which OrderProducts to fetch.
     */
    where?: OrderProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderProducts to fetch.
     */
    orderBy?: OrderProductOrderByWithRelationInput | OrderProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderProducts.
     */
    cursor?: OrderProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderProducts.
     */
    skip?: number
    distinct?: OrderProductScalarFieldEnum | OrderProductScalarFieldEnum[]
  }

  /**
   * OrderProduct create
   */
  export type OrderProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderProduct.
     */
    data: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
  }

  /**
   * OrderProduct createMany
   */
  export type OrderProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderProducts.
     */
    data: OrderProductCreateManyInput | OrderProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderProduct createManyAndReturn
   */
  export type OrderProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * The data used to create many OrderProducts.
     */
    data: OrderProductCreateManyInput | OrderProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderProduct update
   */
  export type OrderProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderProduct.
     */
    data: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
    /**
     * Choose, which OrderProduct to update.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct updateMany
   */
  export type OrderProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderProducts.
     */
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyInput>
    /**
     * Filter which OrderProducts to update
     */
    where?: OrderProductWhereInput
    /**
     * Limit how many OrderProducts to update.
     */
    limit?: number
  }

  /**
   * OrderProduct updateManyAndReturn
   */
  export type OrderProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * The data used to update OrderProducts.
     */
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyInput>
    /**
     * Filter which OrderProducts to update
     */
    where?: OrderProductWhereInput
    /**
     * Limit how many OrderProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderProduct upsert
   */
  export type OrderProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderProduct to update in case it exists.
     */
    where: OrderProductWhereUniqueInput
    /**
     * In case the OrderProduct found by the `where` argument doesn't exist, create a new OrderProduct with this data.
     */
    create: XOR<OrderProductCreateInput, OrderProductUncheckedCreateInput>
    /**
     * In case the OrderProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderProductUpdateInput, OrderProductUncheckedUpdateInput>
  }

  /**
   * OrderProduct delete
   */
  export type OrderProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
    /**
     * Filter which OrderProduct to delete.
     */
    where: OrderProductWhereUniqueInput
  }

  /**
   * OrderProduct deleteMany
   */
  export type OrderProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderProducts to delete
     */
    where?: OrderProductWhereInput
    /**
     * Limit how many OrderProducts to delete.
     */
    limit?: number
  }

  /**
   * OrderProduct without action
   */
  export type OrderProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderProduct
     */
    select?: OrderProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderProduct
     */
    omit?: OrderProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderProductInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    productId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    productId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    clientId: number
    productId: number
    rating: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    clientId?: true
    productId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    clientId?: true
    productId?: true
    rating?: true
    comment?: true
    createdAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    clientId?: true
    productId?: true
    rating?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    clientId: string
    productId: string
    rating: number
    comment: string | null
    createdAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    clientId?: boolean
    productId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "productId" | "rating" | "comment" | "createdAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      productId: string
      rating: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly clientId: FieldRef<"Review", 'String'>
    readonly productId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    productId: string | null
    businessId: string | null
    workerId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    productId: string | null
    businessId: string | null
    workerId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    clientId: number
    productId: number
    businessId: number
    workerId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMinAggregateInputType = {
    id?: true
    clientId?: true
    productId?: true
    businessId?: true
    workerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    clientId?: true
    productId?: true
    businessId?: true
    workerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    clientId?: true
    productId?: true
    businessId?: true
    workerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    clientId: string
    productId: string
    businessId: string | null
    workerId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: ChatCountAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    productId?: boolean
    businessId?: boolean
    workerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    business?: boolean | Chat$businessArgs<ExtArgs>
    worker?: boolean | Chat$workerArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    productId?: boolean
    businessId?: boolean
    workerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    business?: boolean | Chat$businessArgs<ExtArgs>
    worker?: boolean | Chat$workerArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    productId?: boolean
    businessId?: boolean
    workerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    business?: boolean | Chat$businessArgs<ExtArgs>
    worker?: boolean | Chat$workerArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    clientId?: boolean
    productId?: boolean
    businessId?: boolean
    workerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "productId" | "businessId" | "workerId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["chat"]>
  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    business?: boolean | Chat$businessArgs<ExtArgs>
    worker?: boolean | Chat$workerArgs<ExtArgs>
    messages?: boolean | Chat$messagesArgs<ExtArgs>
    _count?: boolean | ChatCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    business?: boolean | Chat$businessArgs<ExtArgs>
    worker?: boolean | Chat$workerArgs<ExtArgs>
  }
  export type ChatIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    business?: boolean | Chat$businessArgs<ExtArgs>
    worker?: boolean | Chat$workerArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
      business: Prisma.$BusinessPayload<ExtArgs> | null
      worker: Prisma.$WorkerPayload<ExtArgs> | null
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      productId: string
      businessId: string | null
      workerId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {ChatUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    business<T extends Chat$businessArgs<ExtArgs> = {}>(args?: Subset<T, Chat$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends Chat$workerArgs<ExtArgs> = {}>(args?: Subset<T, Chat$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    messages<T extends Chat$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Chat$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly clientId: FieldRef<"Chat", 'String'>
    readonly productId: FieldRef<"Chat", 'String'>
    readonly businessId: FieldRef<"Chat", 'String'>
    readonly workerId: FieldRef<"Chat", 'String'>
    readonly status: FieldRef<"Chat", 'String'>
    readonly createdAt: FieldRef<"Chat", 'DateTime'>
    readonly updatedAt: FieldRef<"Chat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
  }

  /**
   * Chat updateManyAndReturn
   */
  export type ChatUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
    /**
     * Limit how many Chats to delete.
     */
    limit?: number
  }

  /**
   * Chat.business
   */
  export type Chat$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Chat.worker
   */
  export type Chat$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * Chat.messages
   */
  export type Chat$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Chat
     */
    omit?: ChatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    message: string | null
    senderId: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    message: string | null
    senderId: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    chatId: number
    message: number
    senderId: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    chatId?: true
    message?: true
    senderId?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    chatId?: true
    message?: true
    senderId?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    chatId?: true
    message?: true
    senderId?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    chatId: string
    message: string
    senderId: string | null
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    message?: boolean
    senderId?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    message?: boolean
    senderId?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    message?: boolean
    senderId?: boolean
    createdAt?: boolean
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    chatId?: boolean
    message?: boolean
    senderId?: boolean
    createdAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "message" | "senderId" | "createdAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat?: boolean | ChatDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      chat: Prisma.$ChatPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string
      message: string
      senderId: string | null
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat<T extends ChatDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatDefaultArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly chatId: FieldRef<"ChatMessage", 'String'>
    readonly message: FieldRef<"ChatMessage", 'String'>
    readonly senderId: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model RepostedProduct
   */

  export type AggregateRepostedProduct = {
    _count: RepostedProductCountAggregateOutputType | null
    _avg: RepostedProductAvgAggregateOutputType | null
    _sum: RepostedProductSumAggregateOutputType | null
    _min: RepostedProductMinAggregateOutputType | null
    _max: RepostedProductMaxAggregateOutputType | null
  }

  export type RepostedProductAvgAggregateOutputType = {
    earnPercentage: number | null
  }

  export type RepostedProductSumAggregateOutputType = {
    earnPercentage: number | null
  }

  export type RepostedProductMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    productId: string | null
    earnPercentage: number | null
    createdAt: Date | null
  }

  export type RepostedProductMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    productId: string | null
    earnPercentage: number | null
    createdAt: Date | null
  }

  export type RepostedProductCountAggregateOutputType = {
    id: number
    businessId: number
    productId: number
    earnPercentage: number
    createdAt: number
    _all: number
  }


  export type RepostedProductAvgAggregateInputType = {
    earnPercentage?: true
  }

  export type RepostedProductSumAggregateInputType = {
    earnPercentage?: true
  }

  export type RepostedProductMinAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    earnPercentage?: true
    createdAt?: true
  }

  export type RepostedProductMaxAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    earnPercentage?: true
    createdAt?: true
  }

  export type RepostedProductCountAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    earnPercentage?: true
    createdAt?: true
    _all?: true
  }

  export type RepostedProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepostedProduct to aggregate.
     */
    where?: RepostedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepostedProducts to fetch.
     */
    orderBy?: RepostedProductOrderByWithRelationInput | RepostedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RepostedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepostedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepostedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RepostedProducts
    **/
    _count?: true | RepostedProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RepostedProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RepostedProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RepostedProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RepostedProductMaxAggregateInputType
  }

  export type GetRepostedProductAggregateType<T extends RepostedProductAggregateArgs> = {
        [P in keyof T & keyof AggregateRepostedProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRepostedProduct[P]>
      : GetScalarType<T[P], AggregateRepostedProduct[P]>
  }




  export type RepostedProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RepostedProductWhereInput
    orderBy?: RepostedProductOrderByWithAggregationInput | RepostedProductOrderByWithAggregationInput[]
    by: RepostedProductScalarFieldEnum[] | RepostedProductScalarFieldEnum
    having?: RepostedProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RepostedProductCountAggregateInputType | true
    _avg?: RepostedProductAvgAggregateInputType
    _sum?: RepostedProductSumAggregateInputType
    _min?: RepostedProductMinAggregateInputType
    _max?: RepostedProductMaxAggregateInputType
  }

  export type RepostedProductGroupByOutputType = {
    id: string
    businessId: string
    productId: string
    earnPercentage: number
    createdAt: Date
    _count: RepostedProductCountAggregateOutputType | null
    _avg: RepostedProductAvgAggregateOutputType | null
    _sum: RepostedProductSumAggregateOutputType | null
    _min: RepostedProductMinAggregateOutputType | null
    _max: RepostedProductMaxAggregateOutputType | null
  }

  type GetRepostedProductGroupByPayload<T extends RepostedProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RepostedProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RepostedProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RepostedProductGroupByOutputType[P]>
            : GetScalarType<T[P], RepostedProductGroupByOutputType[P]>
        }
      >
    >


  export type RepostedProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    earnPercentage?: boolean
    createdAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repostedProduct"]>

  export type RepostedProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    earnPercentage?: boolean
    createdAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repostedProduct"]>

  export type RepostedProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    earnPercentage?: boolean
    createdAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["repostedProduct"]>

  export type RepostedProductSelectScalar = {
    id?: boolean
    businessId?: boolean
    productId?: boolean
    earnPercentage?: boolean
    createdAt?: boolean
  }

  export type RepostedProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "productId" | "earnPercentage" | "createdAt", ExtArgs["result"]["repostedProduct"]>
  export type RepostedProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RepostedProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type RepostedProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $RepostedProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RepostedProduct"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      productId: string
      earnPercentage: number
      createdAt: Date
    }, ExtArgs["result"]["repostedProduct"]>
    composites: {}
  }

  type RepostedProductGetPayload<S extends boolean | null | undefined | RepostedProductDefaultArgs> = $Result.GetResult<Prisma.$RepostedProductPayload, S>

  type RepostedProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RepostedProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RepostedProductCountAggregateInputType | true
    }

  export interface RepostedProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RepostedProduct'], meta: { name: 'RepostedProduct' } }
    /**
     * Find zero or one RepostedProduct that matches the filter.
     * @param {RepostedProductFindUniqueArgs} args - Arguments to find a RepostedProduct
     * @example
     * // Get one RepostedProduct
     * const repostedProduct = await prisma.repostedProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RepostedProductFindUniqueArgs>(args: SelectSubset<T, RepostedProductFindUniqueArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RepostedProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RepostedProductFindUniqueOrThrowArgs} args - Arguments to find a RepostedProduct
     * @example
     * // Get one RepostedProduct
     * const repostedProduct = await prisma.repostedProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RepostedProductFindUniqueOrThrowArgs>(args: SelectSubset<T, RepostedProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RepostedProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductFindFirstArgs} args - Arguments to find a RepostedProduct
     * @example
     * // Get one RepostedProduct
     * const repostedProduct = await prisma.repostedProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RepostedProductFindFirstArgs>(args?: SelectSubset<T, RepostedProductFindFirstArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RepostedProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductFindFirstOrThrowArgs} args - Arguments to find a RepostedProduct
     * @example
     * // Get one RepostedProduct
     * const repostedProduct = await prisma.repostedProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RepostedProductFindFirstOrThrowArgs>(args?: SelectSubset<T, RepostedProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RepostedProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RepostedProducts
     * const repostedProducts = await prisma.repostedProduct.findMany()
     * 
     * // Get first 10 RepostedProducts
     * const repostedProducts = await prisma.repostedProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const repostedProductWithIdOnly = await prisma.repostedProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RepostedProductFindManyArgs>(args?: SelectSubset<T, RepostedProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RepostedProduct.
     * @param {RepostedProductCreateArgs} args - Arguments to create a RepostedProduct.
     * @example
     * // Create one RepostedProduct
     * const RepostedProduct = await prisma.repostedProduct.create({
     *   data: {
     *     // ... data to create a RepostedProduct
     *   }
     * })
     * 
     */
    create<T extends RepostedProductCreateArgs>(args: SelectSubset<T, RepostedProductCreateArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RepostedProducts.
     * @param {RepostedProductCreateManyArgs} args - Arguments to create many RepostedProducts.
     * @example
     * // Create many RepostedProducts
     * const repostedProduct = await prisma.repostedProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RepostedProductCreateManyArgs>(args?: SelectSubset<T, RepostedProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RepostedProducts and returns the data saved in the database.
     * @param {RepostedProductCreateManyAndReturnArgs} args - Arguments to create many RepostedProducts.
     * @example
     * // Create many RepostedProducts
     * const repostedProduct = await prisma.repostedProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RepostedProducts and only return the `id`
     * const repostedProductWithIdOnly = await prisma.repostedProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RepostedProductCreateManyAndReturnArgs>(args?: SelectSubset<T, RepostedProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RepostedProduct.
     * @param {RepostedProductDeleteArgs} args - Arguments to delete one RepostedProduct.
     * @example
     * // Delete one RepostedProduct
     * const RepostedProduct = await prisma.repostedProduct.delete({
     *   where: {
     *     // ... filter to delete one RepostedProduct
     *   }
     * })
     * 
     */
    delete<T extends RepostedProductDeleteArgs>(args: SelectSubset<T, RepostedProductDeleteArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RepostedProduct.
     * @param {RepostedProductUpdateArgs} args - Arguments to update one RepostedProduct.
     * @example
     * // Update one RepostedProduct
     * const repostedProduct = await prisma.repostedProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RepostedProductUpdateArgs>(args: SelectSubset<T, RepostedProductUpdateArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RepostedProducts.
     * @param {RepostedProductDeleteManyArgs} args - Arguments to filter RepostedProducts to delete.
     * @example
     * // Delete a few RepostedProducts
     * const { count } = await prisma.repostedProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RepostedProductDeleteManyArgs>(args?: SelectSubset<T, RepostedProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepostedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RepostedProducts
     * const repostedProduct = await prisma.repostedProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RepostedProductUpdateManyArgs>(args: SelectSubset<T, RepostedProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RepostedProducts and returns the data updated in the database.
     * @param {RepostedProductUpdateManyAndReturnArgs} args - Arguments to update many RepostedProducts.
     * @example
     * // Update many RepostedProducts
     * const repostedProduct = await prisma.repostedProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RepostedProducts and only return the `id`
     * const repostedProductWithIdOnly = await prisma.repostedProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RepostedProductUpdateManyAndReturnArgs>(args: SelectSubset<T, RepostedProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RepostedProduct.
     * @param {RepostedProductUpsertArgs} args - Arguments to update or create a RepostedProduct.
     * @example
     * // Update or create a RepostedProduct
     * const repostedProduct = await prisma.repostedProduct.upsert({
     *   create: {
     *     // ... data to create a RepostedProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RepostedProduct we want to update
     *   }
     * })
     */
    upsert<T extends RepostedProductUpsertArgs>(args: SelectSubset<T, RepostedProductUpsertArgs<ExtArgs>>): Prisma__RepostedProductClient<$Result.GetResult<Prisma.$RepostedProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RepostedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductCountArgs} args - Arguments to filter RepostedProducts to count.
     * @example
     * // Count the number of RepostedProducts
     * const count = await prisma.repostedProduct.count({
     *   where: {
     *     // ... the filter for the RepostedProducts we want to count
     *   }
     * })
    **/
    count<T extends RepostedProductCountArgs>(
      args?: Subset<T, RepostedProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RepostedProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RepostedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RepostedProductAggregateArgs>(args: Subset<T, RepostedProductAggregateArgs>): Prisma.PrismaPromise<GetRepostedProductAggregateType<T>>

    /**
     * Group by RepostedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RepostedProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RepostedProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RepostedProductGroupByArgs['orderBy'] }
        : { orderBy?: RepostedProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RepostedProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRepostedProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RepostedProduct model
   */
  readonly fields: RepostedProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RepostedProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RepostedProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RepostedProduct model
   */
  interface RepostedProductFieldRefs {
    readonly id: FieldRef<"RepostedProduct", 'String'>
    readonly businessId: FieldRef<"RepostedProduct", 'String'>
    readonly productId: FieldRef<"RepostedProduct", 'String'>
    readonly earnPercentage: FieldRef<"RepostedProduct", 'Float'>
    readonly createdAt: FieldRef<"RepostedProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RepostedProduct findUnique
   */
  export type RepostedProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * Filter, which RepostedProduct to fetch.
     */
    where: RepostedProductWhereUniqueInput
  }

  /**
   * RepostedProduct findUniqueOrThrow
   */
  export type RepostedProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * Filter, which RepostedProduct to fetch.
     */
    where: RepostedProductWhereUniqueInput
  }

  /**
   * RepostedProduct findFirst
   */
  export type RepostedProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * Filter, which RepostedProduct to fetch.
     */
    where?: RepostedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepostedProducts to fetch.
     */
    orderBy?: RepostedProductOrderByWithRelationInput | RepostedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepostedProducts.
     */
    cursor?: RepostedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepostedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepostedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepostedProducts.
     */
    distinct?: RepostedProductScalarFieldEnum | RepostedProductScalarFieldEnum[]
  }

  /**
   * RepostedProduct findFirstOrThrow
   */
  export type RepostedProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * Filter, which RepostedProduct to fetch.
     */
    where?: RepostedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepostedProducts to fetch.
     */
    orderBy?: RepostedProductOrderByWithRelationInput | RepostedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RepostedProducts.
     */
    cursor?: RepostedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepostedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepostedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RepostedProducts.
     */
    distinct?: RepostedProductScalarFieldEnum | RepostedProductScalarFieldEnum[]
  }

  /**
   * RepostedProduct findMany
   */
  export type RepostedProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * Filter, which RepostedProducts to fetch.
     */
    where?: RepostedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RepostedProducts to fetch.
     */
    orderBy?: RepostedProductOrderByWithRelationInput | RepostedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RepostedProducts.
     */
    cursor?: RepostedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RepostedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RepostedProducts.
     */
    skip?: number
    distinct?: RepostedProductScalarFieldEnum | RepostedProductScalarFieldEnum[]
  }

  /**
   * RepostedProduct create
   */
  export type RepostedProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * The data needed to create a RepostedProduct.
     */
    data: XOR<RepostedProductCreateInput, RepostedProductUncheckedCreateInput>
  }

  /**
   * RepostedProduct createMany
   */
  export type RepostedProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RepostedProducts.
     */
    data: RepostedProductCreateManyInput | RepostedProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RepostedProduct createManyAndReturn
   */
  export type RepostedProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * The data used to create many RepostedProducts.
     */
    data: RepostedProductCreateManyInput | RepostedProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RepostedProduct update
   */
  export type RepostedProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * The data needed to update a RepostedProduct.
     */
    data: XOR<RepostedProductUpdateInput, RepostedProductUncheckedUpdateInput>
    /**
     * Choose, which RepostedProduct to update.
     */
    where: RepostedProductWhereUniqueInput
  }

  /**
   * RepostedProduct updateMany
   */
  export type RepostedProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RepostedProducts.
     */
    data: XOR<RepostedProductUpdateManyMutationInput, RepostedProductUncheckedUpdateManyInput>
    /**
     * Filter which RepostedProducts to update
     */
    where?: RepostedProductWhereInput
    /**
     * Limit how many RepostedProducts to update.
     */
    limit?: number
  }

  /**
   * RepostedProduct updateManyAndReturn
   */
  export type RepostedProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * The data used to update RepostedProducts.
     */
    data: XOR<RepostedProductUpdateManyMutationInput, RepostedProductUncheckedUpdateManyInput>
    /**
     * Filter which RepostedProducts to update
     */
    where?: RepostedProductWhereInput
    /**
     * Limit how many RepostedProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RepostedProduct upsert
   */
  export type RepostedProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * The filter to search for the RepostedProduct to update in case it exists.
     */
    where: RepostedProductWhereUniqueInput
    /**
     * In case the RepostedProduct found by the `where` argument doesn't exist, create a new RepostedProduct with this data.
     */
    create: XOR<RepostedProductCreateInput, RepostedProductUncheckedCreateInput>
    /**
     * In case the RepostedProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RepostedProductUpdateInput, RepostedProductUncheckedUpdateInput>
  }

  /**
   * RepostedProduct delete
   */
  export type RepostedProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
    /**
     * Filter which RepostedProduct to delete.
     */
    where: RepostedProductWhereUniqueInput
  }

  /**
   * RepostedProduct deleteMany
   */
  export type RepostedProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RepostedProducts to delete
     */
    where?: RepostedProductWhereInput
    /**
     * Limit how many RepostedProducts to delete.
     */
    limit?: number
  }

  /**
   * RepostedProduct without action
   */
  export type RepostedProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RepostedProduct
     */
    select?: RepostedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RepostedProduct
     */
    omit?: RepostedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RepostedProductInclude<ExtArgs> | null
  }


  /**
   * Model ReOwnedProduct
   */

  export type AggregateReOwnedProduct = {
    _count: ReOwnedProductCountAggregateOutputType | null
    _avg: ReOwnedProductAvgAggregateOutputType | null
    _sum: ReOwnedProductSumAggregateOutputType | null
    _min: ReOwnedProductMinAggregateOutputType | null
    _max: ReOwnedProductMaxAggregateOutputType | null
  }

  export type ReOwnedProductAvgAggregateOutputType = {
    oldPrice: number | null
    newPrice: number | null
    markupPercentage: number | null
  }

  export type ReOwnedProductSumAggregateOutputType = {
    oldPrice: number | null
    newPrice: number | null
    markupPercentage: number | null
  }

  export type ReOwnedProductMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    productId: string | null
    oldOwnerId: string | null
    oldPrice: number | null
    newPrice: number | null
    markupPercentage: number | null
    agreedViaChatId: string | null
    createdAt: Date | null
  }

  export type ReOwnedProductMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    productId: string | null
    oldOwnerId: string | null
    oldPrice: number | null
    newPrice: number | null
    markupPercentage: number | null
    agreedViaChatId: string | null
    createdAt: Date | null
  }

  export type ReOwnedProductCountAggregateOutputType = {
    id: number
    businessId: number
    productId: number
    oldOwnerId: number
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: number
    createdAt: number
    _all: number
  }


  export type ReOwnedProductAvgAggregateInputType = {
    oldPrice?: true
    newPrice?: true
    markupPercentage?: true
  }

  export type ReOwnedProductSumAggregateInputType = {
    oldPrice?: true
    newPrice?: true
    markupPercentage?: true
  }

  export type ReOwnedProductMinAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    oldOwnerId?: true
    oldPrice?: true
    newPrice?: true
    markupPercentage?: true
    agreedViaChatId?: true
    createdAt?: true
  }

  export type ReOwnedProductMaxAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    oldOwnerId?: true
    oldPrice?: true
    newPrice?: true
    markupPercentage?: true
    agreedViaChatId?: true
    createdAt?: true
  }

  export type ReOwnedProductCountAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    oldOwnerId?: true
    oldPrice?: true
    newPrice?: true
    markupPercentage?: true
    agreedViaChatId?: true
    createdAt?: true
    _all?: true
  }

  export type ReOwnedProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReOwnedProduct to aggregate.
     */
    where?: ReOwnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReOwnedProducts to fetch.
     */
    orderBy?: ReOwnedProductOrderByWithRelationInput | ReOwnedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReOwnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReOwnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReOwnedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReOwnedProducts
    **/
    _count?: true | ReOwnedProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReOwnedProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReOwnedProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReOwnedProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReOwnedProductMaxAggregateInputType
  }

  export type GetReOwnedProductAggregateType<T extends ReOwnedProductAggregateArgs> = {
        [P in keyof T & keyof AggregateReOwnedProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReOwnedProduct[P]>
      : GetScalarType<T[P], AggregateReOwnedProduct[P]>
  }




  export type ReOwnedProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReOwnedProductWhereInput
    orderBy?: ReOwnedProductOrderByWithAggregationInput | ReOwnedProductOrderByWithAggregationInput[]
    by: ReOwnedProductScalarFieldEnum[] | ReOwnedProductScalarFieldEnum
    having?: ReOwnedProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReOwnedProductCountAggregateInputType | true
    _avg?: ReOwnedProductAvgAggregateInputType
    _sum?: ReOwnedProductSumAggregateInputType
    _min?: ReOwnedProductMinAggregateInputType
    _max?: ReOwnedProductMaxAggregateInputType
  }

  export type ReOwnedProductGroupByOutputType = {
    id: string
    businessId: string
    productId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt: Date
    _count: ReOwnedProductCountAggregateOutputType | null
    _avg: ReOwnedProductAvgAggregateOutputType | null
    _sum: ReOwnedProductSumAggregateOutputType | null
    _min: ReOwnedProductMinAggregateOutputType | null
    _max: ReOwnedProductMaxAggregateOutputType | null
  }

  type GetReOwnedProductGroupByPayload<T extends ReOwnedProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReOwnedProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReOwnedProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReOwnedProductGroupByOutputType[P]>
            : GetScalarType<T[P], ReOwnedProductGroupByOutputType[P]>
        }
      >
    >


  export type ReOwnedProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    oldOwnerId?: boolean
    oldPrice?: boolean
    newPrice?: boolean
    markupPercentage?: boolean
    agreedViaChatId?: boolean
    createdAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reOwnedProduct"]>

  export type ReOwnedProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    oldOwnerId?: boolean
    oldPrice?: boolean
    newPrice?: boolean
    markupPercentage?: boolean
    agreedViaChatId?: boolean
    createdAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reOwnedProduct"]>

  export type ReOwnedProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    oldOwnerId?: boolean
    oldPrice?: boolean
    newPrice?: boolean
    markupPercentage?: boolean
    agreedViaChatId?: boolean
    createdAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reOwnedProduct"]>

  export type ReOwnedProductSelectScalar = {
    id?: boolean
    businessId?: boolean
    productId?: boolean
    oldOwnerId?: boolean
    oldPrice?: boolean
    newPrice?: boolean
    markupPercentage?: boolean
    agreedViaChatId?: boolean
    createdAt?: boolean
  }

  export type ReOwnedProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "productId" | "oldOwnerId" | "oldPrice" | "newPrice" | "markupPercentage" | "agreedViaChatId" | "createdAt", ExtArgs["result"]["reOwnedProduct"]>
  export type ReOwnedProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReOwnedProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReOwnedProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ReOwnedProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReOwnedProduct"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      productId: string
      oldOwnerId: string
      oldPrice: number
      newPrice: number
      markupPercentage: number
      agreedViaChatId: string
      createdAt: Date
    }, ExtArgs["result"]["reOwnedProduct"]>
    composites: {}
  }

  type ReOwnedProductGetPayload<S extends boolean | null | undefined | ReOwnedProductDefaultArgs> = $Result.GetResult<Prisma.$ReOwnedProductPayload, S>

  type ReOwnedProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReOwnedProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReOwnedProductCountAggregateInputType | true
    }

  export interface ReOwnedProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReOwnedProduct'], meta: { name: 'ReOwnedProduct' } }
    /**
     * Find zero or one ReOwnedProduct that matches the filter.
     * @param {ReOwnedProductFindUniqueArgs} args - Arguments to find a ReOwnedProduct
     * @example
     * // Get one ReOwnedProduct
     * const reOwnedProduct = await prisma.reOwnedProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReOwnedProductFindUniqueArgs>(args: SelectSubset<T, ReOwnedProductFindUniqueArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReOwnedProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReOwnedProductFindUniqueOrThrowArgs} args - Arguments to find a ReOwnedProduct
     * @example
     * // Get one ReOwnedProduct
     * const reOwnedProduct = await prisma.reOwnedProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReOwnedProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ReOwnedProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReOwnedProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductFindFirstArgs} args - Arguments to find a ReOwnedProduct
     * @example
     * // Get one ReOwnedProduct
     * const reOwnedProduct = await prisma.reOwnedProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReOwnedProductFindFirstArgs>(args?: SelectSubset<T, ReOwnedProductFindFirstArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReOwnedProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductFindFirstOrThrowArgs} args - Arguments to find a ReOwnedProduct
     * @example
     * // Get one ReOwnedProduct
     * const reOwnedProduct = await prisma.reOwnedProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReOwnedProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ReOwnedProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReOwnedProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReOwnedProducts
     * const reOwnedProducts = await prisma.reOwnedProduct.findMany()
     * 
     * // Get first 10 ReOwnedProducts
     * const reOwnedProducts = await prisma.reOwnedProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reOwnedProductWithIdOnly = await prisma.reOwnedProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReOwnedProductFindManyArgs>(args?: SelectSubset<T, ReOwnedProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReOwnedProduct.
     * @param {ReOwnedProductCreateArgs} args - Arguments to create a ReOwnedProduct.
     * @example
     * // Create one ReOwnedProduct
     * const ReOwnedProduct = await prisma.reOwnedProduct.create({
     *   data: {
     *     // ... data to create a ReOwnedProduct
     *   }
     * })
     * 
     */
    create<T extends ReOwnedProductCreateArgs>(args: SelectSubset<T, ReOwnedProductCreateArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReOwnedProducts.
     * @param {ReOwnedProductCreateManyArgs} args - Arguments to create many ReOwnedProducts.
     * @example
     * // Create many ReOwnedProducts
     * const reOwnedProduct = await prisma.reOwnedProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReOwnedProductCreateManyArgs>(args?: SelectSubset<T, ReOwnedProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReOwnedProducts and returns the data saved in the database.
     * @param {ReOwnedProductCreateManyAndReturnArgs} args - Arguments to create many ReOwnedProducts.
     * @example
     * // Create many ReOwnedProducts
     * const reOwnedProduct = await prisma.reOwnedProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReOwnedProducts and only return the `id`
     * const reOwnedProductWithIdOnly = await prisma.reOwnedProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReOwnedProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ReOwnedProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReOwnedProduct.
     * @param {ReOwnedProductDeleteArgs} args - Arguments to delete one ReOwnedProduct.
     * @example
     * // Delete one ReOwnedProduct
     * const ReOwnedProduct = await prisma.reOwnedProduct.delete({
     *   where: {
     *     // ... filter to delete one ReOwnedProduct
     *   }
     * })
     * 
     */
    delete<T extends ReOwnedProductDeleteArgs>(args: SelectSubset<T, ReOwnedProductDeleteArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReOwnedProduct.
     * @param {ReOwnedProductUpdateArgs} args - Arguments to update one ReOwnedProduct.
     * @example
     * // Update one ReOwnedProduct
     * const reOwnedProduct = await prisma.reOwnedProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReOwnedProductUpdateArgs>(args: SelectSubset<T, ReOwnedProductUpdateArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReOwnedProducts.
     * @param {ReOwnedProductDeleteManyArgs} args - Arguments to filter ReOwnedProducts to delete.
     * @example
     * // Delete a few ReOwnedProducts
     * const { count } = await prisma.reOwnedProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReOwnedProductDeleteManyArgs>(args?: SelectSubset<T, ReOwnedProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReOwnedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReOwnedProducts
     * const reOwnedProduct = await prisma.reOwnedProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReOwnedProductUpdateManyArgs>(args: SelectSubset<T, ReOwnedProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReOwnedProducts and returns the data updated in the database.
     * @param {ReOwnedProductUpdateManyAndReturnArgs} args - Arguments to update many ReOwnedProducts.
     * @example
     * // Update many ReOwnedProducts
     * const reOwnedProduct = await prisma.reOwnedProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReOwnedProducts and only return the `id`
     * const reOwnedProductWithIdOnly = await prisma.reOwnedProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReOwnedProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ReOwnedProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReOwnedProduct.
     * @param {ReOwnedProductUpsertArgs} args - Arguments to update or create a ReOwnedProduct.
     * @example
     * // Update or create a ReOwnedProduct
     * const reOwnedProduct = await prisma.reOwnedProduct.upsert({
     *   create: {
     *     // ... data to create a ReOwnedProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReOwnedProduct we want to update
     *   }
     * })
     */
    upsert<T extends ReOwnedProductUpsertArgs>(args: SelectSubset<T, ReOwnedProductUpsertArgs<ExtArgs>>): Prisma__ReOwnedProductClient<$Result.GetResult<Prisma.$ReOwnedProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReOwnedProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductCountArgs} args - Arguments to filter ReOwnedProducts to count.
     * @example
     * // Count the number of ReOwnedProducts
     * const count = await prisma.reOwnedProduct.count({
     *   where: {
     *     // ... the filter for the ReOwnedProducts we want to count
     *   }
     * })
    **/
    count<T extends ReOwnedProductCountArgs>(
      args?: Subset<T, ReOwnedProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReOwnedProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReOwnedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReOwnedProductAggregateArgs>(args: Subset<T, ReOwnedProductAggregateArgs>): Prisma.PrismaPromise<GetReOwnedProductAggregateType<T>>

    /**
     * Group by ReOwnedProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReOwnedProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReOwnedProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReOwnedProductGroupByArgs['orderBy'] }
        : { orderBy?: ReOwnedProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReOwnedProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReOwnedProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReOwnedProduct model
   */
  readonly fields: ReOwnedProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReOwnedProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReOwnedProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReOwnedProduct model
   */
  interface ReOwnedProductFieldRefs {
    readonly id: FieldRef<"ReOwnedProduct", 'String'>
    readonly businessId: FieldRef<"ReOwnedProduct", 'String'>
    readonly productId: FieldRef<"ReOwnedProduct", 'String'>
    readonly oldOwnerId: FieldRef<"ReOwnedProduct", 'String'>
    readonly oldPrice: FieldRef<"ReOwnedProduct", 'Float'>
    readonly newPrice: FieldRef<"ReOwnedProduct", 'Float'>
    readonly markupPercentage: FieldRef<"ReOwnedProduct", 'Float'>
    readonly agreedViaChatId: FieldRef<"ReOwnedProduct", 'String'>
    readonly createdAt: FieldRef<"ReOwnedProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReOwnedProduct findUnique
   */
  export type ReOwnedProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReOwnedProduct to fetch.
     */
    where: ReOwnedProductWhereUniqueInput
  }

  /**
   * ReOwnedProduct findUniqueOrThrow
   */
  export type ReOwnedProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReOwnedProduct to fetch.
     */
    where: ReOwnedProductWhereUniqueInput
  }

  /**
   * ReOwnedProduct findFirst
   */
  export type ReOwnedProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReOwnedProduct to fetch.
     */
    where?: ReOwnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReOwnedProducts to fetch.
     */
    orderBy?: ReOwnedProductOrderByWithRelationInput | ReOwnedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReOwnedProducts.
     */
    cursor?: ReOwnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReOwnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReOwnedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReOwnedProducts.
     */
    distinct?: ReOwnedProductScalarFieldEnum | ReOwnedProductScalarFieldEnum[]
  }

  /**
   * ReOwnedProduct findFirstOrThrow
   */
  export type ReOwnedProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReOwnedProduct to fetch.
     */
    where?: ReOwnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReOwnedProducts to fetch.
     */
    orderBy?: ReOwnedProductOrderByWithRelationInput | ReOwnedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReOwnedProducts.
     */
    cursor?: ReOwnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReOwnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReOwnedProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReOwnedProducts.
     */
    distinct?: ReOwnedProductScalarFieldEnum | ReOwnedProductScalarFieldEnum[]
  }

  /**
   * ReOwnedProduct findMany
   */
  export type ReOwnedProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * Filter, which ReOwnedProducts to fetch.
     */
    where?: ReOwnedProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReOwnedProducts to fetch.
     */
    orderBy?: ReOwnedProductOrderByWithRelationInput | ReOwnedProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReOwnedProducts.
     */
    cursor?: ReOwnedProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReOwnedProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReOwnedProducts.
     */
    skip?: number
    distinct?: ReOwnedProductScalarFieldEnum | ReOwnedProductScalarFieldEnum[]
  }

  /**
   * ReOwnedProduct create
   */
  export type ReOwnedProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * The data needed to create a ReOwnedProduct.
     */
    data: XOR<ReOwnedProductCreateInput, ReOwnedProductUncheckedCreateInput>
  }

  /**
   * ReOwnedProduct createMany
   */
  export type ReOwnedProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReOwnedProducts.
     */
    data: ReOwnedProductCreateManyInput | ReOwnedProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReOwnedProduct createManyAndReturn
   */
  export type ReOwnedProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * The data used to create many ReOwnedProducts.
     */
    data: ReOwnedProductCreateManyInput | ReOwnedProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReOwnedProduct update
   */
  export type ReOwnedProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * The data needed to update a ReOwnedProduct.
     */
    data: XOR<ReOwnedProductUpdateInput, ReOwnedProductUncheckedUpdateInput>
    /**
     * Choose, which ReOwnedProduct to update.
     */
    where: ReOwnedProductWhereUniqueInput
  }

  /**
   * ReOwnedProduct updateMany
   */
  export type ReOwnedProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReOwnedProducts.
     */
    data: XOR<ReOwnedProductUpdateManyMutationInput, ReOwnedProductUncheckedUpdateManyInput>
    /**
     * Filter which ReOwnedProducts to update
     */
    where?: ReOwnedProductWhereInput
    /**
     * Limit how many ReOwnedProducts to update.
     */
    limit?: number
  }

  /**
   * ReOwnedProduct updateManyAndReturn
   */
  export type ReOwnedProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * The data used to update ReOwnedProducts.
     */
    data: XOR<ReOwnedProductUpdateManyMutationInput, ReOwnedProductUncheckedUpdateManyInput>
    /**
     * Filter which ReOwnedProducts to update
     */
    where?: ReOwnedProductWhereInput
    /**
     * Limit how many ReOwnedProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReOwnedProduct upsert
   */
  export type ReOwnedProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * The filter to search for the ReOwnedProduct to update in case it exists.
     */
    where: ReOwnedProductWhereUniqueInput
    /**
     * In case the ReOwnedProduct found by the `where` argument doesn't exist, create a new ReOwnedProduct with this data.
     */
    create: XOR<ReOwnedProductCreateInput, ReOwnedProductUncheckedCreateInput>
    /**
     * In case the ReOwnedProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReOwnedProductUpdateInput, ReOwnedProductUncheckedUpdateInput>
  }

  /**
   * ReOwnedProduct delete
   */
  export type ReOwnedProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
    /**
     * Filter which ReOwnedProduct to delete.
     */
    where: ReOwnedProductWhereUniqueInput
  }

  /**
   * ReOwnedProduct deleteMany
   */
  export type ReOwnedProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReOwnedProducts to delete
     */
    where?: ReOwnedProductWhereInput
    /**
     * Limit how many ReOwnedProducts to delete.
     */
    limit?: number
  }

  /**
   * ReOwnedProduct without action
   */
  export type ReOwnedProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReOwnedProduct
     */
    select?: ReOwnedProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReOwnedProduct
     */
    omit?: ReOwnedProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReOwnedProductInclude<ExtArgs> | null
  }


  /**
   * Model KYC
   */

  export type AggregateKYC = {
    _count: KYCCountAggregateOutputType | null
    _min: KYCMinAggregateOutputType | null
    _max: KYCMaxAggregateOutputType | null
  }

  export type KYCMinAggregateOutputType = {
    id: string | null
    status: $Enums.KycStatus | null
    documentUrl: string | null
    submittedAt: Date | null
    verifiedAt: Date | null
    businessId: string | null
    clientId: string | null
    workerId: string | null
  }

  export type KYCMaxAggregateOutputType = {
    id: string | null
    status: $Enums.KycStatus | null
    documentUrl: string | null
    submittedAt: Date | null
    verifiedAt: Date | null
    businessId: string | null
    clientId: string | null
    workerId: string | null
  }

  export type KYCCountAggregateOutputType = {
    id: number
    status: number
    documentUrl: number
    submittedAt: number
    verifiedAt: number
    businessId: number
    clientId: number
    workerId: number
    _all: number
  }


  export type KYCMinAggregateInputType = {
    id?: true
    status?: true
    documentUrl?: true
    submittedAt?: true
    verifiedAt?: true
    businessId?: true
    clientId?: true
    workerId?: true
  }

  export type KYCMaxAggregateInputType = {
    id?: true
    status?: true
    documentUrl?: true
    submittedAt?: true
    verifiedAt?: true
    businessId?: true
    clientId?: true
    workerId?: true
  }

  export type KYCCountAggregateInputType = {
    id?: true
    status?: true
    documentUrl?: true
    submittedAt?: true
    verifiedAt?: true
    businessId?: true
    clientId?: true
    workerId?: true
    _all?: true
  }

  export type KYCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYC to aggregate.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KYCS
    **/
    _count?: true | KYCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KYCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KYCMaxAggregateInputType
  }

  export type GetKYCAggregateType<T extends KYCAggregateArgs> = {
        [P in keyof T & keyof AggregateKYC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKYC[P]>
      : GetScalarType<T[P], AggregateKYC[P]>
  }




  export type KYCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KYCWhereInput
    orderBy?: KYCOrderByWithAggregationInput | KYCOrderByWithAggregationInput[]
    by: KYCScalarFieldEnum[] | KYCScalarFieldEnum
    having?: KYCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KYCCountAggregateInputType | true
    _min?: KYCMinAggregateInputType
    _max?: KYCMaxAggregateInputType
  }

  export type KYCGroupByOutputType = {
    id: string
    status: $Enums.KycStatus
    documentUrl: string
    submittedAt: Date
    verifiedAt: Date | null
    businessId: string | null
    clientId: string | null
    workerId: string | null
    _count: KYCCountAggregateOutputType | null
    _min: KYCMinAggregateOutputType | null
    _max: KYCMaxAggregateOutputType | null
  }

  type GetKYCGroupByPayload<T extends KYCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KYCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KYCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KYCGroupByOutputType[P]>
            : GetScalarType<T[P], KYCGroupByOutputType[P]>
        }
      >
    >


  export type KYCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    documentUrl?: boolean
    submittedAt?: boolean
    verifiedAt?: boolean
    businessId?: boolean
    clientId?: boolean
    workerId?: boolean
    business?: boolean | KYC$businessArgs<ExtArgs>
    client?: boolean | KYC$clientArgs<ExtArgs>
    worker?: boolean | KYC$workerArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    documentUrl?: boolean
    submittedAt?: boolean
    verifiedAt?: boolean
    businessId?: boolean
    clientId?: boolean
    workerId?: boolean
    business?: boolean | KYC$businessArgs<ExtArgs>
    client?: boolean | KYC$clientArgs<ExtArgs>
    worker?: boolean | KYC$workerArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    documentUrl?: boolean
    submittedAt?: boolean
    verifiedAt?: boolean
    businessId?: boolean
    clientId?: boolean
    workerId?: boolean
    business?: boolean | KYC$businessArgs<ExtArgs>
    client?: boolean | KYC$clientArgs<ExtArgs>
    worker?: boolean | KYC$workerArgs<ExtArgs>
  }, ExtArgs["result"]["kYC"]>

  export type KYCSelectScalar = {
    id?: boolean
    status?: boolean
    documentUrl?: boolean
    submittedAt?: boolean
    verifiedAt?: boolean
    businessId?: boolean
    clientId?: boolean
    workerId?: boolean
  }

  export type KYCOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "documentUrl" | "submittedAt" | "verifiedAt" | "businessId" | "clientId" | "workerId", ExtArgs["result"]["kYC"]>
  export type KYCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | KYC$businessArgs<ExtArgs>
    client?: boolean | KYC$clientArgs<ExtArgs>
    worker?: boolean | KYC$workerArgs<ExtArgs>
  }
  export type KYCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | KYC$businessArgs<ExtArgs>
    client?: boolean | KYC$clientArgs<ExtArgs>
    worker?: boolean | KYC$workerArgs<ExtArgs>
  }
  export type KYCIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | KYC$businessArgs<ExtArgs>
    client?: boolean | KYC$clientArgs<ExtArgs>
    worker?: boolean | KYC$workerArgs<ExtArgs>
  }

  export type $KYCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KYC"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
      worker: Prisma.$WorkerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.KycStatus
      documentUrl: string
      submittedAt: Date
      verifiedAt: Date | null
      businessId: string | null
      clientId: string | null
      workerId: string | null
    }, ExtArgs["result"]["kYC"]>
    composites: {}
  }

  type KYCGetPayload<S extends boolean | null | undefined | KYCDefaultArgs> = $Result.GetResult<Prisma.$KYCPayload, S>

  type KYCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KYCFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KYCCountAggregateInputType | true
    }

  export interface KYCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KYC'], meta: { name: 'KYC' } }
    /**
     * Find zero or one KYC that matches the filter.
     * @param {KYCFindUniqueArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KYCFindUniqueArgs>(args: SelectSubset<T, KYCFindUniqueArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KYC that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KYCFindUniqueOrThrowArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KYCFindUniqueOrThrowArgs>(args: SelectSubset<T, KYCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindFirstArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KYCFindFirstArgs>(args?: SelectSubset<T, KYCFindFirstArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KYC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindFirstOrThrowArgs} args - Arguments to find a KYC
     * @example
     * // Get one KYC
     * const kYC = await prisma.kYC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KYCFindFirstOrThrowArgs>(args?: SelectSubset<T, KYCFindFirstOrThrowArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KYCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KYCS
     * const kYCS = await prisma.kYC.findMany()
     * 
     * // Get first 10 KYCS
     * const kYCS = await prisma.kYC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kYCWithIdOnly = await prisma.kYC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KYCFindManyArgs>(args?: SelectSubset<T, KYCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KYC.
     * @param {KYCCreateArgs} args - Arguments to create a KYC.
     * @example
     * // Create one KYC
     * const KYC = await prisma.kYC.create({
     *   data: {
     *     // ... data to create a KYC
     *   }
     * })
     * 
     */
    create<T extends KYCCreateArgs>(args: SelectSubset<T, KYCCreateArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KYCS.
     * @param {KYCCreateManyArgs} args - Arguments to create many KYCS.
     * @example
     * // Create many KYCS
     * const kYC = await prisma.kYC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KYCCreateManyArgs>(args?: SelectSubset<T, KYCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KYCS and returns the data saved in the database.
     * @param {KYCCreateManyAndReturnArgs} args - Arguments to create many KYCS.
     * @example
     * // Create many KYCS
     * const kYC = await prisma.kYC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KYCS and only return the `id`
     * const kYCWithIdOnly = await prisma.kYC.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KYCCreateManyAndReturnArgs>(args?: SelectSubset<T, KYCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KYC.
     * @param {KYCDeleteArgs} args - Arguments to delete one KYC.
     * @example
     * // Delete one KYC
     * const KYC = await prisma.kYC.delete({
     *   where: {
     *     // ... filter to delete one KYC
     *   }
     * })
     * 
     */
    delete<T extends KYCDeleteArgs>(args: SelectSubset<T, KYCDeleteArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KYC.
     * @param {KYCUpdateArgs} args - Arguments to update one KYC.
     * @example
     * // Update one KYC
     * const kYC = await prisma.kYC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KYCUpdateArgs>(args: SelectSubset<T, KYCUpdateArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KYCS.
     * @param {KYCDeleteManyArgs} args - Arguments to filter KYCS to delete.
     * @example
     * // Delete a few KYCS
     * const { count } = await prisma.kYC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KYCDeleteManyArgs>(args?: SelectSubset<T, KYCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KYCS
     * const kYC = await prisma.kYC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KYCUpdateManyArgs>(args: SelectSubset<T, KYCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KYCS and returns the data updated in the database.
     * @param {KYCUpdateManyAndReturnArgs} args - Arguments to update many KYCS.
     * @example
     * // Update many KYCS
     * const kYC = await prisma.kYC.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KYCS and only return the `id`
     * const kYCWithIdOnly = await prisma.kYC.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KYCUpdateManyAndReturnArgs>(args: SelectSubset<T, KYCUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KYC.
     * @param {KYCUpsertArgs} args - Arguments to update or create a KYC.
     * @example
     * // Update or create a KYC
     * const kYC = await prisma.kYC.upsert({
     *   create: {
     *     // ... data to create a KYC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KYC we want to update
     *   }
     * })
     */
    upsert<T extends KYCUpsertArgs>(args: SelectSubset<T, KYCUpsertArgs<ExtArgs>>): Prisma__KYCClient<$Result.GetResult<Prisma.$KYCPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KYCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCCountArgs} args - Arguments to filter KYCS to count.
     * @example
     * // Count the number of KYCS
     * const count = await prisma.kYC.count({
     *   where: {
     *     // ... the filter for the KYCS we want to count
     *   }
     * })
    **/
    count<T extends KYCCountArgs>(
      args?: Subset<T, KYCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KYCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KYCAggregateArgs>(args: Subset<T, KYCAggregateArgs>): Prisma.PrismaPromise<GetKYCAggregateType<T>>

    /**
     * Group by KYC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KYCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KYCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KYCGroupByArgs['orderBy'] }
        : { orderBy?: KYCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KYCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKYCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KYC model
   */
  readonly fields: KYCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KYC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KYCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends KYC$businessArgs<ExtArgs> = {}>(args?: Subset<T, KYC$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends KYC$clientArgs<ExtArgs> = {}>(args?: Subset<T, KYC$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    worker<T extends KYC$workerArgs<ExtArgs> = {}>(args?: Subset<T, KYC$workerArgs<ExtArgs>>): Prisma__WorkerClient<$Result.GetResult<Prisma.$WorkerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KYC model
   */
  interface KYCFieldRefs {
    readonly id: FieldRef<"KYC", 'String'>
    readonly status: FieldRef<"KYC", 'KycStatus'>
    readonly documentUrl: FieldRef<"KYC", 'String'>
    readonly submittedAt: FieldRef<"KYC", 'DateTime'>
    readonly verifiedAt: FieldRef<"KYC", 'DateTime'>
    readonly businessId: FieldRef<"KYC", 'String'>
    readonly clientId: FieldRef<"KYC", 'String'>
    readonly workerId: FieldRef<"KYC", 'String'>
  }
    

  // Custom InputTypes
  /**
   * KYC findUnique
   */
  export type KYCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC findUniqueOrThrow
   */
  export type KYCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC findFirst
   */
  export type KYCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCS.
     */
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC findFirstOrThrow
   */
  export type KYCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYC to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KYCS.
     */
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC findMany
   */
  export type KYCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter, which KYCS to fetch.
     */
    where?: KYCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KYCS to fetch.
     */
    orderBy?: KYCOrderByWithRelationInput | KYCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KYCS.
     */
    cursor?: KYCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KYCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KYCS.
     */
    skip?: number
    distinct?: KYCScalarFieldEnum | KYCScalarFieldEnum[]
  }

  /**
   * KYC create
   */
  export type KYCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The data needed to create a KYC.
     */
    data: XOR<KYCCreateInput, KYCUncheckedCreateInput>
  }

  /**
   * KYC createMany
   */
  export type KYCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KYCS.
     */
    data: KYCCreateManyInput | KYCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KYC createManyAndReturn
   */
  export type KYCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * The data used to create many KYCS.
     */
    data: KYCCreateManyInput | KYCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYC update
   */
  export type KYCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The data needed to update a KYC.
     */
    data: XOR<KYCUpdateInput, KYCUncheckedUpdateInput>
    /**
     * Choose, which KYC to update.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC updateMany
   */
  export type KYCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KYCS.
     */
    data: XOR<KYCUpdateManyMutationInput, KYCUncheckedUpdateManyInput>
    /**
     * Filter which KYCS to update
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to update.
     */
    limit?: number
  }

  /**
   * KYC updateManyAndReturn
   */
  export type KYCUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * The data used to update KYCS.
     */
    data: XOR<KYCUpdateManyMutationInput, KYCUncheckedUpdateManyInput>
    /**
     * Filter which KYCS to update
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KYC upsert
   */
  export type KYCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * The filter to search for the KYC to update in case it exists.
     */
    where: KYCWhereUniqueInput
    /**
     * In case the KYC found by the `where` argument doesn't exist, create a new KYC with this data.
     */
    create: XOR<KYCCreateInput, KYCUncheckedCreateInput>
    /**
     * In case the KYC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KYCUpdateInput, KYCUncheckedUpdateInput>
  }

  /**
   * KYC delete
   */
  export type KYCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
    /**
     * Filter which KYC to delete.
     */
    where: KYCWhereUniqueInput
  }

  /**
   * KYC deleteMany
   */
  export type KYCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KYCS to delete
     */
    where?: KYCWhereInput
    /**
     * Limit how many KYCS to delete.
     */
    limit?: number
  }

  /**
   * KYC.business
   */
  export type KYC$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * KYC.client
   */
  export type KYC$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * KYC.worker
   */
  export type KYC$workerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Worker
     */
    select?: WorkerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Worker
     */
    omit?: WorkerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkerInclude<ExtArgs> | null
    where?: WorkerWhereInput
  }

  /**
   * KYC without action
   */
  export type KYCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KYC
     */
    select?: KYCSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KYC
     */
    omit?: KYCOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KYCInclude<ExtArgs> | null
  }


  /**
   * Model AccountRecharge
   */

  export type AggregateAccountRecharge = {
    _count: AccountRechargeCountAggregateOutputType | null
    _avg: AccountRechargeAvgAggregateOutputType | null
    _sum: AccountRechargeSumAggregateOutputType | null
    _min: AccountRechargeMinAggregateOutputType | null
    _max: AccountRechargeMaxAggregateOutputType | null
  }

  export type AccountRechargeAvgAggregateOutputType = {
    amount: number | null
  }

  export type AccountRechargeSumAggregateOutputType = {
    amount: number | null
  }

  export type AccountRechargeMinAggregateOutputType = {
    id: string | null
    amount: number | null
    method: $Enums.RechargeMethod | null
    origin: $Enums.Country | null
    businessId: string | null
    clientId: string | null
    createdAt: Date | null
  }

  export type AccountRechargeMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    method: $Enums.RechargeMethod | null
    origin: $Enums.Country | null
    businessId: string | null
    clientId: string | null
    createdAt: Date | null
  }

  export type AccountRechargeCountAggregateOutputType = {
    id: number
    amount: number
    method: number
    origin: number
    businessId: number
    clientId: number
    createdAt: number
    _all: number
  }


  export type AccountRechargeAvgAggregateInputType = {
    amount?: true
  }

  export type AccountRechargeSumAggregateInputType = {
    amount?: true
  }

  export type AccountRechargeMinAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    origin?: true
    businessId?: true
    clientId?: true
    createdAt?: true
  }

  export type AccountRechargeMaxAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    origin?: true
    businessId?: true
    clientId?: true
    createdAt?: true
  }

  export type AccountRechargeCountAggregateInputType = {
    id?: true
    amount?: true
    method?: true
    origin?: true
    businessId?: true
    clientId?: true
    createdAt?: true
    _all?: true
  }

  export type AccountRechargeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountRecharge to aggregate.
     */
    where?: AccountRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountRecharges to fetch.
     */
    orderBy?: AccountRechargeOrderByWithRelationInput | AccountRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountRecharges
    **/
    _count?: true | AccountRechargeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountRechargeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountRechargeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountRechargeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountRechargeMaxAggregateInputType
  }

  export type GetAccountRechargeAggregateType<T extends AccountRechargeAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountRecharge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountRecharge[P]>
      : GetScalarType<T[P], AggregateAccountRecharge[P]>
  }




  export type AccountRechargeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountRechargeWhereInput
    orderBy?: AccountRechargeOrderByWithAggregationInput | AccountRechargeOrderByWithAggregationInput[]
    by: AccountRechargeScalarFieldEnum[] | AccountRechargeScalarFieldEnum
    having?: AccountRechargeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountRechargeCountAggregateInputType | true
    _avg?: AccountRechargeAvgAggregateInputType
    _sum?: AccountRechargeSumAggregateInputType
    _min?: AccountRechargeMinAggregateInputType
    _max?: AccountRechargeMaxAggregateInputType
  }

  export type AccountRechargeGroupByOutputType = {
    id: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    businessId: string | null
    clientId: string | null
    createdAt: Date
    _count: AccountRechargeCountAggregateOutputType | null
    _avg: AccountRechargeAvgAggregateOutputType | null
    _sum: AccountRechargeSumAggregateOutputType | null
    _min: AccountRechargeMinAggregateOutputType | null
    _max: AccountRechargeMaxAggregateOutputType | null
  }

  type GetAccountRechargeGroupByPayload<T extends AccountRechargeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountRechargeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountRechargeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountRechargeGroupByOutputType[P]>
            : GetScalarType<T[P], AccountRechargeGroupByOutputType[P]>
        }
      >
    >


  export type AccountRechargeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    origin?: boolean
    businessId?: boolean
    clientId?: boolean
    createdAt?: boolean
    business?: boolean | AccountRecharge$businessArgs<ExtArgs>
    client?: boolean | AccountRecharge$clientArgs<ExtArgs>
  }, ExtArgs["result"]["accountRecharge"]>

  export type AccountRechargeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    origin?: boolean
    businessId?: boolean
    clientId?: boolean
    createdAt?: boolean
    business?: boolean | AccountRecharge$businessArgs<ExtArgs>
    client?: boolean | AccountRecharge$clientArgs<ExtArgs>
  }, ExtArgs["result"]["accountRecharge"]>

  export type AccountRechargeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    method?: boolean
    origin?: boolean
    businessId?: boolean
    clientId?: boolean
    createdAt?: boolean
    business?: boolean | AccountRecharge$businessArgs<ExtArgs>
    client?: boolean | AccountRecharge$clientArgs<ExtArgs>
  }, ExtArgs["result"]["accountRecharge"]>

  export type AccountRechargeSelectScalar = {
    id?: boolean
    amount?: boolean
    method?: boolean
    origin?: boolean
    businessId?: boolean
    clientId?: boolean
    createdAt?: boolean
  }

  export type AccountRechargeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "method" | "origin" | "businessId" | "clientId" | "createdAt", ExtArgs["result"]["accountRecharge"]>
  export type AccountRechargeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | AccountRecharge$businessArgs<ExtArgs>
    client?: boolean | AccountRecharge$clientArgs<ExtArgs>
  }
  export type AccountRechargeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | AccountRecharge$businessArgs<ExtArgs>
    client?: boolean | AccountRecharge$clientArgs<ExtArgs>
  }
  export type AccountRechargeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | AccountRecharge$businessArgs<ExtArgs>
    client?: boolean | AccountRecharge$clientArgs<ExtArgs>
  }

  export type $AccountRechargePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountRecharge"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs> | null
      client: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      method: $Enums.RechargeMethod
      origin: $Enums.Country
      businessId: string | null
      clientId: string | null
      createdAt: Date
    }, ExtArgs["result"]["accountRecharge"]>
    composites: {}
  }

  type AccountRechargeGetPayload<S extends boolean | null | undefined | AccountRechargeDefaultArgs> = $Result.GetResult<Prisma.$AccountRechargePayload, S>

  type AccountRechargeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountRechargeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountRechargeCountAggregateInputType | true
    }

  export interface AccountRechargeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountRecharge'], meta: { name: 'AccountRecharge' } }
    /**
     * Find zero or one AccountRecharge that matches the filter.
     * @param {AccountRechargeFindUniqueArgs} args - Arguments to find a AccountRecharge
     * @example
     * // Get one AccountRecharge
     * const accountRecharge = await prisma.accountRecharge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountRechargeFindUniqueArgs>(args: SelectSubset<T, AccountRechargeFindUniqueArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountRecharge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountRechargeFindUniqueOrThrowArgs} args - Arguments to find a AccountRecharge
     * @example
     * // Get one AccountRecharge
     * const accountRecharge = await prisma.accountRecharge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountRechargeFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountRechargeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountRecharge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeFindFirstArgs} args - Arguments to find a AccountRecharge
     * @example
     * // Get one AccountRecharge
     * const accountRecharge = await prisma.accountRecharge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountRechargeFindFirstArgs>(args?: SelectSubset<T, AccountRechargeFindFirstArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountRecharge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeFindFirstOrThrowArgs} args - Arguments to find a AccountRecharge
     * @example
     * // Get one AccountRecharge
     * const accountRecharge = await prisma.accountRecharge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountRechargeFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountRechargeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountRecharges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountRecharges
     * const accountRecharges = await prisma.accountRecharge.findMany()
     * 
     * // Get first 10 AccountRecharges
     * const accountRecharges = await prisma.accountRecharge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountRechargeWithIdOnly = await prisma.accountRecharge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountRechargeFindManyArgs>(args?: SelectSubset<T, AccountRechargeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountRecharge.
     * @param {AccountRechargeCreateArgs} args - Arguments to create a AccountRecharge.
     * @example
     * // Create one AccountRecharge
     * const AccountRecharge = await prisma.accountRecharge.create({
     *   data: {
     *     // ... data to create a AccountRecharge
     *   }
     * })
     * 
     */
    create<T extends AccountRechargeCreateArgs>(args: SelectSubset<T, AccountRechargeCreateArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountRecharges.
     * @param {AccountRechargeCreateManyArgs} args - Arguments to create many AccountRecharges.
     * @example
     * // Create many AccountRecharges
     * const accountRecharge = await prisma.accountRecharge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountRechargeCreateManyArgs>(args?: SelectSubset<T, AccountRechargeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountRecharges and returns the data saved in the database.
     * @param {AccountRechargeCreateManyAndReturnArgs} args - Arguments to create many AccountRecharges.
     * @example
     * // Create many AccountRecharges
     * const accountRecharge = await prisma.accountRecharge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountRecharges and only return the `id`
     * const accountRechargeWithIdOnly = await prisma.accountRecharge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountRechargeCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountRechargeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccountRecharge.
     * @param {AccountRechargeDeleteArgs} args - Arguments to delete one AccountRecharge.
     * @example
     * // Delete one AccountRecharge
     * const AccountRecharge = await prisma.accountRecharge.delete({
     *   where: {
     *     // ... filter to delete one AccountRecharge
     *   }
     * })
     * 
     */
    delete<T extends AccountRechargeDeleteArgs>(args: SelectSubset<T, AccountRechargeDeleteArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountRecharge.
     * @param {AccountRechargeUpdateArgs} args - Arguments to update one AccountRecharge.
     * @example
     * // Update one AccountRecharge
     * const accountRecharge = await prisma.accountRecharge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountRechargeUpdateArgs>(args: SelectSubset<T, AccountRechargeUpdateArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountRecharges.
     * @param {AccountRechargeDeleteManyArgs} args - Arguments to filter AccountRecharges to delete.
     * @example
     * // Delete a few AccountRecharges
     * const { count } = await prisma.accountRecharge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountRechargeDeleteManyArgs>(args?: SelectSubset<T, AccountRechargeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountRecharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountRecharges
     * const accountRecharge = await prisma.accountRecharge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountRechargeUpdateManyArgs>(args: SelectSubset<T, AccountRechargeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountRecharges and returns the data updated in the database.
     * @param {AccountRechargeUpdateManyAndReturnArgs} args - Arguments to update many AccountRecharges.
     * @example
     * // Update many AccountRecharges
     * const accountRecharge = await prisma.accountRecharge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccountRecharges and only return the `id`
     * const accountRechargeWithIdOnly = await prisma.accountRecharge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountRechargeUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountRechargeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccountRecharge.
     * @param {AccountRechargeUpsertArgs} args - Arguments to update or create a AccountRecharge.
     * @example
     * // Update or create a AccountRecharge
     * const accountRecharge = await prisma.accountRecharge.upsert({
     *   create: {
     *     // ... data to create a AccountRecharge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountRecharge we want to update
     *   }
     * })
     */
    upsert<T extends AccountRechargeUpsertArgs>(args: SelectSubset<T, AccountRechargeUpsertArgs<ExtArgs>>): Prisma__AccountRechargeClient<$Result.GetResult<Prisma.$AccountRechargePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountRecharges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeCountArgs} args - Arguments to filter AccountRecharges to count.
     * @example
     * // Count the number of AccountRecharges
     * const count = await prisma.accountRecharge.count({
     *   where: {
     *     // ... the filter for the AccountRecharges we want to count
     *   }
     * })
    **/
    count<T extends AccountRechargeCountArgs>(
      args?: Subset<T, AccountRechargeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountRechargeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountRecharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountRechargeAggregateArgs>(args: Subset<T, AccountRechargeAggregateArgs>): Prisma.PrismaPromise<GetAccountRechargeAggregateType<T>>

    /**
     * Group by AccountRecharge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountRechargeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountRechargeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountRechargeGroupByArgs['orderBy'] }
        : { orderBy?: AccountRechargeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountRechargeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountRechargeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountRecharge model
   */
  readonly fields: AccountRechargeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountRecharge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountRechargeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends AccountRecharge$businessArgs<ExtArgs> = {}>(args?: Subset<T, AccountRecharge$businessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends AccountRecharge$clientArgs<ExtArgs> = {}>(args?: Subset<T, AccountRecharge$clientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountRecharge model
   */
  interface AccountRechargeFieldRefs {
    readonly id: FieldRef<"AccountRecharge", 'String'>
    readonly amount: FieldRef<"AccountRecharge", 'Float'>
    readonly method: FieldRef<"AccountRecharge", 'RechargeMethod'>
    readonly origin: FieldRef<"AccountRecharge", 'Country'>
    readonly businessId: FieldRef<"AccountRecharge", 'String'>
    readonly clientId: FieldRef<"AccountRecharge", 'String'>
    readonly createdAt: FieldRef<"AccountRecharge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountRecharge findUnique
   */
  export type AccountRechargeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * Filter, which AccountRecharge to fetch.
     */
    where: AccountRechargeWhereUniqueInput
  }

  /**
   * AccountRecharge findUniqueOrThrow
   */
  export type AccountRechargeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * Filter, which AccountRecharge to fetch.
     */
    where: AccountRechargeWhereUniqueInput
  }

  /**
   * AccountRecharge findFirst
   */
  export type AccountRechargeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * Filter, which AccountRecharge to fetch.
     */
    where?: AccountRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountRecharges to fetch.
     */
    orderBy?: AccountRechargeOrderByWithRelationInput | AccountRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountRecharges.
     */
    cursor?: AccountRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountRecharges.
     */
    distinct?: AccountRechargeScalarFieldEnum | AccountRechargeScalarFieldEnum[]
  }

  /**
   * AccountRecharge findFirstOrThrow
   */
  export type AccountRechargeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * Filter, which AccountRecharge to fetch.
     */
    where?: AccountRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountRecharges to fetch.
     */
    orderBy?: AccountRechargeOrderByWithRelationInput | AccountRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountRecharges.
     */
    cursor?: AccountRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountRecharges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountRecharges.
     */
    distinct?: AccountRechargeScalarFieldEnum | AccountRechargeScalarFieldEnum[]
  }

  /**
   * AccountRecharge findMany
   */
  export type AccountRechargeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * Filter, which AccountRecharges to fetch.
     */
    where?: AccountRechargeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountRecharges to fetch.
     */
    orderBy?: AccountRechargeOrderByWithRelationInput | AccountRechargeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountRecharges.
     */
    cursor?: AccountRechargeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountRecharges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountRecharges.
     */
    skip?: number
    distinct?: AccountRechargeScalarFieldEnum | AccountRechargeScalarFieldEnum[]
  }

  /**
   * AccountRecharge create
   */
  export type AccountRechargeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountRecharge.
     */
    data: XOR<AccountRechargeCreateInput, AccountRechargeUncheckedCreateInput>
  }

  /**
   * AccountRecharge createMany
   */
  export type AccountRechargeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountRecharges.
     */
    data: AccountRechargeCreateManyInput | AccountRechargeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountRecharge createManyAndReturn
   */
  export type AccountRechargeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * The data used to create many AccountRecharges.
     */
    data: AccountRechargeCreateManyInput | AccountRechargeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountRecharge update
   */
  export type AccountRechargeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountRecharge.
     */
    data: XOR<AccountRechargeUpdateInput, AccountRechargeUncheckedUpdateInput>
    /**
     * Choose, which AccountRecharge to update.
     */
    where: AccountRechargeWhereUniqueInput
  }

  /**
   * AccountRecharge updateMany
   */
  export type AccountRechargeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountRecharges.
     */
    data: XOR<AccountRechargeUpdateManyMutationInput, AccountRechargeUncheckedUpdateManyInput>
    /**
     * Filter which AccountRecharges to update
     */
    where?: AccountRechargeWhereInput
    /**
     * Limit how many AccountRecharges to update.
     */
    limit?: number
  }

  /**
   * AccountRecharge updateManyAndReturn
   */
  export type AccountRechargeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * The data used to update AccountRecharges.
     */
    data: XOR<AccountRechargeUpdateManyMutationInput, AccountRechargeUncheckedUpdateManyInput>
    /**
     * Filter which AccountRecharges to update
     */
    where?: AccountRechargeWhereInput
    /**
     * Limit how many AccountRecharges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountRecharge upsert
   */
  export type AccountRechargeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountRecharge to update in case it exists.
     */
    where: AccountRechargeWhereUniqueInput
    /**
     * In case the AccountRecharge found by the `where` argument doesn't exist, create a new AccountRecharge with this data.
     */
    create: XOR<AccountRechargeCreateInput, AccountRechargeUncheckedCreateInput>
    /**
     * In case the AccountRecharge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountRechargeUpdateInput, AccountRechargeUncheckedUpdateInput>
  }

  /**
   * AccountRecharge delete
   */
  export type AccountRechargeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
    /**
     * Filter which AccountRecharge to delete.
     */
    where: AccountRechargeWhereUniqueInput
  }

  /**
   * AccountRecharge deleteMany
   */
  export type AccountRechargeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountRecharges to delete
     */
    where?: AccountRechargeWhereInput
    /**
     * Limit how many AccountRecharges to delete.
     */
    limit?: number
  }

  /**
   * AccountRecharge.business
   */
  export type AccountRecharge$businessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * AccountRecharge.client
   */
  export type AccountRecharge$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * AccountRecharge without action
   */
  export type AccountRechargeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountRecharge
     */
    select?: AccountRechargeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountRecharge
     */
    omit?: AccountRechargeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountRechargeInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    value: number | null
  }

  export type TokenSumAggregateOutputType = {
    value: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    createdAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    name: string | null
    value: number | null
    createdAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    name: number
    value: number
    createdAt: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    value?: true
  }

  export type TokenSumAggregateInputType = {
    value?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    name?: true
    value?: true
    createdAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    name?: true
    value?: true
    createdAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    name?: true
    value?: true
    createdAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    name: string | null
    value: number
    createdAt: Date
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    name?: boolean
    value?: boolean
    createdAt?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "value" | "createdAt", ExtArgs["result"]["token"]>

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      value: number
      createdAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly name: FieldRef<"Token", 'String'>
    readonly value: FieldRef<"Token", 'Int'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data?: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
  }


  /**
   * Model PaymentTransaction
   */

  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    status: $Enums.PaymentStatus | null
    method: $Enums.PaymentMethod | null
    amount: number | null
    transactionDate: Date | null
    qrCode: string | null
    createdAt: Date | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    status: $Enums.PaymentStatus | null
    method: $Enums.PaymentMethod | null
    amount: number | null
    transactionDate: Date | null
    qrCode: string | null
    createdAt: Date | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    orderId: number
    status: number
    method: number
    amount: number
    transactionDate: number
    qrCode: number
    createdAt: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    amount?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    method?: true
    amount?: true
    transactionDate?: true
    qrCode?: true
    createdAt?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    method?: true
    amount?: true
    transactionDate?: true
    qrCode?: true
    createdAt?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    orderId?: true
    status?: true
    method?: true
    amount?: true
    transactionDate?: true
    qrCode?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithAggregationInput | PaymentTransactionOrderByWithAggregationInput[]
    by: PaymentTransactionScalarFieldEnum[] | PaymentTransactionScalarFieldEnum
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type PaymentTransactionGroupByOutputType = {
    id: string
    orderId: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    amount: number
    transactionDate: Date
    qrCode: string | null
    createdAt: Date
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    method?: boolean
    amount?: boolean
    transactionDate?: boolean
    qrCode?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    method?: boolean
    amount?: boolean
    transactionDate?: boolean
    qrCode?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    status?: boolean
    method?: boolean
    amount?: boolean
    transactionDate?: boolean
    qrCode?: boolean
    createdAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    orderId?: boolean
    status?: boolean
    method?: boolean
    amount?: boolean
    transactionDate?: boolean
    qrCode?: boolean
    createdAt?: boolean
  }

  export type PaymentTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "status" | "method" | "amount" | "transactionDate" | "qrCode" | "createdAt", ExtArgs["result"]["paymentTransaction"]>
  export type PaymentTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $PaymentTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTransaction"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      status: $Enums.PaymentStatus
      method: $Enums.PaymentMethod
      amount: number
      transactionDate: Date
      qrCode: string | null
      createdAt: Date
    }, ExtArgs["result"]["paymentTransaction"]>
    composites: {}
  }

  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionDefaultArgs> = $Result.GetResult<Prisma.$PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTransactionFindUniqueArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTransactionFindFirstArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTransactionFindManyArgs>(args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
     */
    create<T extends PaymentTransactionCreateArgs>(args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentTransactions.
     * @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTransactionCreateManyArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTransactions and returns the data saved in the database.
     * @param {PaymentTransactionCreateManyAndReturnArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
     */
    delete<T extends PaymentTransactionDeleteArgs>(args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTransactionUpdateArgs>(args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTransactionDeleteManyArgs>(args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTransactionUpdateManyArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions and returns the data updated in the database.
     * @param {PaymentTransactionUpdateManyAndReturnArgs} args - Arguments to update many PaymentTransactions.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTransactionUpsertArgs>(args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTransaction model
   */
  readonly fields: PaymentTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTransaction model
   */
  interface PaymentTransactionFieldRefs {
    readonly id: FieldRef<"PaymentTransaction", 'String'>
    readonly orderId: FieldRef<"PaymentTransaction", 'String'>
    readonly status: FieldRef<"PaymentTransaction", 'PaymentStatus'>
    readonly method: FieldRef<"PaymentTransaction", 'PaymentMethod'>
    readonly amount: FieldRef<"PaymentTransaction", 'Float'>
    readonly transactionDate: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly qrCode: FieldRef<"PaymentTransaction", 'String'>
    readonly createdAt: FieldRef<"PaymentTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTransaction findUnique
   */
  export type PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findFirst
   */
  export type PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }

  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction createManyAndReturn
   */
  export type PaymentTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
  }

  /**
   * PaymentTransaction updateManyAndReturn
   */
  export type PaymentTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }

  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
    /**
     * Limit how many PaymentTransactions to delete.
     */
    limit?: number
  }

  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentTransaction
     */
    omit?: PaymentTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Ad
   */

  export type AggregateAd = {
    _count: AdCountAggregateOutputType | null
    _avg: AdAvgAggregateOutputType | null
    _sum: AdSumAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  export type AdAvgAggregateOutputType = {
    price: number | null
    periodDays: number | null
  }

  export type AdSumAggregateOutputType = {
    price: number | null
    periodDays: number | null
  }

  export type AdMinAggregateOutputType = {
    id: string | null
    businessId: string | null
    productId: string | null
    price: number | null
    periodDays: number | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type AdMaxAggregateOutputType = {
    id: string | null
    businessId: string | null
    productId: string | null
    price: number | null
    periodDays: number | null
    createdAt: Date | null
    endedAt: Date | null
  }

  export type AdCountAggregateOutputType = {
    id: number
    businessId: number
    productId: number
    price: number
    periodDays: number
    createdAt: number
    endedAt: number
    _all: number
  }


  export type AdAvgAggregateInputType = {
    price?: true
    periodDays?: true
  }

  export type AdSumAggregateInputType = {
    price?: true
    periodDays?: true
  }

  export type AdMinAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    price?: true
    periodDays?: true
    createdAt?: true
    endedAt?: true
  }

  export type AdMaxAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    price?: true
    periodDays?: true
    createdAt?: true
    endedAt?: true
  }

  export type AdCountAggregateInputType = {
    id?: true
    businessId?: true
    productId?: true
    price?: true
    periodDays?: true
    createdAt?: true
    endedAt?: true
    _all?: true
  }

  export type AdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ad to aggregate.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ads
    **/
    _count?: true | AdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdMaxAggregateInputType
  }

  export type GetAdAggregateType<T extends AdAggregateArgs> = {
        [P in keyof T & keyof AggregateAd]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAd[P]>
      : GetScalarType<T[P], AggregateAd[P]>
  }




  export type AdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdWhereInput
    orderBy?: AdOrderByWithAggregationInput | AdOrderByWithAggregationInput[]
    by: AdScalarFieldEnum[] | AdScalarFieldEnum
    having?: AdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdCountAggregateInputType | true
    _avg?: AdAvgAggregateInputType
    _sum?: AdSumAggregateInputType
    _min?: AdMinAggregateInputType
    _max?: AdMaxAggregateInputType
  }

  export type AdGroupByOutputType = {
    id: string
    businessId: string
    productId: string
    price: number
    periodDays: number
    createdAt: Date
    endedAt: Date | null
    _count: AdCountAggregateOutputType | null
    _avg: AdAvgAggregateOutputType | null
    _sum: AdSumAggregateOutputType | null
    _min: AdMinAggregateOutputType | null
    _max: AdMaxAggregateOutputType | null
  }

  type GetAdGroupByPayload<T extends AdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdGroupByOutputType[P]>
            : GetScalarType<T[P], AdGroupByOutputType[P]>
        }
      >
    >


  export type AdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    price?: boolean
    periodDays?: boolean
    createdAt?: boolean
    endedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    price?: boolean
    periodDays?: boolean
    createdAt?: boolean
    endedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessId?: boolean
    productId?: boolean
    price?: boolean
    periodDays?: boolean
    createdAt?: boolean
    endedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ad"]>

  export type AdSelectScalar = {
    id?: boolean
    businessId?: boolean
    productId?: boolean
    price?: boolean
    periodDays?: boolean
    createdAt?: boolean
    endedAt?: boolean
  }

  export type AdOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessId" | "productId" | "price" | "periodDays" | "createdAt" | "endedAt", ExtArgs["result"]["ad"]>
  export type AdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AdIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type AdIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $AdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ad"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessId: string
      productId: string
      price: number
      periodDays: number
      createdAt: Date
      endedAt: Date | null
    }, ExtArgs["result"]["ad"]>
    composites: {}
  }

  type AdGetPayload<S extends boolean | null | undefined | AdDefaultArgs> = $Result.GetResult<Prisma.$AdPayload, S>

  type AdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdCountAggregateInputType | true
    }

  export interface AdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ad'], meta: { name: 'Ad' } }
    /**
     * Find zero or one Ad that matches the filter.
     * @param {AdFindUniqueArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdFindUniqueArgs>(args: SelectSubset<T, AdFindUniqueArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ad that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdFindUniqueOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdFindUniqueOrThrowArgs>(args: SelectSubset<T, AdFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdFindFirstArgs>(args?: SelectSubset<T, AdFindFirstArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindFirstOrThrowArgs} args - Arguments to find a Ad
     * @example
     * // Get one Ad
     * const ad = await prisma.ad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdFindFirstOrThrowArgs>(args?: SelectSubset<T, AdFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ads
     * const ads = await prisma.ad.findMany()
     * 
     * // Get first 10 Ads
     * const ads = await prisma.ad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adWithIdOnly = await prisma.ad.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdFindManyArgs>(args?: SelectSubset<T, AdFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ad.
     * @param {AdCreateArgs} args - Arguments to create a Ad.
     * @example
     * // Create one Ad
     * const Ad = await prisma.ad.create({
     *   data: {
     *     // ... data to create a Ad
     *   }
     * })
     * 
     */
    create<T extends AdCreateArgs>(args: SelectSubset<T, AdCreateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ads.
     * @param {AdCreateManyArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdCreateManyArgs>(args?: SelectSubset<T, AdCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ads and returns the data saved in the database.
     * @param {AdCreateManyAndReturnArgs} args - Arguments to create many Ads.
     * @example
     * // Create many Ads
     * const ad = await prisma.ad.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdCreateManyAndReturnArgs>(args?: SelectSubset<T, AdCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ad.
     * @param {AdDeleteArgs} args - Arguments to delete one Ad.
     * @example
     * // Delete one Ad
     * const Ad = await prisma.ad.delete({
     *   where: {
     *     // ... filter to delete one Ad
     *   }
     * })
     * 
     */
    delete<T extends AdDeleteArgs>(args: SelectSubset<T, AdDeleteArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ad.
     * @param {AdUpdateArgs} args - Arguments to update one Ad.
     * @example
     * // Update one Ad
     * const ad = await prisma.ad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdUpdateArgs>(args: SelectSubset<T, AdUpdateArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ads.
     * @param {AdDeleteManyArgs} args - Arguments to filter Ads to delete.
     * @example
     * // Delete a few Ads
     * const { count } = await prisma.ad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdDeleteManyArgs>(args?: SelectSubset<T, AdDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdUpdateManyArgs>(args: SelectSubset<T, AdUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ads and returns the data updated in the database.
     * @param {AdUpdateManyAndReturnArgs} args - Arguments to update many Ads.
     * @example
     * // Update many Ads
     * const ad = await prisma.ad.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ads and only return the `id`
     * const adWithIdOnly = await prisma.ad.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdUpdateManyAndReturnArgs>(args: SelectSubset<T, AdUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ad.
     * @param {AdUpsertArgs} args - Arguments to update or create a Ad.
     * @example
     * // Update or create a Ad
     * const ad = await prisma.ad.upsert({
     *   create: {
     *     // ... data to create a Ad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ad we want to update
     *   }
     * })
     */
    upsert<T extends AdUpsertArgs>(args: SelectSubset<T, AdUpsertArgs<ExtArgs>>): Prisma__AdClient<$Result.GetResult<Prisma.$AdPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdCountArgs} args - Arguments to filter Ads to count.
     * @example
     * // Count the number of Ads
     * const count = await prisma.ad.count({
     *   where: {
     *     // ... the filter for the Ads we want to count
     *   }
     * })
    **/
    count<T extends AdCountArgs>(
      args?: Subset<T, AdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdAggregateArgs>(args: Subset<T, AdAggregateArgs>): Prisma.PrismaPromise<GetAdAggregateType<T>>

    /**
     * Group by Ad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdGroupByArgs['orderBy'] }
        : { orderBy?: AdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ad model
   */
  readonly fields: AdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ad model
   */
  interface AdFieldRefs {
    readonly id: FieldRef<"Ad", 'String'>
    readonly businessId: FieldRef<"Ad", 'String'>
    readonly productId: FieldRef<"Ad", 'String'>
    readonly price: FieldRef<"Ad", 'Float'>
    readonly periodDays: FieldRef<"Ad", 'Int'>
    readonly createdAt: FieldRef<"Ad", 'DateTime'>
    readonly endedAt: FieldRef<"Ad", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ad findUnique
   */
  export type AdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findUniqueOrThrow
   */
  export type AdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad findFirst
   */
  export type AdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findFirstOrThrow
   */
  export type AdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ad to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ads.
     */
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad findMany
   */
  export type AdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter, which Ads to fetch.
     */
    where?: AdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ads to fetch.
     */
    orderBy?: AdOrderByWithRelationInput | AdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ads.
     */
    cursor?: AdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ads.
     */
    skip?: number
    distinct?: AdScalarFieldEnum | AdScalarFieldEnum[]
  }

  /**
   * Ad create
   */
  export type AdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to create a Ad.
     */
    data: XOR<AdCreateInput, AdUncheckedCreateInput>
  }

  /**
   * Ad createMany
   */
  export type AdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ad createManyAndReturn
   */
  export type AdCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * The data used to create many Ads.
     */
    data: AdCreateManyInput | AdCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ad update
   */
  export type AdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The data needed to update a Ad.
     */
    data: XOR<AdUpdateInput, AdUncheckedUpdateInput>
    /**
     * Choose, which Ad to update.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad updateMany
   */
  export type AdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to update.
     */
    limit?: number
  }

  /**
   * Ad updateManyAndReturn
   */
  export type AdUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * The data used to update Ads.
     */
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyInput>
    /**
     * Filter which Ads to update
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ad upsert
   */
  export type AdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * The filter to search for the Ad to update in case it exists.
     */
    where: AdWhereUniqueInput
    /**
     * In case the Ad found by the `where` argument doesn't exist, create a new Ad with this data.
     */
    create: XOR<AdCreateInput, AdUncheckedCreateInput>
    /**
     * In case the Ad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdUpdateInput, AdUncheckedUpdateInput>
  }

  /**
   * Ad delete
   */
  export type AdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
    /**
     * Filter which Ad to delete.
     */
    where: AdWhereUniqueInput
  }

  /**
   * Ad deleteMany
   */
  export type AdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ads to delete
     */
    where?: AdWhereInput
    /**
     * Limit how many Ads to delete.
     */
    limit?: number
  }

  /**
   * Ad without action
   */
  export type AdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ad
     */
    select?: AdSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ad
     */
    omit?: AdOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdInclude<ExtArgs> | null
  }


  /**
   * Model FreelanceService
   */

  export type AggregateFreelanceService = {
    _count: FreelanceServiceCountAggregateOutputType | null
    _avg: FreelanceServiceAvgAggregateOutputType | null
    _sum: FreelanceServiceSumAggregateOutputType | null
    _min: FreelanceServiceMinAggregateOutputType | null
    _max: FreelanceServiceMaxAggregateOutputType | null
  }

  export type FreelanceServiceAvgAggregateOutputType = {
    rate: number | null
  }

  export type FreelanceServiceSumAggregateOutputType = {
    rate: number | null
  }

  export type FreelanceServiceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    isHourly: boolean | null
    rate: number | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceServiceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    isHourly: boolean | null
    rate: number | null
    businessId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceServiceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    isHourly: number
    rate: number
    businessId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreelanceServiceAvgAggregateInputType = {
    rate?: true
  }

  export type FreelanceServiceSumAggregateInputType = {
    rate?: true
  }

  export type FreelanceServiceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isHourly?: true
    rate?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceServiceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isHourly?: true
    rate?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceServiceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isHourly?: true
    rate?: true
    businessId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreelanceServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceService to aggregate.
     */
    where?: FreelanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceServices to fetch.
     */
    orderBy?: FreelanceServiceOrderByWithRelationInput | FreelanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelanceServices
    **/
    _count?: true | FreelanceServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreelanceServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreelanceServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelanceServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelanceServiceMaxAggregateInputType
  }

  export type GetFreelanceServiceAggregateType<T extends FreelanceServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelanceService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelanceService[P]>
      : GetScalarType<T[P], AggregateFreelanceService[P]>
  }




  export type FreelanceServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceServiceWhereInput
    orderBy?: FreelanceServiceOrderByWithAggregationInput | FreelanceServiceOrderByWithAggregationInput[]
    by: FreelanceServiceScalarFieldEnum[] | FreelanceServiceScalarFieldEnum
    having?: FreelanceServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelanceServiceCountAggregateInputType | true
    _avg?: FreelanceServiceAvgAggregateInputType
    _sum?: FreelanceServiceSumAggregateInputType
    _min?: FreelanceServiceMinAggregateInputType
    _max?: FreelanceServiceMaxAggregateInputType
  }

  export type FreelanceServiceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    isHourly: boolean
    rate: number
    businessId: string
    createdAt: Date
    updatedAt: Date
    _count: FreelanceServiceCountAggregateOutputType | null
    _avg: FreelanceServiceAvgAggregateOutputType | null
    _sum: FreelanceServiceSumAggregateOutputType | null
    _min: FreelanceServiceMinAggregateOutputType | null
    _max: FreelanceServiceMaxAggregateOutputType | null
  }

  type GetFreelanceServiceGroupByPayload<T extends FreelanceServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelanceServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelanceServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelanceServiceGroupByOutputType[P]>
            : GetScalarType<T[P], FreelanceServiceGroupByOutputType[P]>
        }
      >
    >


  export type FreelanceServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isHourly?: boolean
    rate?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    orders?: boolean | FreelanceService$ordersArgs<ExtArgs>
    _count?: boolean | FreelanceServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceService"]>

  export type FreelanceServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isHourly?: boolean
    rate?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceService"]>

  export type FreelanceServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isHourly?: boolean
    rate?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceService"]>

  export type FreelanceServiceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    isHourly?: boolean
    rate?: boolean
    businessId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreelanceServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "isHourly" | "rate" | "businessId" | "createdAt" | "updatedAt", ExtArgs["result"]["freelanceService"]>
  export type FreelanceServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
    orders?: boolean | FreelanceService$ordersArgs<ExtArgs>
    _count?: boolean | FreelanceServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FreelanceServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }
  export type FreelanceServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    business?: boolean | BusinessDefaultArgs<ExtArgs>
  }

  export type $FreelanceServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelanceService"
    objects: {
      business: Prisma.$BusinessPayload<ExtArgs>
      orders: Prisma.$FreelanceOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      isHourly: boolean
      rate: number
      businessId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["freelanceService"]>
    composites: {}
  }

  type FreelanceServiceGetPayload<S extends boolean | null | undefined | FreelanceServiceDefaultArgs> = $Result.GetResult<Prisma.$FreelanceServicePayload, S>

  type FreelanceServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreelanceServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelanceServiceCountAggregateInputType | true
    }

  export interface FreelanceServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelanceService'], meta: { name: 'FreelanceService' } }
    /**
     * Find zero or one FreelanceService that matches the filter.
     * @param {FreelanceServiceFindUniqueArgs} args - Arguments to find a FreelanceService
     * @example
     * // Get one FreelanceService
     * const freelanceService = await prisma.freelanceService.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelanceServiceFindUniqueArgs>(args: SelectSubset<T, FreelanceServiceFindUniqueArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreelanceService that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreelanceServiceFindUniqueOrThrowArgs} args - Arguments to find a FreelanceService
     * @example
     * // Get one FreelanceService
     * const freelanceService = await prisma.freelanceService.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelanceServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelanceServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceService that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceFindFirstArgs} args - Arguments to find a FreelanceService
     * @example
     * // Get one FreelanceService
     * const freelanceService = await prisma.freelanceService.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelanceServiceFindFirstArgs>(args?: SelectSubset<T, FreelanceServiceFindFirstArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceService that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceFindFirstOrThrowArgs} args - Arguments to find a FreelanceService
     * @example
     * // Get one FreelanceService
     * const freelanceService = await prisma.freelanceService.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelanceServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelanceServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreelanceServices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelanceServices
     * const freelanceServices = await prisma.freelanceService.findMany()
     * 
     * // Get first 10 FreelanceServices
     * const freelanceServices = await prisma.freelanceService.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelanceServiceWithIdOnly = await prisma.freelanceService.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelanceServiceFindManyArgs>(args?: SelectSubset<T, FreelanceServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreelanceService.
     * @param {FreelanceServiceCreateArgs} args - Arguments to create a FreelanceService.
     * @example
     * // Create one FreelanceService
     * const FreelanceService = await prisma.freelanceService.create({
     *   data: {
     *     // ... data to create a FreelanceService
     *   }
     * })
     * 
     */
    create<T extends FreelanceServiceCreateArgs>(args: SelectSubset<T, FreelanceServiceCreateArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreelanceServices.
     * @param {FreelanceServiceCreateManyArgs} args - Arguments to create many FreelanceServices.
     * @example
     * // Create many FreelanceServices
     * const freelanceService = await prisma.freelanceService.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelanceServiceCreateManyArgs>(args?: SelectSubset<T, FreelanceServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelanceServices and returns the data saved in the database.
     * @param {FreelanceServiceCreateManyAndReturnArgs} args - Arguments to create many FreelanceServices.
     * @example
     * // Create many FreelanceServices
     * const freelanceService = await prisma.freelanceService.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelanceServices and only return the `id`
     * const freelanceServiceWithIdOnly = await prisma.freelanceService.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelanceServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelanceServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreelanceService.
     * @param {FreelanceServiceDeleteArgs} args - Arguments to delete one FreelanceService.
     * @example
     * // Delete one FreelanceService
     * const FreelanceService = await prisma.freelanceService.delete({
     *   where: {
     *     // ... filter to delete one FreelanceService
     *   }
     * })
     * 
     */
    delete<T extends FreelanceServiceDeleteArgs>(args: SelectSubset<T, FreelanceServiceDeleteArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreelanceService.
     * @param {FreelanceServiceUpdateArgs} args - Arguments to update one FreelanceService.
     * @example
     * // Update one FreelanceService
     * const freelanceService = await prisma.freelanceService.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelanceServiceUpdateArgs>(args: SelectSubset<T, FreelanceServiceUpdateArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreelanceServices.
     * @param {FreelanceServiceDeleteManyArgs} args - Arguments to filter FreelanceServices to delete.
     * @example
     * // Delete a few FreelanceServices
     * const { count } = await prisma.freelanceService.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelanceServiceDeleteManyArgs>(args?: SelectSubset<T, FreelanceServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelanceServices
     * const freelanceService = await prisma.freelanceService.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelanceServiceUpdateManyArgs>(args: SelectSubset<T, FreelanceServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceServices and returns the data updated in the database.
     * @param {FreelanceServiceUpdateManyAndReturnArgs} args - Arguments to update many FreelanceServices.
     * @example
     * // Update many FreelanceServices
     * const freelanceService = await prisma.freelanceService.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreelanceServices and only return the `id`
     * const freelanceServiceWithIdOnly = await prisma.freelanceService.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreelanceServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, FreelanceServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreelanceService.
     * @param {FreelanceServiceUpsertArgs} args - Arguments to update or create a FreelanceService.
     * @example
     * // Update or create a FreelanceService
     * const freelanceService = await prisma.freelanceService.upsert({
     *   create: {
     *     // ... data to create a FreelanceService
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelanceService we want to update
     *   }
     * })
     */
    upsert<T extends FreelanceServiceUpsertArgs>(args: SelectSubset<T, FreelanceServiceUpsertArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreelanceServices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceCountArgs} args - Arguments to filter FreelanceServices to count.
     * @example
     * // Count the number of FreelanceServices
     * const count = await prisma.freelanceService.count({
     *   where: {
     *     // ... the filter for the FreelanceServices we want to count
     *   }
     * })
    **/
    count<T extends FreelanceServiceCountArgs>(
      args?: Subset<T, FreelanceServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelanceServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelanceService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelanceServiceAggregateArgs>(args: Subset<T, FreelanceServiceAggregateArgs>): Prisma.PrismaPromise<GetFreelanceServiceAggregateType<T>>

    /**
     * Group by FreelanceService.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelanceServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelanceServiceGroupByArgs['orderBy'] }
        : { orderBy?: FreelanceServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelanceServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelanceServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelanceService model
   */
  readonly fields: FreelanceServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelanceService.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelanceServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    business<T extends BusinessDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessDefaultArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orders<T extends FreelanceService$ordersArgs<ExtArgs> = {}>(args?: Subset<T, FreelanceService$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelanceService model
   */
  interface FreelanceServiceFieldRefs {
    readonly id: FieldRef<"FreelanceService", 'String'>
    readonly title: FieldRef<"FreelanceService", 'String'>
    readonly description: FieldRef<"FreelanceService", 'String'>
    readonly isHourly: FieldRef<"FreelanceService", 'Boolean'>
    readonly rate: FieldRef<"FreelanceService", 'Float'>
    readonly businessId: FieldRef<"FreelanceService", 'String'>
    readonly createdAt: FieldRef<"FreelanceService", 'DateTime'>
    readonly updatedAt: FieldRef<"FreelanceService", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FreelanceService findUnique
   */
  export type FreelanceServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceService to fetch.
     */
    where: FreelanceServiceWhereUniqueInput
  }

  /**
   * FreelanceService findUniqueOrThrow
   */
  export type FreelanceServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceService to fetch.
     */
    where: FreelanceServiceWhereUniqueInput
  }

  /**
   * FreelanceService findFirst
   */
  export type FreelanceServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceService to fetch.
     */
    where?: FreelanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceServices to fetch.
     */
    orderBy?: FreelanceServiceOrderByWithRelationInput | FreelanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceServices.
     */
    cursor?: FreelanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceServices.
     */
    distinct?: FreelanceServiceScalarFieldEnum | FreelanceServiceScalarFieldEnum[]
  }

  /**
   * FreelanceService findFirstOrThrow
   */
  export type FreelanceServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceService to fetch.
     */
    where?: FreelanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceServices to fetch.
     */
    orderBy?: FreelanceServiceOrderByWithRelationInput | FreelanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceServices.
     */
    cursor?: FreelanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceServices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceServices.
     */
    distinct?: FreelanceServiceScalarFieldEnum | FreelanceServiceScalarFieldEnum[]
  }

  /**
   * FreelanceService findMany
   */
  export type FreelanceServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceServices to fetch.
     */
    where?: FreelanceServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceServices to fetch.
     */
    orderBy?: FreelanceServiceOrderByWithRelationInput | FreelanceServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelanceServices.
     */
    cursor?: FreelanceServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceServices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceServices.
     */
    skip?: number
    distinct?: FreelanceServiceScalarFieldEnum | FreelanceServiceScalarFieldEnum[]
  }

  /**
   * FreelanceService create
   */
  export type FreelanceServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelanceService.
     */
    data: XOR<FreelanceServiceCreateInput, FreelanceServiceUncheckedCreateInput>
  }

  /**
   * FreelanceService createMany
   */
  export type FreelanceServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelanceServices.
     */
    data: FreelanceServiceCreateManyInput | FreelanceServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelanceService createManyAndReturn
   */
  export type FreelanceServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * The data used to create many FreelanceServices.
     */
    data: FreelanceServiceCreateManyInput | FreelanceServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceService update
   */
  export type FreelanceServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelanceService.
     */
    data: XOR<FreelanceServiceUpdateInput, FreelanceServiceUncheckedUpdateInput>
    /**
     * Choose, which FreelanceService to update.
     */
    where: FreelanceServiceWhereUniqueInput
  }

  /**
   * FreelanceService updateMany
   */
  export type FreelanceServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelanceServices.
     */
    data: XOR<FreelanceServiceUpdateManyMutationInput, FreelanceServiceUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceServices to update
     */
    where?: FreelanceServiceWhereInput
    /**
     * Limit how many FreelanceServices to update.
     */
    limit?: number
  }

  /**
   * FreelanceService updateManyAndReturn
   */
  export type FreelanceServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * The data used to update FreelanceServices.
     */
    data: XOR<FreelanceServiceUpdateManyMutationInput, FreelanceServiceUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceServices to update
     */
    where?: FreelanceServiceWhereInput
    /**
     * Limit how many FreelanceServices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceService upsert
   */
  export type FreelanceServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelanceService to update in case it exists.
     */
    where: FreelanceServiceWhereUniqueInput
    /**
     * In case the FreelanceService found by the `where` argument doesn't exist, create a new FreelanceService with this data.
     */
    create: XOR<FreelanceServiceCreateInput, FreelanceServiceUncheckedCreateInput>
    /**
     * In case the FreelanceService was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelanceServiceUpdateInput, FreelanceServiceUncheckedUpdateInput>
  }

  /**
   * FreelanceService delete
   */
  export type FreelanceServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
    /**
     * Filter which FreelanceService to delete.
     */
    where: FreelanceServiceWhereUniqueInput
  }

  /**
   * FreelanceService deleteMany
   */
  export type FreelanceServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceServices to delete
     */
    where?: FreelanceServiceWhereInput
    /**
     * Limit how many FreelanceServices to delete.
     */
    limit?: number
  }

  /**
   * FreelanceService.orders
   */
  export type FreelanceService$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    where?: FreelanceOrderWhereInput
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    cursor?: FreelanceOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FreelanceOrderScalarFieldEnum | FreelanceOrderScalarFieldEnum[]
  }

  /**
   * FreelanceService without action
   */
  export type FreelanceServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceService
     */
    select?: FreelanceServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceService
     */
    omit?: FreelanceServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceServiceInclude<ExtArgs> | null
  }


  /**
   * Model FreelanceOrder
   */

  export type AggregateFreelanceOrder = {
    _count: FreelanceOrderCountAggregateOutputType | null
    _avg: FreelanceOrderAvgAggregateOutputType | null
    _sum: FreelanceOrderSumAggregateOutputType | null
    _min: FreelanceOrderMinAggregateOutputType | null
    _max: FreelanceOrderMaxAggregateOutputType | null
  }

  export type FreelanceOrderAvgAggregateOutputType = {
    quantity: number | null
    totalAmount: number | null
    escrowAmount: number | null
    commissionPercent: number | null
  }

  export type FreelanceOrderSumAggregateOutputType = {
    quantity: number | null
    totalAmount: number | null
    escrowAmount: number | null
    commissionPercent: number | null
  }

  export type FreelanceOrderMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    serviceId: string | null
    status: $Enums.FreelanceStatus | null
    quantity: number | null
    totalAmount: number | null
    escrowAmount: number | null
    commissionPercent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceOrderMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    serviceId: string | null
    status: $Enums.FreelanceStatus | null
    quantity: number | null
    totalAmount: number | null
    escrowAmount: number | null
    commissionPercent: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FreelanceOrderCountAggregateOutputType = {
    id: number
    clientId: number
    serviceId: number
    status: number
    quantity: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FreelanceOrderAvgAggregateInputType = {
    quantity?: true
    totalAmount?: true
    escrowAmount?: true
    commissionPercent?: true
  }

  export type FreelanceOrderSumAggregateInputType = {
    quantity?: true
    totalAmount?: true
    escrowAmount?: true
    commissionPercent?: true
  }

  export type FreelanceOrderMinAggregateInputType = {
    id?: true
    clientId?: true
    serviceId?: true
    status?: true
    quantity?: true
    totalAmount?: true
    escrowAmount?: true
    commissionPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceOrderMaxAggregateInputType = {
    id?: true
    clientId?: true
    serviceId?: true
    status?: true
    quantity?: true
    totalAmount?: true
    escrowAmount?: true
    commissionPercent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FreelanceOrderCountAggregateInputType = {
    id?: true
    clientId?: true
    serviceId?: true
    status?: true
    quantity?: true
    totalAmount?: true
    escrowAmount?: true
    commissionPercent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FreelanceOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceOrder to aggregate.
     */
    where?: FreelanceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceOrders to fetch.
     */
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FreelanceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FreelanceOrders
    **/
    _count?: true | FreelanceOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FreelanceOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FreelanceOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FreelanceOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FreelanceOrderMaxAggregateInputType
  }

  export type GetFreelanceOrderAggregateType<T extends FreelanceOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateFreelanceOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFreelanceOrder[P]>
      : GetScalarType<T[P], AggregateFreelanceOrder[P]>
  }




  export type FreelanceOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FreelanceOrderWhereInput
    orderBy?: FreelanceOrderOrderByWithAggregationInput | FreelanceOrderOrderByWithAggregationInput[]
    by: FreelanceOrderScalarFieldEnum[] | FreelanceOrderScalarFieldEnum
    having?: FreelanceOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FreelanceOrderCountAggregateInputType | true
    _avg?: FreelanceOrderAvgAggregateInputType
    _sum?: FreelanceOrderSumAggregateInputType
    _min?: FreelanceOrderMinAggregateInputType
    _max?: FreelanceOrderMaxAggregateInputType
  }

  export type FreelanceOrderGroupByOutputType = {
    id: string
    clientId: string
    serviceId: string
    status: $Enums.FreelanceStatus
    quantity: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt: Date
    updatedAt: Date
    _count: FreelanceOrderCountAggregateOutputType | null
    _avg: FreelanceOrderAvgAggregateOutputType | null
    _sum: FreelanceOrderSumAggregateOutputType | null
    _min: FreelanceOrderMinAggregateOutputType | null
    _max: FreelanceOrderMaxAggregateOutputType | null
  }

  type GetFreelanceOrderGroupByPayload<T extends FreelanceOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FreelanceOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FreelanceOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FreelanceOrderGroupByOutputType[P]>
            : GetScalarType<T[P], FreelanceOrderGroupByOutputType[P]>
        }
      >
    >


  export type FreelanceOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    status?: boolean
    quantity?: boolean
    totalAmount?: boolean
    escrowAmount?: boolean
    commissionPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | FreelanceServiceDefaultArgs<ExtArgs>
    businesses?: boolean | FreelanceOrder$businessesArgs<ExtArgs>
    _count?: boolean | FreelanceOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceOrder"]>

  export type FreelanceOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    status?: boolean
    quantity?: boolean
    totalAmount?: boolean
    escrowAmount?: boolean
    commissionPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | FreelanceServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceOrder"]>

  export type FreelanceOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    status?: boolean
    quantity?: boolean
    totalAmount?: boolean
    escrowAmount?: boolean
    commissionPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | FreelanceServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["freelanceOrder"]>

  export type FreelanceOrderSelectScalar = {
    id?: boolean
    clientId?: boolean
    serviceId?: boolean
    status?: boolean
    quantity?: boolean
    totalAmount?: boolean
    escrowAmount?: boolean
    commissionPercent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FreelanceOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "serviceId" | "status" | "quantity" | "totalAmount" | "escrowAmount" | "commissionPercent" | "createdAt" | "updatedAt", ExtArgs["result"]["freelanceOrder"]>
  export type FreelanceOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | FreelanceServiceDefaultArgs<ExtArgs>
    businesses?: boolean | FreelanceOrder$businessesArgs<ExtArgs>
    _count?: boolean | FreelanceOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FreelanceOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | FreelanceServiceDefaultArgs<ExtArgs>
  }
  export type FreelanceOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    service?: boolean | FreelanceServiceDefaultArgs<ExtArgs>
  }

  export type $FreelanceOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FreelanceOrder"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      service: Prisma.$FreelanceServicePayload<ExtArgs>
      businesses: Prisma.$BusinessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      serviceId: string
      status: $Enums.FreelanceStatus
      quantity: number
      totalAmount: number
      escrowAmount: number
      commissionPercent: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["freelanceOrder"]>
    composites: {}
  }

  type FreelanceOrderGetPayload<S extends boolean | null | undefined | FreelanceOrderDefaultArgs> = $Result.GetResult<Prisma.$FreelanceOrderPayload, S>

  type FreelanceOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FreelanceOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FreelanceOrderCountAggregateInputType | true
    }

  export interface FreelanceOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FreelanceOrder'], meta: { name: 'FreelanceOrder' } }
    /**
     * Find zero or one FreelanceOrder that matches the filter.
     * @param {FreelanceOrderFindUniqueArgs} args - Arguments to find a FreelanceOrder
     * @example
     * // Get one FreelanceOrder
     * const freelanceOrder = await prisma.freelanceOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FreelanceOrderFindUniqueArgs>(args: SelectSubset<T, FreelanceOrderFindUniqueArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FreelanceOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FreelanceOrderFindUniqueOrThrowArgs} args - Arguments to find a FreelanceOrder
     * @example
     * // Get one FreelanceOrder
     * const freelanceOrder = await prisma.freelanceOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FreelanceOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, FreelanceOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderFindFirstArgs} args - Arguments to find a FreelanceOrder
     * @example
     * // Get one FreelanceOrder
     * const freelanceOrder = await prisma.freelanceOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FreelanceOrderFindFirstArgs>(args?: SelectSubset<T, FreelanceOrderFindFirstArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FreelanceOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderFindFirstOrThrowArgs} args - Arguments to find a FreelanceOrder
     * @example
     * // Get one FreelanceOrder
     * const freelanceOrder = await prisma.freelanceOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FreelanceOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, FreelanceOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FreelanceOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FreelanceOrders
     * const freelanceOrders = await prisma.freelanceOrder.findMany()
     * 
     * // Get first 10 FreelanceOrders
     * const freelanceOrders = await prisma.freelanceOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const freelanceOrderWithIdOnly = await prisma.freelanceOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FreelanceOrderFindManyArgs>(args?: SelectSubset<T, FreelanceOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FreelanceOrder.
     * @param {FreelanceOrderCreateArgs} args - Arguments to create a FreelanceOrder.
     * @example
     * // Create one FreelanceOrder
     * const FreelanceOrder = await prisma.freelanceOrder.create({
     *   data: {
     *     // ... data to create a FreelanceOrder
     *   }
     * })
     * 
     */
    create<T extends FreelanceOrderCreateArgs>(args: SelectSubset<T, FreelanceOrderCreateArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FreelanceOrders.
     * @param {FreelanceOrderCreateManyArgs} args - Arguments to create many FreelanceOrders.
     * @example
     * // Create many FreelanceOrders
     * const freelanceOrder = await prisma.freelanceOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FreelanceOrderCreateManyArgs>(args?: SelectSubset<T, FreelanceOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FreelanceOrders and returns the data saved in the database.
     * @param {FreelanceOrderCreateManyAndReturnArgs} args - Arguments to create many FreelanceOrders.
     * @example
     * // Create many FreelanceOrders
     * const freelanceOrder = await prisma.freelanceOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FreelanceOrders and only return the `id`
     * const freelanceOrderWithIdOnly = await prisma.freelanceOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FreelanceOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, FreelanceOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FreelanceOrder.
     * @param {FreelanceOrderDeleteArgs} args - Arguments to delete one FreelanceOrder.
     * @example
     * // Delete one FreelanceOrder
     * const FreelanceOrder = await prisma.freelanceOrder.delete({
     *   where: {
     *     // ... filter to delete one FreelanceOrder
     *   }
     * })
     * 
     */
    delete<T extends FreelanceOrderDeleteArgs>(args: SelectSubset<T, FreelanceOrderDeleteArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FreelanceOrder.
     * @param {FreelanceOrderUpdateArgs} args - Arguments to update one FreelanceOrder.
     * @example
     * // Update one FreelanceOrder
     * const freelanceOrder = await prisma.freelanceOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FreelanceOrderUpdateArgs>(args: SelectSubset<T, FreelanceOrderUpdateArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FreelanceOrders.
     * @param {FreelanceOrderDeleteManyArgs} args - Arguments to filter FreelanceOrders to delete.
     * @example
     * // Delete a few FreelanceOrders
     * const { count } = await prisma.freelanceOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FreelanceOrderDeleteManyArgs>(args?: SelectSubset<T, FreelanceOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FreelanceOrders
     * const freelanceOrder = await prisma.freelanceOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FreelanceOrderUpdateManyArgs>(args: SelectSubset<T, FreelanceOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FreelanceOrders and returns the data updated in the database.
     * @param {FreelanceOrderUpdateManyAndReturnArgs} args - Arguments to update many FreelanceOrders.
     * @example
     * // Update many FreelanceOrders
     * const freelanceOrder = await prisma.freelanceOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FreelanceOrders and only return the `id`
     * const freelanceOrderWithIdOnly = await prisma.freelanceOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FreelanceOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, FreelanceOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FreelanceOrder.
     * @param {FreelanceOrderUpsertArgs} args - Arguments to update or create a FreelanceOrder.
     * @example
     * // Update or create a FreelanceOrder
     * const freelanceOrder = await prisma.freelanceOrder.upsert({
     *   create: {
     *     // ... data to create a FreelanceOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FreelanceOrder we want to update
     *   }
     * })
     */
    upsert<T extends FreelanceOrderUpsertArgs>(args: SelectSubset<T, FreelanceOrderUpsertArgs<ExtArgs>>): Prisma__FreelanceOrderClient<$Result.GetResult<Prisma.$FreelanceOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FreelanceOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderCountArgs} args - Arguments to filter FreelanceOrders to count.
     * @example
     * // Count the number of FreelanceOrders
     * const count = await prisma.freelanceOrder.count({
     *   where: {
     *     // ... the filter for the FreelanceOrders we want to count
     *   }
     * })
    **/
    count<T extends FreelanceOrderCountArgs>(
      args?: Subset<T, FreelanceOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FreelanceOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FreelanceOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FreelanceOrderAggregateArgs>(args: Subset<T, FreelanceOrderAggregateArgs>): Prisma.PrismaPromise<GetFreelanceOrderAggregateType<T>>

    /**
     * Group by FreelanceOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FreelanceOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FreelanceOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FreelanceOrderGroupByArgs['orderBy'] }
        : { orderBy?: FreelanceOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FreelanceOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFreelanceOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FreelanceOrder model
   */
  readonly fields: FreelanceOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FreelanceOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FreelanceOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends FreelanceServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FreelanceServiceDefaultArgs<ExtArgs>>): Prisma__FreelanceServiceClient<$Result.GetResult<Prisma.$FreelanceServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businesses<T extends FreelanceOrder$businessesArgs<ExtArgs> = {}>(args?: Subset<T, FreelanceOrder$businessesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FreelanceOrder model
   */
  interface FreelanceOrderFieldRefs {
    readonly id: FieldRef<"FreelanceOrder", 'String'>
    readonly clientId: FieldRef<"FreelanceOrder", 'String'>
    readonly serviceId: FieldRef<"FreelanceOrder", 'String'>
    readonly status: FieldRef<"FreelanceOrder", 'FreelanceStatus'>
    readonly quantity: FieldRef<"FreelanceOrder", 'Int'>
    readonly totalAmount: FieldRef<"FreelanceOrder", 'Float'>
    readonly escrowAmount: FieldRef<"FreelanceOrder", 'Float'>
    readonly commissionPercent: FieldRef<"FreelanceOrder", 'Float'>
    readonly createdAt: FieldRef<"FreelanceOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"FreelanceOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FreelanceOrder findUnique
   */
  export type FreelanceOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceOrder to fetch.
     */
    where: FreelanceOrderWhereUniqueInput
  }

  /**
   * FreelanceOrder findUniqueOrThrow
   */
  export type FreelanceOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceOrder to fetch.
     */
    where: FreelanceOrderWhereUniqueInput
  }

  /**
   * FreelanceOrder findFirst
   */
  export type FreelanceOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceOrder to fetch.
     */
    where?: FreelanceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceOrders to fetch.
     */
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceOrders.
     */
    cursor?: FreelanceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceOrders.
     */
    distinct?: FreelanceOrderScalarFieldEnum | FreelanceOrderScalarFieldEnum[]
  }

  /**
   * FreelanceOrder findFirstOrThrow
   */
  export type FreelanceOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceOrder to fetch.
     */
    where?: FreelanceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceOrders to fetch.
     */
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FreelanceOrders.
     */
    cursor?: FreelanceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FreelanceOrders.
     */
    distinct?: FreelanceOrderScalarFieldEnum | FreelanceOrderScalarFieldEnum[]
  }

  /**
   * FreelanceOrder findMany
   */
  export type FreelanceOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * Filter, which FreelanceOrders to fetch.
     */
    where?: FreelanceOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FreelanceOrders to fetch.
     */
    orderBy?: FreelanceOrderOrderByWithRelationInput | FreelanceOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FreelanceOrders.
     */
    cursor?: FreelanceOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FreelanceOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FreelanceOrders.
     */
    skip?: number
    distinct?: FreelanceOrderScalarFieldEnum | FreelanceOrderScalarFieldEnum[]
  }

  /**
   * FreelanceOrder create
   */
  export type FreelanceOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a FreelanceOrder.
     */
    data: XOR<FreelanceOrderCreateInput, FreelanceOrderUncheckedCreateInput>
  }

  /**
   * FreelanceOrder createMany
   */
  export type FreelanceOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FreelanceOrders.
     */
    data: FreelanceOrderCreateManyInput | FreelanceOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FreelanceOrder createManyAndReturn
   */
  export type FreelanceOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * The data used to create many FreelanceOrders.
     */
    data: FreelanceOrderCreateManyInput | FreelanceOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceOrder update
   */
  export type FreelanceOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a FreelanceOrder.
     */
    data: XOR<FreelanceOrderUpdateInput, FreelanceOrderUncheckedUpdateInput>
    /**
     * Choose, which FreelanceOrder to update.
     */
    where: FreelanceOrderWhereUniqueInput
  }

  /**
   * FreelanceOrder updateMany
   */
  export type FreelanceOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FreelanceOrders.
     */
    data: XOR<FreelanceOrderUpdateManyMutationInput, FreelanceOrderUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceOrders to update
     */
    where?: FreelanceOrderWhereInput
    /**
     * Limit how many FreelanceOrders to update.
     */
    limit?: number
  }

  /**
   * FreelanceOrder updateManyAndReturn
   */
  export type FreelanceOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * The data used to update FreelanceOrders.
     */
    data: XOR<FreelanceOrderUpdateManyMutationInput, FreelanceOrderUncheckedUpdateManyInput>
    /**
     * Filter which FreelanceOrders to update
     */
    where?: FreelanceOrderWhereInput
    /**
     * Limit how many FreelanceOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FreelanceOrder upsert
   */
  export type FreelanceOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the FreelanceOrder to update in case it exists.
     */
    where: FreelanceOrderWhereUniqueInput
    /**
     * In case the FreelanceOrder found by the `where` argument doesn't exist, create a new FreelanceOrder with this data.
     */
    create: XOR<FreelanceOrderCreateInput, FreelanceOrderUncheckedCreateInput>
    /**
     * In case the FreelanceOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FreelanceOrderUpdateInput, FreelanceOrderUncheckedUpdateInput>
  }

  /**
   * FreelanceOrder delete
   */
  export type FreelanceOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
    /**
     * Filter which FreelanceOrder to delete.
     */
    where: FreelanceOrderWhereUniqueInput
  }

  /**
   * FreelanceOrder deleteMany
   */
  export type FreelanceOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FreelanceOrders to delete
     */
    where?: FreelanceOrderWhereInput
    /**
     * Limit how many FreelanceOrders to delete.
     */
    limit?: number
  }

  /**
   * FreelanceOrder.businesses
   */
  export type FreelanceOrder$businessesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
    orderBy?: BusinessOrderByWithRelationInput | BusinessOrderByWithRelationInput[]
    cursor?: BusinessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessScalarFieldEnum | BusinessScalarFieldEnum[]
  }

  /**
   * FreelanceOrder without action
   */
  export type FreelanceOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FreelanceOrder
     */
    select?: FreelanceOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FreelanceOrder
     */
    omit?: FreelanceOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FreelanceOrderInclude<ExtArgs> | null
  }


  /**
   * Model Referral
   */

  export type AggregateReferral = {
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  export type ReferralMinAggregateOutputType = {
    id: string | null
    affiliateBusinessId: string | null
    affiliateClientId: string | null
    referredBusinessId: string | null
    referredClientId: string | null
    verifiedPurchase: boolean | null
    createdAt: Date | null
  }

  export type ReferralMaxAggregateOutputType = {
    id: string | null
    affiliateBusinessId: string | null
    affiliateClientId: string | null
    referredBusinessId: string | null
    referredClientId: string | null
    verifiedPurchase: boolean | null
    createdAt: Date | null
  }

  export type ReferralCountAggregateOutputType = {
    id: number
    affiliateBusinessId: number
    affiliateClientId: number
    referredBusinessId: number
    referredClientId: number
    verifiedPurchase: number
    createdAt: number
    _all: number
  }


  export type ReferralMinAggregateInputType = {
    id?: true
    affiliateBusinessId?: true
    affiliateClientId?: true
    referredBusinessId?: true
    referredClientId?: true
    verifiedPurchase?: true
    createdAt?: true
  }

  export type ReferralMaxAggregateInputType = {
    id?: true
    affiliateBusinessId?: true
    affiliateClientId?: true
    referredBusinessId?: true
    referredClientId?: true
    verifiedPurchase?: true
    createdAt?: true
  }

  export type ReferralCountAggregateInputType = {
    id?: true
    affiliateBusinessId?: true
    affiliateClientId?: true
    referredBusinessId?: true
    referredClientId?: true
    verifiedPurchase?: true
    createdAt?: true
    _all?: true
  }

  export type ReferralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referral to aggregate.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Referrals
    **/
    _count?: true | ReferralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferralMaxAggregateInputType
  }

  export type GetReferralAggregateType<T extends ReferralAggregateArgs> = {
        [P in keyof T & keyof AggregateReferral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferral[P]>
      : GetScalarType<T[P], AggregateReferral[P]>
  }




  export type ReferralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReferralWhereInput
    orderBy?: ReferralOrderByWithAggregationInput | ReferralOrderByWithAggregationInput[]
    by: ReferralScalarFieldEnum[] | ReferralScalarFieldEnum
    having?: ReferralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferralCountAggregateInputType | true
    _min?: ReferralMinAggregateInputType
    _max?: ReferralMaxAggregateInputType
  }

  export type ReferralGroupByOutputType = {
    id: string
    affiliateBusinessId: string | null
    affiliateClientId: string | null
    referredBusinessId: string | null
    referredClientId: string | null
    verifiedPurchase: boolean
    createdAt: Date
    _count: ReferralCountAggregateOutputType | null
    _min: ReferralMinAggregateOutputType | null
    _max: ReferralMaxAggregateOutputType | null
  }

  type GetReferralGroupByPayload<T extends ReferralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferralGroupByOutputType[P]>
            : GetScalarType<T[P], ReferralGroupByOutputType[P]>
        }
      >
    >


  export type ReferralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateBusinessId?: boolean
    affiliateClientId?: boolean
    referredBusinessId?: boolean
    referredClientId?: boolean
    verifiedPurchase?: boolean
    createdAt?: boolean
    affiliateBusiness?: boolean | Referral$affiliateBusinessArgs<ExtArgs>
    affiliateClient?: boolean | Referral$affiliateClientArgs<ExtArgs>
    referredBusiness?: boolean | Referral$referredBusinessArgs<ExtArgs>
    referredClient?: boolean | Referral$referredClientArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateBusinessId?: boolean
    affiliateClientId?: boolean
    referredBusinessId?: boolean
    referredClientId?: boolean
    verifiedPurchase?: boolean
    createdAt?: boolean
    affiliateBusiness?: boolean | Referral$affiliateBusinessArgs<ExtArgs>
    affiliateClient?: boolean | Referral$affiliateClientArgs<ExtArgs>
    referredBusiness?: boolean | Referral$referredBusinessArgs<ExtArgs>
    referredClient?: boolean | Referral$referredClientArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affiliateBusinessId?: boolean
    affiliateClientId?: boolean
    referredBusinessId?: boolean
    referredClientId?: boolean
    verifiedPurchase?: boolean
    createdAt?: boolean
    affiliateBusiness?: boolean | Referral$affiliateBusinessArgs<ExtArgs>
    affiliateClient?: boolean | Referral$affiliateClientArgs<ExtArgs>
    referredBusiness?: boolean | Referral$referredBusinessArgs<ExtArgs>
    referredClient?: boolean | Referral$referredClientArgs<ExtArgs>
  }, ExtArgs["result"]["referral"]>

  export type ReferralSelectScalar = {
    id?: boolean
    affiliateBusinessId?: boolean
    affiliateClientId?: boolean
    referredBusinessId?: boolean
    referredClientId?: boolean
    verifiedPurchase?: boolean
    createdAt?: boolean
  }

  export type ReferralOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "affiliateBusinessId" | "affiliateClientId" | "referredBusinessId" | "referredClientId" | "verifiedPurchase" | "createdAt", ExtArgs["result"]["referral"]>
  export type ReferralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateBusiness?: boolean | Referral$affiliateBusinessArgs<ExtArgs>
    affiliateClient?: boolean | Referral$affiliateClientArgs<ExtArgs>
    referredBusiness?: boolean | Referral$referredBusinessArgs<ExtArgs>
    referredClient?: boolean | Referral$referredClientArgs<ExtArgs>
  }
  export type ReferralIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateBusiness?: boolean | Referral$affiliateBusinessArgs<ExtArgs>
    affiliateClient?: boolean | Referral$affiliateClientArgs<ExtArgs>
    referredBusiness?: boolean | Referral$referredBusinessArgs<ExtArgs>
    referredClient?: boolean | Referral$referredClientArgs<ExtArgs>
  }
  export type ReferralIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliateBusiness?: boolean | Referral$affiliateBusinessArgs<ExtArgs>
    affiliateClient?: boolean | Referral$affiliateClientArgs<ExtArgs>
    referredBusiness?: boolean | Referral$referredBusinessArgs<ExtArgs>
    referredClient?: boolean | Referral$referredClientArgs<ExtArgs>
  }

  export type $ReferralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Referral"
    objects: {
      affiliateBusiness: Prisma.$BusinessPayload<ExtArgs> | null
      affiliateClient: Prisma.$ClientPayload<ExtArgs> | null
      referredBusiness: Prisma.$BusinessPayload<ExtArgs> | null
      referredClient: Prisma.$ClientPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      affiliateBusinessId: string | null
      affiliateClientId: string | null
      referredBusinessId: string | null
      referredClientId: string | null
      verifiedPurchase: boolean
      createdAt: Date
    }, ExtArgs["result"]["referral"]>
    composites: {}
  }

  type ReferralGetPayload<S extends boolean | null | undefined | ReferralDefaultArgs> = $Result.GetResult<Prisma.$ReferralPayload, S>

  type ReferralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReferralFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferralCountAggregateInputType | true
    }

  export interface ReferralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Referral'], meta: { name: 'Referral' } }
    /**
     * Find zero or one Referral that matches the filter.
     * @param {ReferralFindUniqueArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReferralFindUniqueArgs>(args: SelectSubset<T, ReferralFindUniqueArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Referral that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReferralFindUniqueOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReferralFindUniqueOrThrowArgs>(args: SelectSubset<T, ReferralFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReferralFindFirstArgs>(args?: SelectSubset<T, ReferralFindFirstArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Referral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindFirstOrThrowArgs} args - Arguments to find a Referral
     * @example
     * // Get one Referral
     * const referral = await prisma.referral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReferralFindFirstOrThrowArgs>(args?: SelectSubset<T, ReferralFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Referrals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Referrals
     * const referrals = await prisma.referral.findMany()
     * 
     * // Get first 10 Referrals
     * const referrals = await prisma.referral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referralWithIdOnly = await prisma.referral.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReferralFindManyArgs>(args?: SelectSubset<T, ReferralFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Referral.
     * @param {ReferralCreateArgs} args - Arguments to create a Referral.
     * @example
     * // Create one Referral
     * const Referral = await prisma.referral.create({
     *   data: {
     *     // ... data to create a Referral
     *   }
     * })
     * 
     */
    create<T extends ReferralCreateArgs>(args: SelectSubset<T, ReferralCreateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Referrals.
     * @param {ReferralCreateManyArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReferralCreateManyArgs>(args?: SelectSubset<T, ReferralCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Referrals and returns the data saved in the database.
     * @param {ReferralCreateManyAndReturnArgs} args - Arguments to create many Referrals.
     * @example
     * // Create many Referrals
     * const referral = await prisma.referral.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReferralCreateManyAndReturnArgs>(args?: SelectSubset<T, ReferralCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Referral.
     * @param {ReferralDeleteArgs} args - Arguments to delete one Referral.
     * @example
     * // Delete one Referral
     * const Referral = await prisma.referral.delete({
     *   where: {
     *     // ... filter to delete one Referral
     *   }
     * })
     * 
     */
    delete<T extends ReferralDeleteArgs>(args: SelectSubset<T, ReferralDeleteArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Referral.
     * @param {ReferralUpdateArgs} args - Arguments to update one Referral.
     * @example
     * // Update one Referral
     * const referral = await prisma.referral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReferralUpdateArgs>(args: SelectSubset<T, ReferralUpdateArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Referrals.
     * @param {ReferralDeleteManyArgs} args - Arguments to filter Referrals to delete.
     * @example
     * // Delete a few Referrals
     * const { count } = await prisma.referral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReferralDeleteManyArgs>(args?: SelectSubset<T, ReferralDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReferralUpdateManyArgs>(args: SelectSubset<T, ReferralUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Referrals and returns the data updated in the database.
     * @param {ReferralUpdateManyAndReturnArgs} args - Arguments to update many Referrals.
     * @example
     * // Update many Referrals
     * const referral = await prisma.referral.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Referrals and only return the `id`
     * const referralWithIdOnly = await prisma.referral.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReferralUpdateManyAndReturnArgs>(args: SelectSubset<T, ReferralUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Referral.
     * @param {ReferralUpsertArgs} args - Arguments to update or create a Referral.
     * @example
     * // Update or create a Referral
     * const referral = await prisma.referral.upsert({
     *   create: {
     *     // ... data to create a Referral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Referral we want to update
     *   }
     * })
     */
    upsert<T extends ReferralUpsertArgs>(args: SelectSubset<T, ReferralUpsertArgs<ExtArgs>>): Prisma__ReferralClient<$Result.GetResult<Prisma.$ReferralPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Referrals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralCountArgs} args - Arguments to filter Referrals to count.
     * @example
     * // Count the number of Referrals
     * const count = await prisma.referral.count({
     *   where: {
     *     // ... the filter for the Referrals we want to count
     *   }
     * })
    **/
    count<T extends ReferralCountArgs>(
      args?: Subset<T, ReferralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferralAggregateArgs>(args: Subset<T, ReferralAggregateArgs>): Prisma.PrismaPromise<GetReferralAggregateType<T>>

    /**
     * Group by Referral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReferralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReferralGroupByArgs['orderBy'] }
        : { orderBy?: ReferralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReferralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Referral model
   */
  readonly fields: ReferralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Referral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReferralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliateBusiness<T extends Referral$affiliateBusinessArgs<ExtArgs> = {}>(args?: Subset<T, Referral$affiliateBusinessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    affiliateClient<T extends Referral$affiliateClientArgs<ExtArgs> = {}>(args?: Subset<T, Referral$affiliateClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referredBusiness<T extends Referral$referredBusinessArgs<ExtArgs> = {}>(args?: Subset<T, Referral$referredBusinessArgs<ExtArgs>>): Prisma__BusinessClient<$Result.GetResult<Prisma.$BusinessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    referredClient<T extends Referral$referredClientArgs<ExtArgs> = {}>(args?: Subset<T, Referral$referredClientArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Referral model
   */
  interface ReferralFieldRefs {
    readonly id: FieldRef<"Referral", 'String'>
    readonly affiliateBusinessId: FieldRef<"Referral", 'String'>
    readonly affiliateClientId: FieldRef<"Referral", 'String'>
    readonly referredBusinessId: FieldRef<"Referral", 'String'>
    readonly referredClientId: FieldRef<"Referral", 'String'>
    readonly verifiedPurchase: FieldRef<"Referral", 'Boolean'>
    readonly createdAt: FieldRef<"Referral", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Referral findUnique
   */
  export type ReferralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findUniqueOrThrow
   */
  export type ReferralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral findFirst
   */
  export type ReferralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findFirstOrThrow
   */
  export type ReferralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referral to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Referrals.
     */
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral findMany
   */
  export type ReferralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter, which Referrals to fetch.
     */
    where?: ReferralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Referrals to fetch.
     */
    orderBy?: ReferralOrderByWithRelationInput | ReferralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Referrals.
     */
    cursor?: ReferralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Referrals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Referrals.
     */
    skip?: number
    distinct?: ReferralScalarFieldEnum | ReferralScalarFieldEnum[]
  }

  /**
   * Referral create
   */
  export type ReferralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to create a Referral.
     */
    data?: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
  }

  /**
   * Referral createMany
   */
  export type ReferralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Referral createManyAndReturn
   */
  export type ReferralCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to create many Referrals.
     */
    data: ReferralCreateManyInput | ReferralCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral update
   */
  export type ReferralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The data needed to update a Referral.
     */
    data: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
    /**
     * Choose, which Referral to update.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral updateMany
   */
  export type ReferralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
  }

  /**
   * Referral updateManyAndReturn
   */
  export type ReferralUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * The data used to update Referrals.
     */
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyInput>
    /**
     * Filter which Referrals to update
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Referral upsert
   */
  export type ReferralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * The filter to search for the Referral to update in case it exists.
     */
    where: ReferralWhereUniqueInput
    /**
     * In case the Referral found by the `where` argument doesn't exist, create a new Referral with this data.
     */
    create: XOR<ReferralCreateInput, ReferralUncheckedCreateInput>
    /**
     * In case the Referral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReferralUpdateInput, ReferralUncheckedUpdateInput>
  }

  /**
   * Referral delete
   */
  export type ReferralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
    /**
     * Filter which Referral to delete.
     */
    where: ReferralWhereUniqueInput
  }

  /**
   * Referral deleteMany
   */
  export type ReferralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Referrals to delete
     */
    where?: ReferralWhereInput
    /**
     * Limit how many Referrals to delete.
     */
    limit?: number
  }

  /**
   * Referral.affiliateBusiness
   */
  export type Referral$affiliateBusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Referral.affiliateClient
   */
  export type Referral$affiliateClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Referral.referredBusiness
   */
  export type Referral$referredBusinessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Business
     */
    select?: BusinessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Business
     */
    omit?: BusinessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessInclude<ExtArgs> | null
    where?: BusinessWhereInput
  }

  /**
   * Referral.referredClient
   */
  export type Referral$referredClientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    where?: ClientWhereInput
  }

  /**
   * Referral without action
   */
  export type ReferralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Referral
     */
    select?: ReferralSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Referral
     */
    omit?: ReferralOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReferralInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BusinessScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    description: 'description',
    address: 'address',
    phone: 'phone',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessScalarFieldEnum = (typeof BusinessScalarFieldEnum)[keyof typeof BusinessScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    fullName: 'fullName',
    address: 'address',
    phone: 'phone',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const WorkerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    role: 'role',
    phone: 'phone',
    businessId: 'businessId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkerScalarFieldEnum = (typeof WorkerScalarFieldEnum)[keyof typeof WorkerScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    price: 'price',
    stock: 'stock',
    category: 'category',
    businessId: 'businessId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    url: 'url',
    type: 'type',
    productId: 'productId',
    createdAt: 'createdAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    deliveryFee: 'deliveryFee',
    deliveryAddress: 'deliveryAddress',
    qrCode: 'qrCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderProductScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity'
  };

  export type OrderProductScalarFieldEnum = (typeof OrderProductScalarFieldEnum)[keyof typeof OrderProductScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    productId: 'productId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    productId: 'productId',
    businessId: 'businessId',
    workerId: 'workerId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    message: 'message',
    senderId: 'senderId',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const RepostedProductScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    productId: 'productId',
    earnPercentage: 'earnPercentage',
    createdAt: 'createdAt'
  };

  export type RepostedProductScalarFieldEnum = (typeof RepostedProductScalarFieldEnum)[keyof typeof RepostedProductScalarFieldEnum]


  export const ReOwnedProductScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    productId: 'productId',
    oldOwnerId: 'oldOwnerId',
    oldPrice: 'oldPrice',
    newPrice: 'newPrice',
    markupPercentage: 'markupPercentage',
    agreedViaChatId: 'agreedViaChatId',
    createdAt: 'createdAt'
  };

  export type ReOwnedProductScalarFieldEnum = (typeof ReOwnedProductScalarFieldEnum)[keyof typeof ReOwnedProductScalarFieldEnum]


  export const KYCScalarFieldEnum: {
    id: 'id',
    status: 'status',
    documentUrl: 'documentUrl',
    submittedAt: 'submittedAt',
    verifiedAt: 'verifiedAt',
    businessId: 'businessId',
    clientId: 'clientId',
    workerId: 'workerId'
  };

  export type KYCScalarFieldEnum = (typeof KYCScalarFieldEnum)[keyof typeof KYCScalarFieldEnum]


  export const AccountRechargeScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    method: 'method',
    origin: 'origin',
    businessId: 'businessId',
    clientId: 'clientId',
    createdAt: 'createdAt'
  };

  export type AccountRechargeScalarFieldEnum = (typeof AccountRechargeScalarFieldEnum)[keyof typeof AccountRechargeScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    name: 'name',
    value: 'value',
    createdAt: 'createdAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    status: 'status',
    method: 'method',
    amount: 'amount',
    transactionDate: 'transactionDate',
    qrCode: 'qrCode',
    createdAt: 'createdAt'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const AdScalarFieldEnum: {
    id: 'id',
    businessId: 'businessId',
    productId: 'productId',
    price: 'price',
    periodDays: 'periodDays',
    createdAt: 'createdAt',
    endedAt: 'endedAt'
  };

  export type AdScalarFieldEnum = (typeof AdScalarFieldEnum)[keyof typeof AdScalarFieldEnum]


  export const FreelanceServiceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    isHourly: 'isHourly',
    rate: 'rate',
    businessId: 'businessId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreelanceServiceScalarFieldEnum = (typeof FreelanceServiceScalarFieldEnum)[keyof typeof FreelanceServiceScalarFieldEnum]


  export const FreelanceOrderScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    serviceId: 'serviceId',
    status: 'status',
    quantity: 'quantity',
    totalAmount: 'totalAmount',
    escrowAmount: 'escrowAmount',
    commissionPercent: 'commissionPercent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FreelanceOrderScalarFieldEnum = (typeof FreelanceOrderScalarFieldEnum)[keyof typeof FreelanceOrderScalarFieldEnum]


  export const ReferralScalarFieldEnum: {
    id: 'id',
    affiliateBusinessId: 'affiliateBusinessId',
    affiliateClientId: 'affiliateClientId',
    referredBusinessId: 'referredBusinessId',
    referredClientId: 'referredClientId',
    verifiedPurchase: 'verifiedPurchase',
    createdAt: 'createdAt'
  };

  export type ReferralScalarFieldEnum = (typeof ReferralScalarFieldEnum)[keyof typeof ReferralScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'KycStatus'
   */
  export type EnumKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycStatus'>
    


  /**
   * Reference to a field of type 'KycStatus[]'
   */
  export type ListEnumKycStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KycStatus[]'>
    


  /**
   * Reference to a field of type 'RechargeMethod'
   */
  export type EnumRechargeMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RechargeMethod'>
    


  /**
   * Reference to a field of type 'RechargeMethod[]'
   */
  export type ListEnumRechargeMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RechargeMethod[]'>
    


  /**
   * Reference to a field of type 'Country'
   */
  export type EnumCountryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Country'>
    


  /**
   * Reference to a field of type 'Country[]'
   */
  export type ListEnumCountryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Country[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'FreelanceStatus'
   */
  export type EnumFreelanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FreelanceStatus'>
    


  /**
   * Reference to a field of type 'FreelanceStatus[]'
   */
  export type ListEnumFreelanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FreelanceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BusinessWhereInput = {
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    id?: StringFilter<"Business"> | string
    name?: StringFilter<"Business"> | string
    email?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    address?: StringNullableFilter<"Business"> | string | null
    phone?: StringNullableFilter<"Business"> | string | null
    isVerified?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    products?: ProductListRelationFilter
    workers?: WorkerListRelationFilter
    repostedItems?: RepostedProductListRelationFilter
    reownedItems?: ReOwnedProductListRelationFilter
    recharges?: AccountRechargeListRelationFilter
    ads?: AdListRelationFilter
    freelanceServices?: FreelanceServiceListRelationFilter
    freelanceOrders?: FreelanceOrderListRelationFilter
    referralsMade?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    chats?: ChatListRelationFilter
  }

  export type BusinessOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kyc?: KYCOrderByWithRelationInput
    products?: ProductOrderByRelationAggregateInput
    workers?: WorkerOrderByRelationAggregateInput
    repostedItems?: RepostedProductOrderByRelationAggregateInput
    reownedItems?: ReOwnedProductOrderByRelationAggregateInput
    recharges?: AccountRechargeOrderByRelationAggregateInput
    ads?: AdOrderByRelationAggregateInput
    freelanceServices?: FreelanceServiceOrderByRelationAggregateInput
    freelanceOrders?: FreelanceOrderOrderByRelationAggregateInput
    referralsMade?: ReferralOrderByRelationAggregateInput
    referralsReceived?: ReferralOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
  }

  export type BusinessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: BusinessWhereInput | BusinessWhereInput[]
    OR?: BusinessWhereInput[]
    NOT?: BusinessWhereInput | BusinessWhereInput[]
    name?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    address?: StringNullableFilter<"Business"> | string | null
    phone?: StringNullableFilter<"Business"> | string | null
    isVerified?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    products?: ProductListRelationFilter
    workers?: WorkerListRelationFilter
    repostedItems?: RepostedProductListRelationFilter
    reownedItems?: ReOwnedProductListRelationFilter
    recharges?: AccountRechargeListRelationFilter
    ads?: AdListRelationFilter
    freelanceServices?: FreelanceServiceListRelationFilter
    freelanceOrders?: FreelanceOrderListRelationFilter
    referralsMade?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
    chats?: ChatListRelationFilter
  }, "id" | "email">

  export type BusinessOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    description?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessCountOrderByAggregateInput
    _max?: BusinessMaxOrderByAggregateInput
    _min?: BusinessMinOrderByAggregateInput
  }

  export type BusinessScalarWhereWithAggregatesInput = {
    AND?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    OR?: BusinessScalarWhereWithAggregatesInput[]
    NOT?: BusinessScalarWhereWithAggregatesInput | BusinessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Business"> | string
    name?: StringWithAggregatesFilter<"Business"> | string
    email?: StringWithAggregatesFilter<"Business"> | string
    description?: StringNullableWithAggregatesFilter<"Business"> | string | null
    address?: StringNullableWithAggregatesFilter<"Business"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Business"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Business"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Business"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    username?: StringFilter<"Client"> | string
    email?: StringFilter<"Client"> | string
    fullName?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    isVerified?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
    chats?: ChatListRelationFilter
    recharges?: AccountRechargeListRelationFilter
    freelanceOrders?: FreelanceOrderListRelationFilter
    referralsMade?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    kyc?: KYCOrderByWithRelationInput
    orders?: OrderOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    recharges?: AccountRechargeOrderByRelationAggregateInput
    freelanceOrders?: FreelanceOrderOrderByRelationAggregateInput
    referralsMade?: ReferralOrderByRelationAggregateInput
    referralsReceived?: ReferralOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    fullName?: StringNullableFilter<"Client"> | string | null
    address?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    isVerified?: BoolFilter<"Client"> | boolean
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    orders?: OrderListRelationFilter
    reviews?: ReviewListRelationFilter
    chats?: ChatListRelationFilter
    recharges?: AccountRechargeListRelationFilter
    freelanceOrders?: FreelanceOrderListRelationFilter
    referralsMade?: ReferralListRelationFilter
    referralsReceived?: ReferralListRelationFilter
  }, "id" | "username" | "email">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    username?: StringWithAggregatesFilter<"Client"> | string
    email?: StringWithAggregatesFilter<"Client"> | string
    fullName?: StringNullableWithAggregatesFilter<"Client"> | string | null
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Client"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type WorkerWhereInput = {
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    id?: StringFilter<"Worker"> | string
    email?: StringFilter<"Worker"> | string
    fullName?: StringNullableFilter<"Worker"> | string | null
    role?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    businessId?: StringFilter<"Worker"> | string
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    chats?: ChatListRelationFilter
  }

  export type WorkerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    kyc?: KYCOrderByWithRelationInput
    chats?: ChatOrderByRelationAggregateInput
  }

  export type WorkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: WorkerWhereInput | WorkerWhereInput[]
    OR?: WorkerWhereInput[]
    NOT?: WorkerWhereInput | WorkerWhereInput[]
    fullName?: StringNullableFilter<"Worker"> | string | null
    role?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    businessId?: StringFilter<"Worker"> | string
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    kyc?: XOR<KYCNullableScalarRelationFilter, KYCWhereInput> | null
    chats?: ChatListRelationFilter
  }, "id" | "email">

  export type WorkerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkerCountOrderByAggregateInput
    _max?: WorkerMaxOrderByAggregateInput
    _min?: WorkerMinOrderByAggregateInput
  }

  export type WorkerScalarWhereWithAggregatesInput = {
    AND?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    OR?: WorkerScalarWhereWithAggregatesInput[]
    NOT?: WorkerScalarWhereWithAggregatesInput | WorkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Worker"> | string
    email?: StringWithAggregatesFilter<"Worker"> | string
    fullName?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    role?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Worker"> | string | null
    businessId?: StringWithAggregatesFilter<"Worker"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Worker"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    businessId?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    medias?: MediaListRelationFilter
    reviews?: ReviewListRelationFilter
    orders?: OrderProductListRelationFilter
    chats?: ChatListRelationFilter
    reposts?: RepostedProductListRelationFilter
    reowns?: ReOwnedProductListRelationFilter
    ads?: AdListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    medias?: MediaOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    orders?: OrderProductOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    reposts?: RepostedProductOrderByRelationAggregateInput
    reowns?: ReOwnedProductOrderByRelationAggregateInput
    ads?: AdOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    title?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    businessId?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    medias?: MediaListRelationFilter
    reviews?: ReviewListRelationFilter
    orders?: OrderProductListRelationFilter
    chats?: ChatListRelationFilter
    reposts?: RepostedProductListRelationFilter
    reowns?: ReOwnedProductListRelationFilter
    ads?: AdListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    title?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    stock?: IntWithAggregatesFilter<"Product"> | number
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    businessId?: StringWithAggregatesFilter<"Product"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    productId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    url?: StringFilter<"Media"> | string
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    productId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    url?: StringWithAggregatesFilter<"Media"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"Media"> | $Enums.MediaType
    productId?: StringWithAggregatesFilter<"Media"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    deliveryFee?: FloatFilter<"Order"> | number
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    qrCode?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    products?: OrderProductListRelationFilter
    payment?: XOR<PaymentTransactionNullableScalarRelationFilter, PaymentTransactionWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    deliveryFee?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    products?: OrderProductOrderByRelationAggregateInput
    payment?: PaymentTransactionOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    clientId?: StringFilter<"Order"> | string
    deliveryFee?: FloatFilter<"Order"> | number
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    qrCode?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    products?: OrderProductListRelationFilter
    payment?: XOR<PaymentTransactionNullableScalarRelationFilter, PaymentTransactionWhereInput> | null
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    deliveryFee?: SortOrder
    deliveryAddress?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    clientId?: StringWithAggregatesFilter<"Order"> | string
    deliveryFee?: FloatWithAggregatesFilter<"Order"> | number
    deliveryAddress?: StringNullableWithAggregatesFilter<"Order"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Order"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type OrderProductWhereInput = {
    AND?: OrderProductWhereInput | OrderProductWhereInput[]
    OR?: OrderProductWhereInput[]
    NOT?: OrderProductWhereInput | OrderProductWhereInput[]
    id?: StringFilter<"OrderProduct"> | string
    orderId?: StringFilter<"OrderProduct"> | string
    productId?: StringFilter<"OrderProduct"> | string
    quantity?: IntFilter<"OrderProduct"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type OrderProductOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    order?: OrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderProductWhereInput | OrderProductWhereInput[]
    OR?: OrderProductWhereInput[]
    NOT?: OrderProductWhereInput | OrderProductWhereInput[]
    orderId?: StringFilter<"OrderProduct"> | string
    productId?: StringFilter<"OrderProduct"> | string
    quantity?: IntFilter<"OrderProduct"> | number
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type OrderProductOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    _count?: OrderProductCountOrderByAggregateInput
    _avg?: OrderProductAvgOrderByAggregateInput
    _max?: OrderProductMaxOrderByAggregateInput
    _min?: OrderProductMinOrderByAggregateInput
    _sum?: OrderProductSumOrderByAggregateInput
  }

  export type OrderProductScalarWhereWithAggregatesInput = {
    AND?: OrderProductScalarWhereWithAggregatesInput | OrderProductScalarWhereWithAggregatesInput[]
    OR?: OrderProductScalarWhereWithAggregatesInput[]
    NOT?: OrderProductScalarWhereWithAggregatesInput | OrderProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderProduct"> | string
    orderId?: StringWithAggregatesFilter<"OrderProduct"> | string
    productId?: StringWithAggregatesFilter<"OrderProduct"> | string
    quantity?: IntWithAggregatesFilter<"OrderProduct"> | number
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    clientId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    clientId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    clientId?: StringWithAggregatesFilter<"Review"> | string
    productId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    clientId?: StringFilter<"Chat"> | string
    productId?: StringFilter<"Chat"> | string
    businessId?: StringNullableFilter<"Chat"> | string | null
    workerId?: StringNullableFilter<"Chat"> | string | null
    status?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    messages?: ChatMessageListRelationFilter
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    businessId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
    business?: BusinessOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    clientId?: StringFilter<"Chat"> | string
    productId?: StringFilter<"Chat"> | string
    businessId?: StringNullableFilter<"Chat"> | string | null
    workerId?: StringNullableFilter<"Chat"> | string | null
    status?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    businessId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    clientId?: StringWithAggregatesFilter<"Chat"> | string
    productId?: StringWithAggregatesFilter<"Chat"> | string
    businessId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    workerId?: StringNullableWithAggregatesFilter<"Chat"> | string | null
    status?: StringWithAggregatesFilter<"Chat"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Chat"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    chatId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    senderId?: StringNullableFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    senderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    chat?: ChatOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    chatId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    senderId?: StringNullableFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    chat?: XOR<ChatScalarRelationFilter, ChatWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    senderId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    chatId?: StringWithAggregatesFilter<"ChatMessage"> | string
    message?: StringWithAggregatesFilter<"ChatMessage"> | string
    senderId?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type RepostedProductWhereInput = {
    AND?: RepostedProductWhereInput | RepostedProductWhereInput[]
    OR?: RepostedProductWhereInput[]
    NOT?: RepostedProductWhereInput | RepostedProductWhereInput[]
    id?: StringFilter<"RepostedProduct"> | string
    businessId?: StringFilter<"RepostedProduct"> | string
    productId?: StringFilter<"RepostedProduct"> | string
    earnPercentage?: FloatFilter<"RepostedProduct"> | number
    createdAt?: DateTimeFilter<"RepostedProduct"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type RepostedProductOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    earnPercentage?: SortOrder
    createdAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type RepostedProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RepostedProductWhereInput | RepostedProductWhereInput[]
    OR?: RepostedProductWhereInput[]
    NOT?: RepostedProductWhereInput | RepostedProductWhereInput[]
    businessId?: StringFilter<"RepostedProduct"> | string
    productId?: StringFilter<"RepostedProduct"> | string
    earnPercentage?: FloatFilter<"RepostedProduct"> | number
    createdAt?: DateTimeFilter<"RepostedProduct"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type RepostedProductOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    earnPercentage?: SortOrder
    createdAt?: SortOrder
    _count?: RepostedProductCountOrderByAggregateInput
    _avg?: RepostedProductAvgOrderByAggregateInput
    _max?: RepostedProductMaxOrderByAggregateInput
    _min?: RepostedProductMinOrderByAggregateInput
    _sum?: RepostedProductSumOrderByAggregateInput
  }

  export type RepostedProductScalarWhereWithAggregatesInput = {
    AND?: RepostedProductScalarWhereWithAggregatesInput | RepostedProductScalarWhereWithAggregatesInput[]
    OR?: RepostedProductScalarWhereWithAggregatesInput[]
    NOT?: RepostedProductScalarWhereWithAggregatesInput | RepostedProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RepostedProduct"> | string
    businessId?: StringWithAggregatesFilter<"RepostedProduct"> | string
    productId?: StringWithAggregatesFilter<"RepostedProduct"> | string
    earnPercentage?: FloatWithAggregatesFilter<"RepostedProduct"> | number
    createdAt?: DateTimeWithAggregatesFilter<"RepostedProduct"> | Date | string
  }

  export type ReOwnedProductWhereInput = {
    AND?: ReOwnedProductWhereInput | ReOwnedProductWhereInput[]
    OR?: ReOwnedProductWhereInput[]
    NOT?: ReOwnedProductWhereInput | ReOwnedProductWhereInput[]
    id?: StringFilter<"ReOwnedProduct"> | string
    businessId?: StringFilter<"ReOwnedProduct"> | string
    productId?: StringFilter<"ReOwnedProduct"> | string
    oldOwnerId?: StringFilter<"ReOwnedProduct"> | string
    oldPrice?: FloatFilter<"ReOwnedProduct"> | number
    newPrice?: FloatFilter<"ReOwnedProduct"> | number
    markupPercentage?: FloatFilter<"ReOwnedProduct"> | number
    agreedViaChatId?: StringFilter<"ReOwnedProduct"> | string
    createdAt?: DateTimeFilter<"ReOwnedProduct"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ReOwnedProductOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    oldOwnerId?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
    agreedViaChatId?: SortOrder
    createdAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ReOwnedProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReOwnedProductWhereInput | ReOwnedProductWhereInput[]
    OR?: ReOwnedProductWhereInput[]
    NOT?: ReOwnedProductWhereInput | ReOwnedProductWhereInput[]
    businessId?: StringFilter<"ReOwnedProduct"> | string
    productId?: StringFilter<"ReOwnedProduct"> | string
    oldOwnerId?: StringFilter<"ReOwnedProduct"> | string
    oldPrice?: FloatFilter<"ReOwnedProduct"> | number
    newPrice?: FloatFilter<"ReOwnedProduct"> | number
    markupPercentage?: FloatFilter<"ReOwnedProduct"> | number
    agreedViaChatId?: StringFilter<"ReOwnedProduct"> | string
    createdAt?: DateTimeFilter<"ReOwnedProduct"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ReOwnedProductOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    oldOwnerId?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
    agreedViaChatId?: SortOrder
    createdAt?: SortOrder
    _count?: ReOwnedProductCountOrderByAggregateInput
    _avg?: ReOwnedProductAvgOrderByAggregateInput
    _max?: ReOwnedProductMaxOrderByAggregateInput
    _min?: ReOwnedProductMinOrderByAggregateInput
    _sum?: ReOwnedProductSumOrderByAggregateInput
  }

  export type ReOwnedProductScalarWhereWithAggregatesInput = {
    AND?: ReOwnedProductScalarWhereWithAggregatesInput | ReOwnedProductScalarWhereWithAggregatesInput[]
    OR?: ReOwnedProductScalarWhereWithAggregatesInput[]
    NOT?: ReOwnedProductScalarWhereWithAggregatesInput | ReOwnedProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReOwnedProduct"> | string
    businessId?: StringWithAggregatesFilter<"ReOwnedProduct"> | string
    productId?: StringWithAggregatesFilter<"ReOwnedProduct"> | string
    oldOwnerId?: StringWithAggregatesFilter<"ReOwnedProduct"> | string
    oldPrice?: FloatWithAggregatesFilter<"ReOwnedProduct"> | number
    newPrice?: FloatWithAggregatesFilter<"ReOwnedProduct"> | number
    markupPercentage?: FloatWithAggregatesFilter<"ReOwnedProduct"> | number
    agreedViaChatId?: StringWithAggregatesFilter<"ReOwnedProduct"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReOwnedProduct"> | Date | string
  }

  export type KYCWhereInput = {
    AND?: KYCWhereInput | KYCWhereInput[]
    OR?: KYCWhereInput[]
    NOT?: KYCWhereInput | KYCWhereInput[]
    id?: StringFilter<"KYC"> | string
    status?: EnumKycStatusFilter<"KYC"> | $Enums.KycStatus
    documentUrl?: StringFilter<"KYC"> | string
    submittedAt?: DateTimeFilter<"KYC"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    businessId?: StringNullableFilter<"KYC"> | string | null
    clientId?: StringNullableFilter<"KYC"> | string | null
    workerId?: StringNullableFilter<"KYC"> | string | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
  }

  export type KYCOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    submittedAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    worker?: WorkerOrderByWithRelationInput
  }

  export type KYCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessId?: string
    clientId?: string
    workerId?: string
    AND?: KYCWhereInput | KYCWhereInput[]
    OR?: KYCWhereInput[]
    NOT?: KYCWhereInput | KYCWhereInput[]
    status?: EnumKycStatusFilter<"KYC"> | $Enums.KycStatus
    documentUrl?: StringFilter<"KYC"> | string
    submittedAt?: DateTimeFilter<"KYC"> | Date | string
    verifiedAt?: DateTimeNullableFilter<"KYC"> | Date | string | null
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    worker?: XOR<WorkerNullableScalarRelationFilter, WorkerWhereInput> | null
  }, "id" | "businessId" | "clientId" | "workerId">

  export type KYCOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    submittedAt?: SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    businessId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    workerId?: SortOrderInput | SortOrder
    _count?: KYCCountOrderByAggregateInput
    _max?: KYCMaxOrderByAggregateInput
    _min?: KYCMinOrderByAggregateInput
  }

  export type KYCScalarWhereWithAggregatesInput = {
    AND?: KYCScalarWhereWithAggregatesInput | KYCScalarWhereWithAggregatesInput[]
    OR?: KYCScalarWhereWithAggregatesInput[]
    NOT?: KYCScalarWhereWithAggregatesInput | KYCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KYC"> | string
    status?: EnumKycStatusWithAggregatesFilter<"KYC"> | $Enums.KycStatus
    documentUrl?: StringWithAggregatesFilter<"KYC"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"KYC"> | Date | string
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"KYC"> | Date | string | null
    businessId?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"KYC"> | string | null
    workerId?: StringNullableWithAggregatesFilter<"KYC"> | string | null
  }

  export type AccountRechargeWhereInput = {
    AND?: AccountRechargeWhereInput | AccountRechargeWhereInput[]
    OR?: AccountRechargeWhereInput[]
    NOT?: AccountRechargeWhereInput | AccountRechargeWhereInput[]
    id?: StringFilter<"AccountRecharge"> | string
    amount?: FloatFilter<"AccountRecharge"> | number
    method?: EnumRechargeMethodFilter<"AccountRecharge"> | $Enums.RechargeMethod
    origin?: EnumCountryFilter<"AccountRecharge"> | $Enums.Country
    businessId?: StringNullableFilter<"AccountRecharge"> | string | null
    clientId?: StringNullableFilter<"AccountRecharge"> | string | null
    createdAt?: DateTimeFilter<"AccountRecharge"> | Date | string
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type AccountRechargeOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    origin?: SortOrder
    businessId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
  }

  export type AccountRechargeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountRechargeWhereInput | AccountRechargeWhereInput[]
    OR?: AccountRechargeWhereInput[]
    NOT?: AccountRechargeWhereInput | AccountRechargeWhereInput[]
    amount?: FloatFilter<"AccountRecharge"> | number
    method?: EnumRechargeMethodFilter<"AccountRecharge"> | $Enums.RechargeMethod
    origin?: EnumCountryFilter<"AccountRecharge"> | $Enums.Country
    businessId?: StringNullableFilter<"AccountRecharge"> | string | null
    clientId?: StringNullableFilter<"AccountRecharge"> | string | null
    createdAt?: DateTimeFilter<"AccountRecharge"> | Date | string
    business?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    client?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type AccountRechargeOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    origin?: SortOrder
    businessId?: SortOrderInput | SortOrder
    clientId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AccountRechargeCountOrderByAggregateInput
    _avg?: AccountRechargeAvgOrderByAggregateInput
    _max?: AccountRechargeMaxOrderByAggregateInput
    _min?: AccountRechargeMinOrderByAggregateInput
    _sum?: AccountRechargeSumOrderByAggregateInput
  }

  export type AccountRechargeScalarWhereWithAggregatesInput = {
    AND?: AccountRechargeScalarWhereWithAggregatesInput | AccountRechargeScalarWhereWithAggregatesInput[]
    OR?: AccountRechargeScalarWhereWithAggregatesInput[]
    NOT?: AccountRechargeScalarWhereWithAggregatesInput | AccountRechargeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountRecharge"> | string
    amount?: FloatWithAggregatesFilter<"AccountRecharge"> | number
    method?: EnumRechargeMethodWithAggregatesFilter<"AccountRecharge"> | $Enums.RechargeMethod
    origin?: EnumCountryWithAggregatesFilter<"AccountRecharge"> | $Enums.Country
    businessId?: StringNullableWithAggregatesFilter<"AccountRecharge"> | string | null
    clientId?: StringNullableWithAggregatesFilter<"AccountRecharge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccountRecharge"> | Date | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    name?: StringNullableFilter<"Token"> | string | null
    value?: IntFilter<"Token"> | number
    createdAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    name?: StringNullableFilter<"Token"> | string | null
    value?: IntFilter<"Token"> | number
    createdAt?: DateTimeFilter<"Token"> | Date | string
  }, "id">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    name?: StringNullableWithAggregatesFilter<"Token"> | string | null
    value?: IntWithAggregatesFilter<"Token"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type PaymentTransactionWhereInput = {
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    id?: StringFilter<"PaymentTransaction"> | string
    orderId?: StringFilter<"PaymentTransaction"> | string
    status?: EnumPaymentStatusFilter<"PaymentTransaction"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"PaymentTransaction"> | $Enums.PaymentMethod
    amount?: FloatFilter<"PaymentTransaction"> | number
    transactionDate?: DateTimeFilter<"PaymentTransaction"> | Date | string
    qrCode?: StringNullableFilter<"PaymentTransaction"> | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    transactionDate?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    order?: OrderOrderByWithRelationInput
  }

  export type PaymentTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    status?: EnumPaymentStatusFilter<"PaymentTransaction"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"PaymentTransaction"> | $Enums.PaymentMethod
    amount?: FloatFilter<"PaymentTransaction"> | number
    transactionDate?: DateTimeFilter<"PaymentTransaction"> | Date | string
    qrCode?: StringNullableFilter<"PaymentTransaction"> | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id" | "orderId">

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    transactionDate?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    OR?: PaymentTransactionScalarWhereWithAggregatesInput[]
    NOT?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    orderId?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"PaymentTransaction"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodWithAggregatesFilter<"PaymentTransaction"> | $Enums.PaymentMethod
    amount?: FloatWithAggregatesFilter<"PaymentTransaction"> | number
    transactionDate?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    qrCode?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
  }

  export type AdWhereInput = {
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    id?: StringFilter<"Ad"> | string
    businessId?: StringFilter<"Ad"> | string
    productId?: StringFilter<"Ad"> | string
    price?: FloatFilter<"Ad"> | number
    periodDays?: IntFilter<"Ad"> | number
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    endedAt?: DateTimeNullableFilter<"Ad"> | Date | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type AdOrderByWithRelationInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    periodDays?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    business?: BusinessOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type AdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdWhereInput | AdWhereInput[]
    OR?: AdWhereInput[]
    NOT?: AdWhereInput | AdWhereInput[]
    businessId?: StringFilter<"Ad"> | string
    productId?: StringFilter<"Ad"> | string
    price?: FloatFilter<"Ad"> | number
    periodDays?: IntFilter<"Ad"> | number
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    endedAt?: DateTimeNullableFilter<"Ad"> | Date | string | null
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type AdOrderByWithAggregationInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    periodDays?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: AdCountOrderByAggregateInput
    _avg?: AdAvgOrderByAggregateInput
    _max?: AdMaxOrderByAggregateInput
    _min?: AdMinOrderByAggregateInput
    _sum?: AdSumOrderByAggregateInput
  }

  export type AdScalarWhereWithAggregatesInput = {
    AND?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    OR?: AdScalarWhereWithAggregatesInput[]
    NOT?: AdScalarWhereWithAggregatesInput | AdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ad"> | string
    businessId?: StringWithAggregatesFilter<"Ad"> | string
    productId?: StringWithAggregatesFilter<"Ad"> | string
    price?: FloatWithAggregatesFilter<"Ad"> | number
    periodDays?: IntWithAggregatesFilter<"Ad"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Ad"> | Date | string
    endedAt?: DateTimeNullableWithAggregatesFilter<"Ad"> | Date | string | null
  }

  export type FreelanceServiceWhereInput = {
    AND?: FreelanceServiceWhereInput | FreelanceServiceWhereInput[]
    OR?: FreelanceServiceWhereInput[]
    NOT?: FreelanceServiceWhereInput | FreelanceServiceWhereInput[]
    id?: StringFilter<"FreelanceService"> | string
    title?: StringFilter<"FreelanceService"> | string
    description?: StringNullableFilter<"FreelanceService"> | string | null
    isHourly?: BoolFilter<"FreelanceService"> | boolean
    rate?: FloatFilter<"FreelanceService"> | number
    businessId?: StringFilter<"FreelanceService"> | string
    createdAt?: DateTimeFilter<"FreelanceService"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceService"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    orders?: FreelanceOrderListRelationFilter
  }

  export type FreelanceServiceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isHourly?: SortOrder
    rate?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    business?: BusinessOrderByWithRelationInput
    orders?: FreelanceOrderOrderByRelationAggregateInput
  }

  export type FreelanceServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FreelanceServiceWhereInput | FreelanceServiceWhereInput[]
    OR?: FreelanceServiceWhereInput[]
    NOT?: FreelanceServiceWhereInput | FreelanceServiceWhereInput[]
    title?: StringFilter<"FreelanceService"> | string
    description?: StringNullableFilter<"FreelanceService"> | string | null
    isHourly?: BoolFilter<"FreelanceService"> | boolean
    rate?: FloatFilter<"FreelanceService"> | number
    businessId?: StringFilter<"FreelanceService"> | string
    createdAt?: DateTimeFilter<"FreelanceService"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceService"> | Date | string
    business?: XOR<BusinessScalarRelationFilter, BusinessWhereInput>
    orders?: FreelanceOrderListRelationFilter
  }, "id">

  export type FreelanceServiceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isHourly?: SortOrder
    rate?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreelanceServiceCountOrderByAggregateInput
    _avg?: FreelanceServiceAvgOrderByAggregateInput
    _max?: FreelanceServiceMaxOrderByAggregateInput
    _min?: FreelanceServiceMinOrderByAggregateInput
    _sum?: FreelanceServiceSumOrderByAggregateInput
  }

  export type FreelanceServiceScalarWhereWithAggregatesInput = {
    AND?: FreelanceServiceScalarWhereWithAggregatesInput | FreelanceServiceScalarWhereWithAggregatesInput[]
    OR?: FreelanceServiceScalarWhereWithAggregatesInput[]
    NOT?: FreelanceServiceScalarWhereWithAggregatesInput | FreelanceServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FreelanceService"> | string
    title?: StringWithAggregatesFilter<"FreelanceService"> | string
    description?: StringNullableWithAggregatesFilter<"FreelanceService"> | string | null
    isHourly?: BoolWithAggregatesFilter<"FreelanceService"> | boolean
    rate?: FloatWithAggregatesFilter<"FreelanceService"> | number
    businessId?: StringWithAggregatesFilter<"FreelanceService"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FreelanceService"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreelanceService"> | Date | string
  }

  export type FreelanceOrderWhereInput = {
    AND?: FreelanceOrderWhereInput | FreelanceOrderWhereInput[]
    OR?: FreelanceOrderWhereInput[]
    NOT?: FreelanceOrderWhereInput | FreelanceOrderWhereInput[]
    id?: StringFilter<"FreelanceOrder"> | string
    clientId?: StringFilter<"FreelanceOrder"> | string
    serviceId?: StringFilter<"FreelanceOrder"> | string
    status?: EnumFreelanceStatusFilter<"FreelanceOrder"> | $Enums.FreelanceStatus
    quantity?: IntFilter<"FreelanceOrder"> | number
    totalAmount?: FloatFilter<"FreelanceOrder"> | number
    escrowAmount?: FloatFilter<"FreelanceOrder"> | number
    commissionPercent?: FloatFilter<"FreelanceOrder"> | number
    createdAt?: DateTimeFilter<"FreelanceOrder"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceOrder"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    service?: XOR<FreelanceServiceScalarRelationFilter, FreelanceServiceWhereInput>
    businesses?: BusinessListRelationFilter
  }

  export type FreelanceOrderOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientOrderByWithRelationInput
    service?: FreelanceServiceOrderByWithRelationInput
    businesses?: BusinessOrderByRelationAggregateInput
  }

  export type FreelanceOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FreelanceOrderWhereInput | FreelanceOrderWhereInput[]
    OR?: FreelanceOrderWhereInput[]
    NOT?: FreelanceOrderWhereInput | FreelanceOrderWhereInput[]
    clientId?: StringFilter<"FreelanceOrder"> | string
    serviceId?: StringFilter<"FreelanceOrder"> | string
    status?: EnumFreelanceStatusFilter<"FreelanceOrder"> | $Enums.FreelanceStatus
    quantity?: IntFilter<"FreelanceOrder"> | number
    totalAmount?: FloatFilter<"FreelanceOrder"> | number
    escrowAmount?: FloatFilter<"FreelanceOrder"> | number
    commissionPercent?: FloatFilter<"FreelanceOrder"> | number
    createdAt?: DateTimeFilter<"FreelanceOrder"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceOrder"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    service?: XOR<FreelanceServiceScalarRelationFilter, FreelanceServiceWhereInput>
    businesses?: BusinessListRelationFilter
  }, "id">

  export type FreelanceOrderOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FreelanceOrderCountOrderByAggregateInput
    _avg?: FreelanceOrderAvgOrderByAggregateInput
    _max?: FreelanceOrderMaxOrderByAggregateInput
    _min?: FreelanceOrderMinOrderByAggregateInput
    _sum?: FreelanceOrderSumOrderByAggregateInput
  }

  export type FreelanceOrderScalarWhereWithAggregatesInput = {
    AND?: FreelanceOrderScalarWhereWithAggregatesInput | FreelanceOrderScalarWhereWithAggregatesInput[]
    OR?: FreelanceOrderScalarWhereWithAggregatesInput[]
    NOT?: FreelanceOrderScalarWhereWithAggregatesInput | FreelanceOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FreelanceOrder"> | string
    clientId?: StringWithAggregatesFilter<"FreelanceOrder"> | string
    serviceId?: StringWithAggregatesFilter<"FreelanceOrder"> | string
    status?: EnumFreelanceStatusWithAggregatesFilter<"FreelanceOrder"> | $Enums.FreelanceStatus
    quantity?: IntWithAggregatesFilter<"FreelanceOrder"> | number
    totalAmount?: FloatWithAggregatesFilter<"FreelanceOrder"> | number
    escrowAmount?: FloatWithAggregatesFilter<"FreelanceOrder"> | number
    commissionPercent?: FloatWithAggregatesFilter<"FreelanceOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FreelanceOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FreelanceOrder"> | Date | string
  }

  export type ReferralWhereInput = {
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    id?: StringFilter<"Referral"> | string
    affiliateBusinessId?: StringNullableFilter<"Referral"> | string | null
    affiliateClientId?: StringNullableFilter<"Referral"> | string | null
    referredBusinessId?: StringNullableFilter<"Referral"> | string | null
    referredClientId?: StringNullableFilter<"Referral"> | string | null
    verifiedPurchase?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    affiliateBusiness?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    affiliateClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    referredBusiness?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    referredClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }

  export type ReferralOrderByWithRelationInput = {
    id?: SortOrder
    affiliateBusinessId?: SortOrderInput | SortOrder
    affiliateClientId?: SortOrderInput | SortOrder
    referredBusinessId?: SortOrderInput | SortOrder
    referredClientId?: SortOrderInput | SortOrder
    verifiedPurchase?: SortOrder
    createdAt?: SortOrder
    affiliateBusiness?: BusinessOrderByWithRelationInput
    affiliateClient?: ClientOrderByWithRelationInput
    referredBusiness?: BusinessOrderByWithRelationInput
    referredClient?: ClientOrderByWithRelationInput
  }

  export type ReferralWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReferralWhereInput | ReferralWhereInput[]
    OR?: ReferralWhereInput[]
    NOT?: ReferralWhereInput | ReferralWhereInput[]
    affiliateBusinessId?: StringNullableFilter<"Referral"> | string | null
    affiliateClientId?: StringNullableFilter<"Referral"> | string | null
    referredBusinessId?: StringNullableFilter<"Referral"> | string | null
    referredClientId?: StringNullableFilter<"Referral"> | string | null
    verifiedPurchase?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
    affiliateBusiness?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    affiliateClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
    referredBusiness?: XOR<BusinessNullableScalarRelationFilter, BusinessWhereInput> | null
    referredClient?: XOR<ClientNullableScalarRelationFilter, ClientWhereInput> | null
  }, "id">

  export type ReferralOrderByWithAggregationInput = {
    id?: SortOrder
    affiliateBusinessId?: SortOrderInput | SortOrder
    affiliateClientId?: SortOrderInput | SortOrder
    referredBusinessId?: SortOrderInput | SortOrder
    referredClientId?: SortOrderInput | SortOrder
    verifiedPurchase?: SortOrder
    createdAt?: SortOrder
    _count?: ReferralCountOrderByAggregateInput
    _max?: ReferralMaxOrderByAggregateInput
    _min?: ReferralMinOrderByAggregateInput
  }

  export type ReferralScalarWhereWithAggregatesInput = {
    AND?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    OR?: ReferralScalarWhereWithAggregatesInput[]
    NOT?: ReferralScalarWhereWithAggregatesInput | ReferralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Referral"> | string
    affiliateBusinessId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    affiliateClientId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referredBusinessId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    referredClientId?: StringNullableWithAggregatesFilter<"Referral"> | string | null
    verifiedPurchase?: BoolWithAggregatesFilter<"Referral"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Referral"> | Date | string
  }

  export type BusinessCreateInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessCreateManyInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerCreateInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutWorkersInput
    kyc?: KYCCreateNestedOneWithoutWorkerInput
    chats?: ChatCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutWorkerInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutWorkersNestedInput
    kyc?: KYCUpdateOneWithoutWorkerNestedInput
    chats?: ChatUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutWorkerNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerCreateManyInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateInput = {
    id?: string
    url: string
    type: $Enums.MediaType
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutMediasInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    url: string
    type: $Enums.MediaType
    productId: string
    createdAt?: Date | string
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutMediasNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyInput = {
    id?: string
    url: string
    type: $Enums.MediaType
    productId: string
    createdAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    productId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutOrdersInput
    products?: OrderProductCreateNestedManyWithoutOrderInput
    payment?: PaymentTransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    clientId: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentTransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    products?: OrderProductUpdateManyWithoutOrderNestedInput
    payment?: PaymentTransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentTransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    clientId: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductCreateInput = {
    id?: string
    quantity?: number
    order: OrderCreateNestedOneWithoutProductsInput
    product: ProductCreateNestedOneWithoutOrdersInput
  }

  export type OrderProductUncheckedCreateInput = {
    id?: string
    orderId: string
    productId: string
    quantity?: number
  }

  export type OrderProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutProductsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderProductCreateManyInput = {
    id?: string
    orderId: string
    productId: string
    quantity?: number
  }

  export type OrderProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ReviewCreateInput = {
    id?: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    clientId: string
    productId: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    clientId: string
    productId: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutChatsInput
    product: ProductCreateNestedOneWithoutChatsInput
    business?: BusinessCreateNestedOneWithoutChatsInput
    worker?: WorkerCreateNestedOneWithoutChatsInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    clientId: string
    productId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutChatsNestedInput
    product?: ProductUpdateOneRequiredWithoutChatsNestedInput
    business?: BusinessUpdateOneWithoutChatsNestedInput
    worker?: WorkerUpdateOneWithoutChatsNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatCreateManyInput = {
    id?: string
    clientId: string
    productId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    message: string
    senderId?: string | null
    createdAt?: Date | string
    chat: ChatCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    chatId: string
    message: string
    senderId?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chat?: ChatUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    chatId: string
    message: string
    senderId?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductCreateInput = {
    id?: string
    earnPercentage?: number
    createdAt?: Date | string
    business: BusinessCreateNestedOneWithoutRepostedItemsInput
    product: ProductCreateNestedOneWithoutRepostsInput
  }

  export type RepostedProductUncheckedCreateInput = {
    id?: string
    businessId: string
    productId: string
    earnPercentage?: number
    createdAt?: Date | string
  }

  export type RepostedProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutRepostedItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutRepostsNestedInput
  }

  export type RepostedProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductCreateManyInput = {
    id?: string
    businessId: string
    productId: string
    earnPercentage?: number
    createdAt?: Date | string
  }

  export type RepostedProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductCreateInput = {
    id?: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
    business: BusinessCreateNestedOneWithoutReownedItemsInput
    product: ProductCreateNestedOneWithoutReownsInput
  }

  export type ReOwnedProductUncheckedCreateInput = {
    id?: string
    businessId: string
    productId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
  }

  export type ReOwnedProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutReownedItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutReownsNestedInput
  }

  export type ReOwnedProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductCreateManyInput = {
    id?: string
    businessId: string
    productId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
  }

  export type ReOwnedProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KYCCreateInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    business?: BusinessCreateNestedOneWithoutKycInput
    client?: ClientCreateNestedOneWithoutKycInput
    worker?: WorkerCreateNestedOneWithoutKycInput
  }

  export type KYCUncheckedCreateInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    businessId?: string | null
    clientId?: string | null
    workerId?: string | null
  }

  export type KYCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneWithoutKycNestedInput
    client?: ClientUpdateOneWithoutKycNestedInput
    worker?: WorkerUpdateOneWithoutKycNestedInput
  }

  export type KYCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KYCCreateManyInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    businessId?: string | null
    clientId?: string | null
    workerId?: string | null
  }

  export type KYCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type KYCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountRechargeCreateInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    createdAt?: Date | string
    business?: BusinessCreateNestedOneWithoutRechargesInput
    client?: ClientCreateNestedOneWithoutRechargesInput
  }

  export type AccountRechargeUncheckedCreateInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    businessId?: string | null
    clientId?: string | null
    createdAt?: Date | string
  }

  export type AccountRechargeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutRechargesNestedInput
    client?: ClientUpdateOneWithoutRechargesNestedInput
  }

  export type AccountRechargeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountRechargeCreateManyInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    businessId?: string | null
    clientId?: string | null
    createdAt?: Date | string
  }

  export type AccountRechargeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountRechargeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    name?: string | null
    value?: number
    createdAt?: Date | string
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    name?: string | null
    value?: number
    createdAt?: Date | string
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    id?: string
    name?: string | null
    value?: number
    createdAt?: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateInput = {
    id?: string
    status?: $Enums.PaymentStatus
    method?: $Enums.PaymentMethod
    amount: number
    transactionDate?: Date | string
    qrCode?: string | null
    createdAt?: Date | string
    order: OrderCreateNestedOneWithoutPaymentInput
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id?: string
    orderId: string
    status?: $Enums.PaymentStatus
    method?: $Enums.PaymentMethod
    amount: number
    transactionDate?: Date | string
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type PaymentTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManyInput = {
    id?: string
    orderId: string
    status?: $Enums.PaymentStatus
    method?: $Enums.PaymentMethod
    amount: number
    transactionDate?: Date | string
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdCreateInput = {
    id?: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutAdsInput
    product: ProductCreateNestedOneWithoutAdsInput
  }

  export type AdUncheckedCreateInput = {
    id?: string
    businessId: string
    productId: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type AdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutAdsNestedInput
    product?: ProductUpdateOneRequiredWithoutAdsNestedInput
  }

  export type AdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdCreateManyInput = {
    id?: string
    businessId: string
    productId: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type AdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FreelanceServiceCreateInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutFreelanceServicesInput
    orders?: FreelanceOrderCreateNestedManyWithoutServiceInput
  }

  export type FreelanceServiceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: FreelanceOrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type FreelanceServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutFreelanceServicesNestedInput
    orders?: FreelanceOrderUpdateManyWithoutServiceNestedInput
  }

  export type FreelanceServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: FreelanceOrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type FreelanceServiceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceOrderCreateInput = {
    id?: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutFreelanceOrdersInput
    service: FreelanceServiceCreateNestedOneWithoutOrdersInput
    businesses?: BusinessCreateNestedManyWithoutFreelanceOrdersInput
  }

  export type FreelanceOrderUncheckedCreateInput = {
    id?: string
    clientId: string
    serviceId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessUncheckedCreateNestedManyWithoutFreelanceOrdersInput
  }

  export type FreelanceOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutFreelanceOrdersNestedInput
    service?: FreelanceServiceUpdateOneRequiredWithoutOrdersNestedInput
    businesses?: BusinessUpdateManyWithoutFreelanceOrdersNestedInput
  }

  export type FreelanceOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUncheckedUpdateManyWithoutFreelanceOrdersNestedInput
  }

  export type FreelanceOrderCreateManyInput = {
    id?: string
    clientId: string
    serviceId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateInput = {
    id?: string
    verifiedPurchase?: boolean
    createdAt?: Date | string
    affiliateBusiness?: BusinessCreateNestedOneWithoutReferralsMadeInput
    affiliateClient?: ClientCreateNestedOneWithoutReferralsMadeInput
    referredBusiness?: BusinessCreateNestedOneWithoutReferralsReceivedInput
    referredClient?: ClientCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateInput = {
    id?: string
    affiliateBusinessId?: string | null
    affiliateClientId?: string | null
    referredBusinessId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliateBusiness?: BusinessUpdateOneWithoutReferralsMadeNestedInput
    affiliateClient?: ClientUpdateOneWithoutReferralsMadeNestedInput
    referredBusiness?: BusinessUpdateOneWithoutReferralsReceivedNestedInput
    referredClient?: ClientUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralCreateManyInput = {
    id?: string
    affiliateBusinessId?: string | null
    affiliateClientId?: string | null
    referredBusinessId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type KYCNullableScalarRelationFilter = {
    is?: KYCWhereInput | null
    isNot?: KYCWhereInput | null
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type WorkerListRelationFilter = {
    every?: WorkerWhereInput
    some?: WorkerWhereInput
    none?: WorkerWhereInput
  }

  export type RepostedProductListRelationFilter = {
    every?: RepostedProductWhereInput
    some?: RepostedProductWhereInput
    none?: RepostedProductWhereInput
  }

  export type ReOwnedProductListRelationFilter = {
    every?: ReOwnedProductWhereInput
    some?: ReOwnedProductWhereInput
    none?: ReOwnedProductWhereInput
  }

  export type AccountRechargeListRelationFilter = {
    every?: AccountRechargeWhereInput
    some?: AccountRechargeWhereInput
    none?: AccountRechargeWhereInput
  }

  export type AdListRelationFilter = {
    every?: AdWhereInput
    some?: AdWhereInput
    none?: AdWhereInput
  }

  export type FreelanceServiceListRelationFilter = {
    every?: FreelanceServiceWhereInput
    some?: FreelanceServiceWhereInput
    none?: FreelanceServiceWhereInput
  }

  export type FreelanceOrderListRelationFilter = {
    every?: FreelanceOrderWhereInput
    some?: FreelanceOrderWhereInput
    none?: FreelanceOrderWhereInput
  }

  export type ReferralListRelationFilter = {
    every?: ReferralWhereInput
    some?: ReferralWhereInput
    none?: ReferralWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RepostedProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReOwnedProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountRechargeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelanceServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelanceOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReferralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    description?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessScalarRelationFilter = {
    is?: BusinessWhereInput
    isNot?: BusinessWhereInput
  }

  export type WorkerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type MediaListRelationFilter = {
    every?: MediaWhereInput
    some?: MediaWhereInput
    none?: MediaWhereInput
  }

  export type OrderProductListRelationFilter = {
    every?: OrderProductWhereInput
    some?: OrderProductWhereInput
    none?: OrderProductWhereInput
  }

  export type MediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    type?: SortOrder
    productId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type PaymentTransactionNullableScalarRelationFilter = {
    is?: PaymentTransactionWhereInput | null
    isNot?: PaymentTransactionWhereInput | null
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    deliveryFee?: SortOrder
    deliveryAddress?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    deliveryFee?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    deliveryFee?: SortOrder
    deliveryAddress?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    deliveryFee?: SortOrder
    deliveryAddress?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    deliveryFee?: SortOrder
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderProductCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderProductAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type OrderProductMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderProductMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
  }

  export type OrderProductSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type BusinessNullableScalarRelationFilter = {
    is?: BusinessWhereInput | null
    isNot?: BusinessWhereInput | null
  }

  export type WorkerNullableScalarRelationFilter = {
    is?: WorkerWhereInput | null
    isNot?: WorkerWhereInput | null
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    businessId?: SortOrder
    workerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    businessId?: SortOrder
    workerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    productId?: SortOrder
    businessId?: SortOrder
    workerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatScalarRelationFilter = {
    is?: ChatWhereInput
    isNot?: ChatWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
  }

  export type RepostedProductCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    earnPercentage?: SortOrder
    createdAt?: SortOrder
  }

  export type RepostedProductAvgOrderByAggregateInput = {
    earnPercentage?: SortOrder
  }

  export type RepostedProductMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    earnPercentage?: SortOrder
    createdAt?: SortOrder
  }

  export type RepostedProductMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    earnPercentage?: SortOrder
    createdAt?: SortOrder
  }

  export type RepostedProductSumOrderByAggregateInput = {
    earnPercentage?: SortOrder
  }

  export type ReOwnedProductCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    oldOwnerId?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
    agreedViaChatId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReOwnedProductAvgOrderByAggregateInput = {
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
  }

  export type ReOwnedProductMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    oldOwnerId?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
    agreedViaChatId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReOwnedProductMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    oldOwnerId?: SortOrder
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
    agreedViaChatId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReOwnedProductSumOrderByAggregateInput = {
    oldPrice?: SortOrder
    newPrice?: SortOrder
    markupPercentage?: SortOrder
  }

  export type EnumKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusFilter<$PrismaModel> | $Enums.KycStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClientNullableScalarRelationFilter = {
    is?: ClientWhereInput | null
    isNot?: ClientWhereInput | null
  }

  export type KYCCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    submittedAt?: SortOrder
    verifiedAt?: SortOrder
    businessId?: SortOrder
    clientId?: SortOrder
    workerId?: SortOrder
  }

  export type KYCMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    submittedAt?: SortOrder
    verifiedAt?: SortOrder
    businessId?: SortOrder
    clientId?: SortOrder
    workerId?: SortOrder
  }

  export type KYCMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    documentUrl?: SortOrder
    submittedAt?: SortOrder
    verifiedAt?: SortOrder
    businessId?: SortOrder
    clientId?: SortOrder
    workerId?: SortOrder
  }

  export type EnumKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.KycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycStatusFilter<$PrismaModel>
    _max?: NestedEnumKycStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumRechargeMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeMethod | EnumRechargeMethodFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumRechargeMethodFilter<$PrismaModel> | $Enums.RechargeMethod
  }

  export type EnumCountryFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryFilter<$PrismaModel> | $Enums.Country
  }

  export type AccountRechargeCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    origin?: SortOrder
    businessId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountRechargeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AccountRechargeMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    origin?: SortOrder
    businessId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountRechargeMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    origin?: SortOrder
    businessId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
  }

  export type AccountRechargeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumRechargeMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeMethod | EnumRechargeMethodFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumRechargeMethodWithAggregatesFilter<$PrismaModel> | $Enums.RechargeMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRechargeMethodFilter<$PrismaModel>
    _max?: NestedEnumRechargeMethodFilter<$PrismaModel>
  }

  export type EnumCountryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryWithAggregatesFilter<$PrismaModel> | $Enums.Country
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCountryFilter<$PrismaModel>
    _max?: NestedEnumCountryFilter<$PrismaModel>
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    transactionDate?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    transactionDate?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    status?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    transactionDate?: SortOrder
    qrCode?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type AdCountOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    periodDays?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type AdAvgOrderByAggregateInput = {
    price?: SortOrder
    periodDays?: SortOrder
  }

  export type AdMaxOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    periodDays?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type AdMinOrderByAggregateInput = {
    id?: SortOrder
    businessId?: SortOrder
    productId?: SortOrder
    price?: SortOrder
    periodDays?: SortOrder
    createdAt?: SortOrder
    endedAt?: SortOrder
  }

  export type AdSumOrderByAggregateInput = {
    price?: SortOrder
    periodDays?: SortOrder
  }

  export type FreelanceServiceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isHourly?: SortOrder
    rate?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceServiceAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type FreelanceServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isHourly?: SortOrder
    rate?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceServiceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isHourly?: SortOrder
    rate?: SortOrder
    businessId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceServiceSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type EnumFreelanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FreelanceStatus | EnumFreelanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFreelanceStatusFilter<$PrismaModel> | $Enums.FreelanceStatus
  }

  export type FreelanceServiceScalarRelationFilter = {
    is?: FreelanceServiceWhereInput
    isNot?: FreelanceServiceWhereInput
  }

  export type BusinessListRelationFilter = {
    every?: BusinessWhereInput
    some?: BusinessWhereInput
    none?: BusinessWhereInput
  }

  export type BusinessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FreelanceOrderCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceOrderAvgOrderByAggregateInput = {
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
  }

  export type FreelanceOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceOrderMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    serviceId?: SortOrder
    status?: SortOrder
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FreelanceOrderSumOrderByAggregateInput = {
    quantity?: SortOrder
    totalAmount?: SortOrder
    escrowAmount?: SortOrder
    commissionPercent?: SortOrder
  }

  export type EnumFreelanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FreelanceStatus | EnumFreelanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFreelanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.FreelanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFreelanceStatusFilter<$PrismaModel>
    _max?: NestedEnumFreelanceStatusFilter<$PrismaModel>
  }

  export type ReferralCountOrderByAggregateInput = {
    id?: SortOrder
    affiliateBusinessId?: SortOrder
    affiliateClientId?: SortOrder
    referredBusinessId?: SortOrder
    referredClientId?: SortOrder
    verifiedPurchase?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMaxOrderByAggregateInput = {
    id?: SortOrder
    affiliateBusinessId?: SortOrder
    affiliateClientId?: SortOrder
    referredBusinessId?: SortOrder
    referredClientId?: SortOrder
    verifiedPurchase?: SortOrder
    createdAt?: SortOrder
  }

  export type ReferralMinOrderByAggregateInput = {
    id?: SortOrder
    affiliateBusinessId?: SortOrder
    affiliateClientId?: SortOrder
    referredBusinessId?: SortOrder
    referredClientId?: SortOrder
    verifiedPurchase?: SortOrder
    createdAt?: SortOrder
  }

  export type KYCCreateNestedOneWithoutBusinessInput = {
    create?: XOR<KYCCreateWithoutBusinessInput, KYCUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: KYCCreateOrConnectWithoutBusinessInput
    connect?: KYCWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ProductCreateWithoutBusinessInput, ProductUncheckedCreateWithoutBusinessInput> | ProductCreateWithoutBusinessInput[] | ProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessInput | ProductCreateOrConnectWithoutBusinessInput[]
    createMany?: ProductCreateManyBusinessInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type WorkerCreateNestedManyWithoutBusinessInput = {
    create?: XOR<WorkerCreateWithoutBusinessInput, WorkerUncheckedCreateWithoutBusinessInput> | WorkerCreateWithoutBusinessInput[] | WorkerUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutBusinessInput | WorkerCreateOrConnectWithoutBusinessInput[]
    createMany?: WorkerCreateManyBusinessInputEnvelope
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type RepostedProductCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RepostedProductCreateWithoutBusinessInput, RepostedProductUncheckedCreateWithoutBusinessInput> | RepostedProductCreateWithoutBusinessInput[] | RepostedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutBusinessInput | RepostedProductCreateOrConnectWithoutBusinessInput[]
    createMany?: RepostedProductCreateManyBusinessInputEnvelope
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
  }

  export type ReOwnedProductCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ReOwnedProductCreateWithoutBusinessInput, ReOwnedProductUncheckedCreateWithoutBusinessInput> | ReOwnedProductCreateWithoutBusinessInput[] | ReOwnedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutBusinessInput | ReOwnedProductCreateOrConnectWithoutBusinessInput[]
    createMany?: ReOwnedProductCreateManyBusinessInputEnvelope
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
  }

  export type AccountRechargeCreateNestedManyWithoutBusinessInput = {
    create?: XOR<AccountRechargeCreateWithoutBusinessInput, AccountRechargeUncheckedCreateWithoutBusinessInput> | AccountRechargeCreateWithoutBusinessInput[] | AccountRechargeUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutBusinessInput | AccountRechargeCreateOrConnectWithoutBusinessInput[]
    createMany?: AccountRechargeCreateManyBusinessInputEnvelope
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutBusinessInput = {
    create?: XOR<AdCreateWithoutBusinessInput, AdUncheckedCreateWithoutBusinessInput> | AdCreateWithoutBusinessInput[] | AdUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdCreateOrConnectWithoutBusinessInput | AdCreateOrConnectWithoutBusinessInput[]
    createMany?: AdCreateManyBusinessInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type FreelanceServiceCreateNestedManyWithoutBusinessInput = {
    create?: XOR<FreelanceServiceCreateWithoutBusinessInput, FreelanceServiceUncheckedCreateWithoutBusinessInput> | FreelanceServiceCreateWithoutBusinessInput[] | FreelanceServiceUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FreelanceServiceCreateOrConnectWithoutBusinessInput | FreelanceServiceCreateOrConnectWithoutBusinessInput[]
    createMany?: FreelanceServiceCreateManyBusinessInputEnvelope
    connect?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
  }

  export type FreelanceOrderCreateNestedManyWithoutBusinessesInput = {
    create?: XOR<FreelanceOrderCreateWithoutBusinessesInput, FreelanceOrderUncheckedCreateWithoutBusinessesInput> | FreelanceOrderCreateWithoutBusinessesInput[] | FreelanceOrderUncheckedCreateWithoutBusinessesInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutBusinessesInput | FreelanceOrderCreateOrConnectWithoutBusinessesInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutAffiliateBusinessInput = {
    create?: XOR<ReferralCreateWithoutAffiliateBusinessInput, ReferralUncheckedCreateWithoutAffiliateBusinessInput> | ReferralCreateWithoutAffiliateBusinessInput[] | ReferralUncheckedCreateWithoutAffiliateBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateBusinessInput | ReferralCreateOrConnectWithoutAffiliateBusinessInput[]
    createMany?: ReferralCreateManyAffiliateBusinessInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferredBusinessInput = {
    create?: XOR<ReferralCreateWithoutReferredBusinessInput, ReferralUncheckedCreateWithoutReferredBusinessInput> | ReferralCreateWithoutReferredBusinessInput[] | ReferralUncheckedCreateWithoutReferredBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredBusinessInput | ReferralCreateOrConnectWithoutReferredBusinessInput[]
    createMany?: ReferralCreateManyReferredBusinessInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type KYCUncheckedCreateNestedOneWithoutBusinessInput = {
    create?: XOR<KYCCreateWithoutBusinessInput, KYCUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: KYCCreateOrConnectWithoutBusinessInput
    connect?: KYCWhereUniqueInput
  }

  export type ProductUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ProductCreateWithoutBusinessInput, ProductUncheckedCreateWithoutBusinessInput> | ProductCreateWithoutBusinessInput[] | ProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessInput | ProductCreateOrConnectWithoutBusinessInput[]
    createMany?: ProductCreateManyBusinessInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type WorkerUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<WorkerCreateWithoutBusinessInput, WorkerUncheckedCreateWithoutBusinessInput> | WorkerCreateWithoutBusinessInput[] | WorkerUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutBusinessInput | WorkerCreateOrConnectWithoutBusinessInput[]
    createMany?: WorkerCreateManyBusinessInputEnvelope
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
  }

  export type RepostedProductUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<RepostedProductCreateWithoutBusinessInput, RepostedProductUncheckedCreateWithoutBusinessInput> | RepostedProductCreateWithoutBusinessInput[] | RepostedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutBusinessInput | RepostedProductCreateOrConnectWithoutBusinessInput[]
    createMany?: RepostedProductCreateManyBusinessInputEnvelope
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
  }

  export type ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ReOwnedProductCreateWithoutBusinessInput, ReOwnedProductUncheckedCreateWithoutBusinessInput> | ReOwnedProductCreateWithoutBusinessInput[] | ReOwnedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutBusinessInput | ReOwnedProductCreateOrConnectWithoutBusinessInput[]
    createMany?: ReOwnedProductCreateManyBusinessInputEnvelope
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
  }

  export type AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<AccountRechargeCreateWithoutBusinessInput, AccountRechargeUncheckedCreateWithoutBusinessInput> | AccountRechargeCreateWithoutBusinessInput[] | AccountRechargeUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutBusinessInput | AccountRechargeCreateOrConnectWithoutBusinessInput[]
    createMany?: AccountRechargeCreateManyBusinessInputEnvelope
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<AdCreateWithoutBusinessInput, AdUncheckedCreateWithoutBusinessInput> | AdCreateWithoutBusinessInput[] | AdUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdCreateOrConnectWithoutBusinessInput | AdCreateOrConnectWithoutBusinessInput[]
    createMany?: AdCreateManyBusinessInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<FreelanceServiceCreateWithoutBusinessInput, FreelanceServiceUncheckedCreateWithoutBusinessInput> | FreelanceServiceCreateWithoutBusinessInput[] | FreelanceServiceUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FreelanceServiceCreateOrConnectWithoutBusinessInput | FreelanceServiceCreateOrConnectWithoutBusinessInput[]
    createMany?: FreelanceServiceCreateManyBusinessInputEnvelope
    connect?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
  }

  export type FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput = {
    create?: XOR<FreelanceOrderCreateWithoutBusinessesInput, FreelanceOrderUncheckedCreateWithoutBusinessesInput> | FreelanceOrderCreateWithoutBusinessesInput[] | FreelanceOrderUncheckedCreateWithoutBusinessesInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutBusinessesInput | FreelanceOrderCreateOrConnectWithoutBusinessesInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput = {
    create?: XOR<ReferralCreateWithoutAffiliateBusinessInput, ReferralUncheckedCreateWithoutAffiliateBusinessInput> | ReferralCreateWithoutAffiliateBusinessInput[] | ReferralUncheckedCreateWithoutAffiliateBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateBusinessInput | ReferralCreateOrConnectWithoutAffiliateBusinessInput[]
    createMany?: ReferralCreateManyAffiliateBusinessInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput = {
    create?: XOR<ReferralCreateWithoutReferredBusinessInput, ReferralUncheckedCreateWithoutReferredBusinessInput> | ReferralCreateWithoutReferredBusinessInput[] | ReferralUncheckedCreateWithoutReferredBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredBusinessInput | ReferralCreateOrConnectWithoutReferredBusinessInput[]
    createMany?: ReferralCreateManyReferredBusinessInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutBusinessInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type KYCUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<KYCCreateWithoutBusinessInput, KYCUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: KYCCreateOrConnectWithoutBusinessInput
    upsert?: KYCUpsertWithoutBusinessInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutBusinessInput, KYCUpdateWithoutBusinessInput>, KYCUncheckedUpdateWithoutBusinessInput>
  }

  export type ProductUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ProductCreateWithoutBusinessInput, ProductUncheckedCreateWithoutBusinessInput> | ProductCreateWithoutBusinessInput[] | ProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessInput | ProductCreateOrConnectWithoutBusinessInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBusinessInput | ProductUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ProductCreateManyBusinessInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBusinessInput | ProductUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBusinessInput | ProductUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type WorkerUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<WorkerCreateWithoutBusinessInput, WorkerUncheckedCreateWithoutBusinessInput> | WorkerCreateWithoutBusinessInput[] | WorkerUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutBusinessInput | WorkerCreateOrConnectWithoutBusinessInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutBusinessInput | WorkerUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: WorkerCreateManyBusinessInputEnvelope
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutBusinessInput | WorkerUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutBusinessInput | WorkerUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type RepostedProductUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RepostedProductCreateWithoutBusinessInput, RepostedProductUncheckedCreateWithoutBusinessInput> | RepostedProductCreateWithoutBusinessInput[] | RepostedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutBusinessInput | RepostedProductCreateOrConnectWithoutBusinessInput[]
    upsert?: RepostedProductUpsertWithWhereUniqueWithoutBusinessInput | RepostedProductUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RepostedProductCreateManyBusinessInputEnvelope
    set?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    disconnect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    delete?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    update?: RepostedProductUpdateWithWhereUniqueWithoutBusinessInput | RepostedProductUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RepostedProductUpdateManyWithWhereWithoutBusinessInput | RepostedProductUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RepostedProductScalarWhereInput | RepostedProductScalarWhereInput[]
  }

  export type ReOwnedProductUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ReOwnedProductCreateWithoutBusinessInput, ReOwnedProductUncheckedCreateWithoutBusinessInput> | ReOwnedProductCreateWithoutBusinessInput[] | ReOwnedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutBusinessInput | ReOwnedProductCreateOrConnectWithoutBusinessInput[]
    upsert?: ReOwnedProductUpsertWithWhereUniqueWithoutBusinessInput | ReOwnedProductUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ReOwnedProductCreateManyBusinessInputEnvelope
    set?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    disconnect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    delete?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    update?: ReOwnedProductUpdateWithWhereUniqueWithoutBusinessInput | ReOwnedProductUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ReOwnedProductUpdateManyWithWhereWithoutBusinessInput | ReOwnedProductUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ReOwnedProductScalarWhereInput | ReOwnedProductScalarWhereInput[]
  }

  export type AccountRechargeUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<AccountRechargeCreateWithoutBusinessInput, AccountRechargeUncheckedCreateWithoutBusinessInput> | AccountRechargeCreateWithoutBusinessInput[] | AccountRechargeUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutBusinessInput | AccountRechargeCreateOrConnectWithoutBusinessInput[]
    upsert?: AccountRechargeUpsertWithWhereUniqueWithoutBusinessInput | AccountRechargeUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: AccountRechargeCreateManyBusinessInputEnvelope
    set?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    disconnect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    delete?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    update?: AccountRechargeUpdateWithWhereUniqueWithoutBusinessInput | AccountRechargeUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: AccountRechargeUpdateManyWithWhereWithoutBusinessInput | AccountRechargeUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: AccountRechargeScalarWhereInput | AccountRechargeScalarWhereInput[]
  }

  export type AdUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<AdCreateWithoutBusinessInput, AdUncheckedCreateWithoutBusinessInput> | AdCreateWithoutBusinessInput[] | AdUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdCreateOrConnectWithoutBusinessInput | AdCreateOrConnectWithoutBusinessInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutBusinessInput | AdUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: AdCreateManyBusinessInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutBusinessInput | AdUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: AdUpdateManyWithWhereWithoutBusinessInput | AdUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type FreelanceServiceUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<FreelanceServiceCreateWithoutBusinessInput, FreelanceServiceUncheckedCreateWithoutBusinessInput> | FreelanceServiceCreateWithoutBusinessInput[] | FreelanceServiceUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FreelanceServiceCreateOrConnectWithoutBusinessInput | FreelanceServiceCreateOrConnectWithoutBusinessInput[]
    upsert?: FreelanceServiceUpsertWithWhereUniqueWithoutBusinessInput | FreelanceServiceUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: FreelanceServiceCreateManyBusinessInputEnvelope
    set?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    disconnect?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    delete?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    connect?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    update?: FreelanceServiceUpdateWithWhereUniqueWithoutBusinessInput | FreelanceServiceUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: FreelanceServiceUpdateManyWithWhereWithoutBusinessInput | FreelanceServiceUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: FreelanceServiceScalarWhereInput | FreelanceServiceScalarWhereInput[]
  }

  export type FreelanceOrderUpdateManyWithoutBusinessesNestedInput = {
    create?: XOR<FreelanceOrderCreateWithoutBusinessesInput, FreelanceOrderUncheckedCreateWithoutBusinessesInput> | FreelanceOrderCreateWithoutBusinessesInput[] | FreelanceOrderUncheckedCreateWithoutBusinessesInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutBusinessesInput | FreelanceOrderCreateOrConnectWithoutBusinessesInput[]
    upsert?: FreelanceOrderUpsertWithWhereUniqueWithoutBusinessesInput | FreelanceOrderUpsertWithWhereUniqueWithoutBusinessesInput[]
    set?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    disconnect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    delete?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    update?: FreelanceOrderUpdateWithWhereUniqueWithoutBusinessesInput | FreelanceOrderUpdateWithWhereUniqueWithoutBusinessesInput[]
    updateMany?: FreelanceOrderUpdateManyWithWhereWithoutBusinessesInput | FreelanceOrderUpdateManyWithWhereWithoutBusinessesInput[]
    deleteMany?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutAffiliateBusinessNestedInput = {
    create?: XOR<ReferralCreateWithoutAffiliateBusinessInput, ReferralUncheckedCreateWithoutAffiliateBusinessInput> | ReferralCreateWithoutAffiliateBusinessInput[] | ReferralUncheckedCreateWithoutAffiliateBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateBusinessInput | ReferralCreateOrConnectWithoutAffiliateBusinessInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutAffiliateBusinessInput | ReferralUpsertWithWhereUniqueWithoutAffiliateBusinessInput[]
    createMany?: ReferralCreateManyAffiliateBusinessInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutAffiliateBusinessInput | ReferralUpdateWithWhereUniqueWithoutAffiliateBusinessInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutAffiliateBusinessInput | ReferralUpdateManyWithWhereWithoutAffiliateBusinessInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferredBusinessNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredBusinessInput, ReferralUncheckedCreateWithoutReferredBusinessInput> | ReferralCreateWithoutReferredBusinessInput[] | ReferralUncheckedCreateWithoutReferredBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredBusinessInput | ReferralCreateOrConnectWithoutReferredBusinessInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredBusinessInput | ReferralUpsertWithWhereUniqueWithoutReferredBusinessInput[]
    createMany?: ReferralCreateManyReferredBusinessInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredBusinessInput | ReferralUpdateWithWhereUniqueWithoutReferredBusinessInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredBusinessInput | ReferralUpdateManyWithWhereWithoutReferredBusinessInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutBusinessInput | ChatUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutBusinessInput | ChatUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutBusinessInput | ChatUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type KYCUncheckedUpdateOneWithoutBusinessNestedInput = {
    create?: XOR<KYCCreateWithoutBusinessInput, KYCUncheckedCreateWithoutBusinessInput>
    connectOrCreate?: KYCCreateOrConnectWithoutBusinessInput
    upsert?: KYCUpsertWithoutBusinessInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutBusinessInput, KYCUpdateWithoutBusinessInput>, KYCUncheckedUpdateWithoutBusinessInput>
  }

  export type ProductUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ProductCreateWithoutBusinessInput, ProductUncheckedCreateWithoutBusinessInput> | ProductCreateWithoutBusinessInput[] | ProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBusinessInput | ProductCreateOrConnectWithoutBusinessInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBusinessInput | ProductUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ProductCreateManyBusinessInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBusinessInput | ProductUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBusinessInput | ProductUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type WorkerUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<WorkerCreateWithoutBusinessInput, WorkerUncheckedCreateWithoutBusinessInput> | WorkerCreateWithoutBusinessInput[] | WorkerUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: WorkerCreateOrConnectWithoutBusinessInput | WorkerCreateOrConnectWithoutBusinessInput[]
    upsert?: WorkerUpsertWithWhereUniqueWithoutBusinessInput | WorkerUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: WorkerCreateManyBusinessInputEnvelope
    set?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    disconnect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    delete?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    connect?: WorkerWhereUniqueInput | WorkerWhereUniqueInput[]
    update?: WorkerUpdateWithWhereUniqueWithoutBusinessInput | WorkerUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: WorkerUpdateManyWithWhereWithoutBusinessInput | WorkerUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
  }

  export type RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<RepostedProductCreateWithoutBusinessInput, RepostedProductUncheckedCreateWithoutBusinessInput> | RepostedProductCreateWithoutBusinessInput[] | RepostedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutBusinessInput | RepostedProductCreateOrConnectWithoutBusinessInput[]
    upsert?: RepostedProductUpsertWithWhereUniqueWithoutBusinessInput | RepostedProductUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: RepostedProductCreateManyBusinessInputEnvelope
    set?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    disconnect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    delete?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    update?: RepostedProductUpdateWithWhereUniqueWithoutBusinessInput | RepostedProductUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: RepostedProductUpdateManyWithWhereWithoutBusinessInput | RepostedProductUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: RepostedProductScalarWhereInput | RepostedProductScalarWhereInput[]
  }

  export type ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ReOwnedProductCreateWithoutBusinessInput, ReOwnedProductUncheckedCreateWithoutBusinessInput> | ReOwnedProductCreateWithoutBusinessInput[] | ReOwnedProductUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutBusinessInput | ReOwnedProductCreateOrConnectWithoutBusinessInput[]
    upsert?: ReOwnedProductUpsertWithWhereUniqueWithoutBusinessInput | ReOwnedProductUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ReOwnedProductCreateManyBusinessInputEnvelope
    set?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    disconnect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    delete?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    update?: ReOwnedProductUpdateWithWhereUniqueWithoutBusinessInput | ReOwnedProductUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ReOwnedProductUpdateManyWithWhereWithoutBusinessInput | ReOwnedProductUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ReOwnedProductScalarWhereInput | ReOwnedProductScalarWhereInput[]
  }

  export type AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<AccountRechargeCreateWithoutBusinessInput, AccountRechargeUncheckedCreateWithoutBusinessInput> | AccountRechargeCreateWithoutBusinessInput[] | AccountRechargeUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutBusinessInput | AccountRechargeCreateOrConnectWithoutBusinessInput[]
    upsert?: AccountRechargeUpsertWithWhereUniqueWithoutBusinessInput | AccountRechargeUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: AccountRechargeCreateManyBusinessInputEnvelope
    set?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    disconnect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    delete?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    update?: AccountRechargeUpdateWithWhereUniqueWithoutBusinessInput | AccountRechargeUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: AccountRechargeUpdateManyWithWhereWithoutBusinessInput | AccountRechargeUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: AccountRechargeScalarWhereInput | AccountRechargeScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<AdCreateWithoutBusinessInput, AdUncheckedCreateWithoutBusinessInput> | AdCreateWithoutBusinessInput[] | AdUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: AdCreateOrConnectWithoutBusinessInput | AdCreateOrConnectWithoutBusinessInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutBusinessInput | AdUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: AdCreateManyBusinessInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutBusinessInput | AdUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: AdUpdateManyWithWhereWithoutBusinessInput | AdUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<FreelanceServiceCreateWithoutBusinessInput, FreelanceServiceUncheckedCreateWithoutBusinessInput> | FreelanceServiceCreateWithoutBusinessInput[] | FreelanceServiceUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: FreelanceServiceCreateOrConnectWithoutBusinessInput | FreelanceServiceCreateOrConnectWithoutBusinessInput[]
    upsert?: FreelanceServiceUpsertWithWhereUniqueWithoutBusinessInput | FreelanceServiceUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: FreelanceServiceCreateManyBusinessInputEnvelope
    set?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    disconnect?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    delete?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    connect?: FreelanceServiceWhereUniqueInput | FreelanceServiceWhereUniqueInput[]
    update?: FreelanceServiceUpdateWithWhereUniqueWithoutBusinessInput | FreelanceServiceUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: FreelanceServiceUpdateManyWithWhereWithoutBusinessInput | FreelanceServiceUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: FreelanceServiceScalarWhereInput | FreelanceServiceScalarWhereInput[]
  }

  export type FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput = {
    create?: XOR<FreelanceOrderCreateWithoutBusinessesInput, FreelanceOrderUncheckedCreateWithoutBusinessesInput> | FreelanceOrderCreateWithoutBusinessesInput[] | FreelanceOrderUncheckedCreateWithoutBusinessesInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutBusinessesInput | FreelanceOrderCreateOrConnectWithoutBusinessesInput[]
    upsert?: FreelanceOrderUpsertWithWhereUniqueWithoutBusinessesInput | FreelanceOrderUpsertWithWhereUniqueWithoutBusinessesInput[]
    set?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    disconnect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    delete?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    update?: FreelanceOrderUpdateWithWhereUniqueWithoutBusinessesInput | FreelanceOrderUpdateWithWhereUniqueWithoutBusinessesInput[]
    updateMany?: FreelanceOrderUpdateManyWithWhereWithoutBusinessesInput | FreelanceOrderUpdateManyWithWhereWithoutBusinessesInput[]
    deleteMany?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput = {
    create?: XOR<ReferralCreateWithoutAffiliateBusinessInput, ReferralUncheckedCreateWithoutAffiliateBusinessInput> | ReferralCreateWithoutAffiliateBusinessInput[] | ReferralUncheckedCreateWithoutAffiliateBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateBusinessInput | ReferralCreateOrConnectWithoutAffiliateBusinessInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutAffiliateBusinessInput | ReferralUpsertWithWhereUniqueWithoutAffiliateBusinessInput[]
    createMany?: ReferralCreateManyAffiliateBusinessInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutAffiliateBusinessInput | ReferralUpdateWithWhereUniqueWithoutAffiliateBusinessInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutAffiliateBusinessInput | ReferralUpdateManyWithWhereWithoutAffiliateBusinessInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredBusinessInput, ReferralUncheckedCreateWithoutReferredBusinessInput> | ReferralCreateWithoutReferredBusinessInput[] | ReferralUncheckedCreateWithoutReferredBusinessInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredBusinessInput | ReferralCreateOrConnectWithoutReferredBusinessInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredBusinessInput | ReferralUpsertWithWhereUniqueWithoutReferredBusinessInput[]
    createMany?: ReferralCreateManyReferredBusinessInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredBusinessInput | ReferralUpdateWithWhereUniqueWithoutReferredBusinessInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredBusinessInput | ReferralUpdateManyWithWhereWithoutReferredBusinessInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutBusinessNestedInput = {
    create?: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput> | ChatCreateWithoutBusinessInput[] | ChatUncheckedCreateWithoutBusinessInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutBusinessInput | ChatCreateOrConnectWithoutBusinessInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutBusinessInput | ChatUpsertWithWhereUniqueWithoutBusinessInput[]
    createMany?: ChatCreateManyBusinessInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutBusinessInput | ChatUpdateWithWhereUniqueWithoutBusinessInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutBusinessInput | ChatUpdateManyWithWhereWithoutBusinessInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type KYCCreateNestedOneWithoutClientInput = {
    create?: XOR<KYCCreateWithoutClientInput, KYCUncheckedCreateWithoutClientInput>
    connectOrCreate?: KYCCreateOrConnectWithoutClientInput
    connect?: KYCWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutClientInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutClientInput = {
    create?: XOR<ChatCreateWithoutClientInput, ChatUncheckedCreateWithoutClientInput> | ChatCreateWithoutClientInput[] | ChatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutClientInput | ChatCreateOrConnectWithoutClientInput[]
    createMany?: ChatCreateManyClientInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type AccountRechargeCreateNestedManyWithoutClientInput = {
    create?: XOR<AccountRechargeCreateWithoutClientInput, AccountRechargeUncheckedCreateWithoutClientInput> | AccountRechargeCreateWithoutClientInput[] | AccountRechargeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutClientInput | AccountRechargeCreateOrConnectWithoutClientInput[]
    createMany?: AccountRechargeCreateManyClientInputEnvelope
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
  }

  export type FreelanceOrderCreateNestedManyWithoutClientInput = {
    create?: XOR<FreelanceOrderCreateWithoutClientInput, FreelanceOrderUncheckedCreateWithoutClientInput> | FreelanceOrderCreateWithoutClientInput[] | FreelanceOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutClientInput | FreelanceOrderCreateOrConnectWithoutClientInput[]
    createMany?: FreelanceOrderCreateManyClientInputEnvelope
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutAffiliateClientInput = {
    create?: XOR<ReferralCreateWithoutAffiliateClientInput, ReferralUncheckedCreateWithoutAffiliateClientInput> | ReferralCreateWithoutAffiliateClientInput[] | ReferralUncheckedCreateWithoutAffiliateClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateClientInput | ReferralCreateOrConnectWithoutAffiliateClientInput[]
    createMany?: ReferralCreateManyAffiliateClientInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralCreateNestedManyWithoutReferredClientInput = {
    create?: XOR<ReferralCreateWithoutReferredClientInput, ReferralUncheckedCreateWithoutReferredClientInput> | ReferralCreateWithoutReferredClientInput[] | ReferralUncheckedCreateWithoutReferredClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredClientInput | ReferralCreateOrConnectWithoutReferredClientInput[]
    createMany?: ReferralCreateManyReferredClientInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type KYCUncheckedCreateNestedOneWithoutClientInput = {
    create?: XOR<KYCCreateWithoutClientInput, KYCUncheckedCreateWithoutClientInput>
    connectOrCreate?: KYCCreateOrConnectWithoutClientInput
    connect?: KYCWhereUniqueInput
  }

  export type OrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ChatCreateWithoutClientInput, ChatUncheckedCreateWithoutClientInput> | ChatCreateWithoutClientInput[] | ChatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutClientInput | ChatCreateOrConnectWithoutClientInput[]
    createMany?: ChatCreateManyClientInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type AccountRechargeUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<AccountRechargeCreateWithoutClientInput, AccountRechargeUncheckedCreateWithoutClientInput> | AccountRechargeCreateWithoutClientInput[] | AccountRechargeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutClientInput | AccountRechargeCreateOrConnectWithoutClientInput[]
    createMany?: AccountRechargeCreateManyClientInputEnvelope
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
  }

  export type FreelanceOrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<FreelanceOrderCreateWithoutClientInput, FreelanceOrderUncheckedCreateWithoutClientInput> | FreelanceOrderCreateWithoutClientInput[] | FreelanceOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutClientInput | FreelanceOrderCreateOrConnectWithoutClientInput[]
    createMany?: FreelanceOrderCreateManyClientInputEnvelope
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput = {
    create?: XOR<ReferralCreateWithoutAffiliateClientInput, ReferralUncheckedCreateWithoutAffiliateClientInput> | ReferralCreateWithoutAffiliateClientInput[] | ReferralUncheckedCreateWithoutAffiliateClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateClientInput | ReferralCreateOrConnectWithoutAffiliateClientInput[]
    createMany?: ReferralCreateManyAffiliateClientInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type ReferralUncheckedCreateNestedManyWithoutReferredClientInput = {
    create?: XOR<ReferralCreateWithoutReferredClientInput, ReferralUncheckedCreateWithoutReferredClientInput> | ReferralCreateWithoutReferredClientInput[] | ReferralUncheckedCreateWithoutReferredClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredClientInput | ReferralCreateOrConnectWithoutReferredClientInput[]
    createMany?: ReferralCreateManyReferredClientInputEnvelope
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
  }

  export type KYCUpdateOneWithoutClientNestedInput = {
    create?: XOR<KYCCreateWithoutClientInput, KYCUncheckedCreateWithoutClientInput>
    connectOrCreate?: KYCCreateOrConnectWithoutClientInput
    upsert?: KYCUpsertWithoutClientInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutClientInput, KYCUpdateWithoutClientInput>, KYCUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutClientInput | ReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutClientInput | ReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutClientInput | ReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutClientNestedInput = {
    create?: XOR<ChatCreateWithoutClientInput, ChatUncheckedCreateWithoutClientInput> | ChatCreateWithoutClientInput[] | ChatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutClientInput | ChatCreateOrConnectWithoutClientInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutClientInput | ChatUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ChatCreateManyClientInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutClientInput | ChatUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutClientInput | ChatUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type AccountRechargeUpdateManyWithoutClientNestedInput = {
    create?: XOR<AccountRechargeCreateWithoutClientInput, AccountRechargeUncheckedCreateWithoutClientInput> | AccountRechargeCreateWithoutClientInput[] | AccountRechargeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutClientInput | AccountRechargeCreateOrConnectWithoutClientInput[]
    upsert?: AccountRechargeUpsertWithWhereUniqueWithoutClientInput | AccountRechargeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AccountRechargeCreateManyClientInputEnvelope
    set?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    disconnect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    delete?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    update?: AccountRechargeUpdateWithWhereUniqueWithoutClientInput | AccountRechargeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AccountRechargeUpdateManyWithWhereWithoutClientInput | AccountRechargeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AccountRechargeScalarWhereInput | AccountRechargeScalarWhereInput[]
  }

  export type FreelanceOrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<FreelanceOrderCreateWithoutClientInput, FreelanceOrderUncheckedCreateWithoutClientInput> | FreelanceOrderCreateWithoutClientInput[] | FreelanceOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutClientInput | FreelanceOrderCreateOrConnectWithoutClientInput[]
    upsert?: FreelanceOrderUpsertWithWhereUniqueWithoutClientInput | FreelanceOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FreelanceOrderCreateManyClientInputEnvelope
    set?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    disconnect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    delete?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    update?: FreelanceOrderUpdateWithWhereUniqueWithoutClientInput | FreelanceOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FreelanceOrderUpdateManyWithWhereWithoutClientInput | FreelanceOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutAffiliateClientNestedInput = {
    create?: XOR<ReferralCreateWithoutAffiliateClientInput, ReferralUncheckedCreateWithoutAffiliateClientInput> | ReferralCreateWithoutAffiliateClientInput[] | ReferralUncheckedCreateWithoutAffiliateClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateClientInput | ReferralCreateOrConnectWithoutAffiliateClientInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutAffiliateClientInput | ReferralUpsertWithWhereUniqueWithoutAffiliateClientInput[]
    createMany?: ReferralCreateManyAffiliateClientInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutAffiliateClientInput | ReferralUpdateWithWhereUniqueWithoutAffiliateClientInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutAffiliateClientInput | ReferralUpdateManyWithWhereWithoutAffiliateClientInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUpdateManyWithoutReferredClientNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredClientInput, ReferralUncheckedCreateWithoutReferredClientInput> | ReferralCreateWithoutReferredClientInput[] | ReferralUncheckedCreateWithoutReferredClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredClientInput | ReferralCreateOrConnectWithoutReferredClientInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredClientInput | ReferralUpsertWithWhereUniqueWithoutReferredClientInput[]
    createMany?: ReferralCreateManyReferredClientInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredClientInput | ReferralUpdateWithWhereUniqueWithoutReferredClientInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredClientInput | ReferralUpdateManyWithWhereWithoutReferredClientInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type KYCUncheckedUpdateOneWithoutClientNestedInput = {
    create?: XOR<KYCCreateWithoutClientInput, KYCUncheckedCreateWithoutClientInput>
    connectOrCreate?: KYCCreateOrConnectWithoutClientInput
    upsert?: KYCUpsertWithoutClientInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutClientInput, KYCUpdateWithoutClientInput>, KYCUncheckedUpdateWithoutClientInput>
  }

  export type OrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput> | ReviewCreateWithoutClientInput[] | ReviewUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutClientInput | ReviewCreateOrConnectWithoutClientInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutClientInput | ReviewUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReviewCreateManyClientInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutClientInput | ReviewUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutClientInput | ReviewUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ChatCreateWithoutClientInput, ChatUncheckedCreateWithoutClientInput> | ChatCreateWithoutClientInput[] | ChatUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutClientInput | ChatCreateOrConnectWithoutClientInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutClientInput | ChatUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ChatCreateManyClientInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutClientInput | ChatUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutClientInput | ChatUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type AccountRechargeUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<AccountRechargeCreateWithoutClientInput, AccountRechargeUncheckedCreateWithoutClientInput> | AccountRechargeCreateWithoutClientInput[] | AccountRechargeUncheckedCreateWithoutClientInput[]
    connectOrCreate?: AccountRechargeCreateOrConnectWithoutClientInput | AccountRechargeCreateOrConnectWithoutClientInput[]
    upsert?: AccountRechargeUpsertWithWhereUniqueWithoutClientInput | AccountRechargeUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: AccountRechargeCreateManyClientInputEnvelope
    set?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    disconnect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    delete?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    connect?: AccountRechargeWhereUniqueInput | AccountRechargeWhereUniqueInput[]
    update?: AccountRechargeUpdateWithWhereUniqueWithoutClientInput | AccountRechargeUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: AccountRechargeUpdateManyWithWhereWithoutClientInput | AccountRechargeUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: AccountRechargeScalarWhereInput | AccountRechargeScalarWhereInput[]
  }

  export type FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<FreelanceOrderCreateWithoutClientInput, FreelanceOrderUncheckedCreateWithoutClientInput> | FreelanceOrderCreateWithoutClientInput[] | FreelanceOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutClientInput | FreelanceOrderCreateOrConnectWithoutClientInput[]
    upsert?: FreelanceOrderUpsertWithWhereUniqueWithoutClientInput | FreelanceOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: FreelanceOrderCreateManyClientInputEnvelope
    set?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    disconnect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    delete?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    update?: FreelanceOrderUpdateWithWhereUniqueWithoutClientInput | FreelanceOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: FreelanceOrderUpdateManyWithWhereWithoutClientInput | FreelanceOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput = {
    create?: XOR<ReferralCreateWithoutAffiliateClientInput, ReferralUncheckedCreateWithoutAffiliateClientInput> | ReferralCreateWithoutAffiliateClientInput[] | ReferralUncheckedCreateWithoutAffiliateClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutAffiliateClientInput | ReferralCreateOrConnectWithoutAffiliateClientInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutAffiliateClientInput | ReferralUpsertWithWhereUniqueWithoutAffiliateClientInput[]
    createMany?: ReferralCreateManyAffiliateClientInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutAffiliateClientInput | ReferralUpdateWithWhereUniqueWithoutAffiliateClientInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutAffiliateClientInput | ReferralUpdateManyWithWhereWithoutAffiliateClientInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type ReferralUncheckedUpdateManyWithoutReferredClientNestedInput = {
    create?: XOR<ReferralCreateWithoutReferredClientInput, ReferralUncheckedCreateWithoutReferredClientInput> | ReferralCreateWithoutReferredClientInput[] | ReferralUncheckedCreateWithoutReferredClientInput[]
    connectOrCreate?: ReferralCreateOrConnectWithoutReferredClientInput | ReferralCreateOrConnectWithoutReferredClientInput[]
    upsert?: ReferralUpsertWithWhereUniqueWithoutReferredClientInput | ReferralUpsertWithWhereUniqueWithoutReferredClientInput[]
    createMany?: ReferralCreateManyReferredClientInputEnvelope
    set?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    disconnect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    delete?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    connect?: ReferralWhereUniqueInput | ReferralWhereUniqueInput[]
    update?: ReferralUpdateWithWhereUniqueWithoutReferredClientInput | ReferralUpdateWithWhereUniqueWithoutReferredClientInput[]
    updateMany?: ReferralUpdateManyWithWhereWithoutReferredClientInput | ReferralUpdateManyWithWhereWithoutReferredClientInput[]
    deleteMany?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutWorkersInput = {
    create?: XOR<BusinessCreateWithoutWorkersInput, BusinessUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutWorkersInput
    connect?: BusinessWhereUniqueInput
  }

  export type KYCCreateNestedOneWithoutWorkerInput = {
    create?: XOR<KYCCreateWithoutWorkerInput, KYCUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: KYCCreateOrConnectWithoutWorkerInput
    connect?: KYCWhereUniqueInput
  }

  export type ChatCreateNestedManyWithoutWorkerInput = {
    create?: XOR<ChatCreateWithoutWorkerInput, ChatUncheckedCreateWithoutWorkerInput> | ChatCreateWithoutWorkerInput[] | ChatUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkerInput | ChatCreateOrConnectWithoutWorkerInput[]
    createMany?: ChatCreateManyWorkerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type KYCUncheckedCreateNestedOneWithoutWorkerInput = {
    create?: XOR<KYCCreateWithoutWorkerInput, KYCUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: KYCCreateOrConnectWithoutWorkerInput
    connect?: KYCWhereUniqueInput
  }

  export type ChatUncheckedCreateNestedManyWithoutWorkerInput = {
    create?: XOR<ChatCreateWithoutWorkerInput, ChatUncheckedCreateWithoutWorkerInput> | ChatCreateWithoutWorkerInput[] | ChatUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkerInput | ChatCreateOrConnectWithoutWorkerInput[]
    createMany?: ChatCreateManyWorkerInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type BusinessUpdateOneRequiredWithoutWorkersNestedInput = {
    create?: XOR<BusinessCreateWithoutWorkersInput, BusinessUncheckedCreateWithoutWorkersInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutWorkersInput
    upsert?: BusinessUpsertWithoutWorkersInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutWorkersInput, BusinessUpdateWithoutWorkersInput>, BusinessUncheckedUpdateWithoutWorkersInput>
  }

  export type KYCUpdateOneWithoutWorkerNestedInput = {
    create?: XOR<KYCCreateWithoutWorkerInput, KYCUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: KYCCreateOrConnectWithoutWorkerInput
    upsert?: KYCUpsertWithoutWorkerInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutWorkerInput, KYCUpdateWithoutWorkerInput>, KYCUncheckedUpdateWithoutWorkerInput>
  }

  export type ChatUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<ChatCreateWithoutWorkerInput, ChatUncheckedCreateWithoutWorkerInput> | ChatCreateWithoutWorkerInput[] | ChatUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkerInput | ChatCreateOrConnectWithoutWorkerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutWorkerInput | ChatUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: ChatCreateManyWorkerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutWorkerInput | ChatUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutWorkerInput | ChatUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type KYCUncheckedUpdateOneWithoutWorkerNestedInput = {
    create?: XOR<KYCCreateWithoutWorkerInput, KYCUncheckedCreateWithoutWorkerInput>
    connectOrCreate?: KYCCreateOrConnectWithoutWorkerInput
    upsert?: KYCUpsertWithoutWorkerInput
    disconnect?: KYCWhereInput | boolean
    delete?: KYCWhereInput | boolean
    connect?: KYCWhereUniqueInput
    update?: XOR<XOR<KYCUpdateToOneWithWhereWithoutWorkerInput, KYCUpdateWithoutWorkerInput>, KYCUncheckedUpdateWithoutWorkerInput>
  }

  export type ChatUncheckedUpdateManyWithoutWorkerNestedInput = {
    create?: XOR<ChatCreateWithoutWorkerInput, ChatUncheckedCreateWithoutWorkerInput> | ChatCreateWithoutWorkerInput[] | ChatUncheckedCreateWithoutWorkerInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkerInput | ChatCreateOrConnectWithoutWorkerInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutWorkerInput | ChatUpsertWithWhereUniqueWithoutWorkerInput[]
    createMany?: ChatCreateManyWorkerInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutWorkerInput | ChatUpdateWithWhereUniqueWithoutWorkerInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutWorkerInput | ChatUpdateManyWithWhereWithoutWorkerInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutProductsInput = {
    create?: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutProductsInput
    connect?: BusinessWhereUniqueInput
  }

  export type MediaCreateNestedManyWithoutProductInput = {
    create?: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput> | MediaCreateWithoutProductInput[] | MediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductInput | MediaCreateOrConnectWithoutProductInput[]
    createMany?: MediaCreateManyProductInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderProductCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutProductInput = {
    create?: XOR<ChatCreateWithoutProductInput, ChatUncheckedCreateWithoutProductInput> | ChatCreateWithoutProductInput[] | ChatUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutProductInput | ChatCreateOrConnectWithoutProductInput[]
    createMany?: ChatCreateManyProductInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type RepostedProductCreateNestedManyWithoutProductInput = {
    create?: XOR<RepostedProductCreateWithoutProductInput, RepostedProductUncheckedCreateWithoutProductInput> | RepostedProductCreateWithoutProductInput[] | RepostedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutProductInput | RepostedProductCreateOrConnectWithoutProductInput[]
    createMany?: RepostedProductCreateManyProductInputEnvelope
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
  }

  export type ReOwnedProductCreateNestedManyWithoutProductInput = {
    create?: XOR<ReOwnedProductCreateWithoutProductInput, ReOwnedProductUncheckedCreateWithoutProductInput> | ReOwnedProductCreateWithoutProductInput[] | ReOwnedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutProductInput | ReOwnedProductCreateOrConnectWithoutProductInput[]
    createMany?: ReOwnedProductCreateManyProductInputEnvelope
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
  }

  export type AdCreateNestedManyWithoutProductInput = {
    create?: XOR<AdCreateWithoutProductInput, AdUncheckedCreateWithoutProductInput> | AdCreateWithoutProductInput[] | AdUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdCreateOrConnectWithoutProductInput | AdCreateOrConnectWithoutProductInput[]
    createMany?: AdCreateManyProductInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type MediaUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput> | MediaCreateWithoutProductInput[] | MediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductInput | MediaCreateOrConnectWithoutProductInput[]
    createMany?: MediaCreateManyProductInputEnvelope
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type OrderProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ChatCreateWithoutProductInput, ChatUncheckedCreateWithoutProductInput> | ChatCreateWithoutProductInput[] | ChatUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutProductInput | ChatCreateOrConnectWithoutProductInput[]
    createMany?: ChatCreateManyProductInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type RepostedProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<RepostedProductCreateWithoutProductInput, RepostedProductUncheckedCreateWithoutProductInput> | RepostedProductCreateWithoutProductInput[] | RepostedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutProductInput | RepostedProductCreateOrConnectWithoutProductInput[]
    createMany?: RepostedProductCreateManyProductInputEnvelope
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
  }

  export type ReOwnedProductUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReOwnedProductCreateWithoutProductInput, ReOwnedProductUncheckedCreateWithoutProductInput> | ReOwnedProductCreateWithoutProductInput[] | ReOwnedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutProductInput | ReOwnedProductCreateOrConnectWithoutProductInput[]
    createMany?: ReOwnedProductCreateManyProductInputEnvelope
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
  }

  export type AdUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<AdCreateWithoutProductInput, AdUncheckedCreateWithoutProductInput> | AdCreateWithoutProductInput[] | AdUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdCreateOrConnectWithoutProductInput | AdCreateOrConnectWithoutProductInput[]
    createMany?: AdCreateManyProductInputEnvelope
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutProductsInput
    upsert?: BusinessUpsertWithoutProductsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutProductsInput, BusinessUpdateWithoutProductsInput>, BusinessUncheckedUpdateWithoutProductsInput>
  }

  export type MediaUpdateManyWithoutProductNestedInput = {
    create?: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput> | MediaCreateWithoutProductInput[] | MediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductInput | MediaCreateOrConnectWithoutProductInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProductInput | MediaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MediaCreateManyProductInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProductInput | MediaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProductInput | MediaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutProductInput | OrderProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutProductInput | OrderProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutProductInput | OrderProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutProductNestedInput = {
    create?: XOR<ChatCreateWithoutProductInput, ChatUncheckedCreateWithoutProductInput> | ChatCreateWithoutProductInput[] | ChatUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutProductInput | ChatCreateOrConnectWithoutProductInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutProductInput | ChatUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ChatCreateManyProductInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutProductInput | ChatUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutProductInput | ChatUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type RepostedProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<RepostedProductCreateWithoutProductInput, RepostedProductUncheckedCreateWithoutProductInput> | RepostedProductCreateWithoutProductInput[] | RepostedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutProductInput | RepostedProductCreateOrConnectWithoutProductInput[]
    upsert?: RepostedProductUpsertWithWhereUniqueWithoutProductInput | RepostedProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RepostedProductCreateManyProductInputEnvelope
    set?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    disconnect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    delete?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    update?: RepostedProductUpdateWithWhereUniqueWithoutProductInput | RepostedProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RepostedProductUpdateManyWithWhereWithoutProductInput | RepostedProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RepostedProductScalarWhereInput | RepostedProductScalarWhereInput[]
  }

  export type ReOwnedProductUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReOwnedProductCreateWithoutProductInput, ReOwnedProductUncheckedCreateWithoutProductInput> | ReOwnedProductCreateWithoutProductInput[] | ReOwnedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutProductInput | ReOwnedProductCreateOrConnectWithoutProductInput[]
    upsert?: ReOwnedProductUpsertWithWhereUniqueWithoutProductInput | ReOwnedProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReOwnedProductCreateManyProductInputEnvelope
    set?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    disconnect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    delete?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    update?: ReOwnedProductUpdateWithWhereUniqueWithoutProductInput | ReOwnedProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReOwnedProductUpdateManyWithWhereWithoutProductInput | ReOwnedProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReOwnedProductScalarWhereInput | ReOwnedProductScalarWhereInput[]
  }

  export type AdUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdCreateWithoutProductInput, AdUncheckedCreateWithoutProductInput> | AdCreateWithoutProductInput[] | AdUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdCreateOrConnectWithoutProductInput | AdCreateOrConnectWithoutProductInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutProductInput | AdUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdCreateManyProductInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutProductInput | AdUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdUpdateManyWithWhereWithoutProductInput | AdUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type MediaUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput> | MediaCreateWithoutProductInput[] | MediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: MediaCreateOrConnectWithoutProductInput | MediaCreateOrConnectWithoutProductInput[]
    upsert?: MediaUpsertWithWhereUniqueWithoutProductInput | MediaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: MediaCreateManyProductInputEnvelope
    set?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    disconnect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    delete?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    connect?: MediaWhereUniqueInput | MediaWhereUniqueInput[]
    update?: MediaUpdateWithWhereUniqueWithoutProductInput | MediaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: MediaUpdateManyWithWhereWithoutProductInput | MediaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: MediaScalarWhereInput | MediaScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type OrderProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput> | OrderProductCreateWithoutProductInput[] | OrderProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutProductInput | OrderProductCreateOrConnectWithoutProductInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutProductInput | OrderProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderProductCreateManyProductInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutProductInput | OrderProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutProductInput | OrderProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ChatCreateWithoutProductInput, ChatUncheckedCreateWithoutProductInput> | ChatCreateWithoutProductInput[] | ChatUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutProductInput | ChatCreateOrConnectWithoutProductInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutProductInput | ChatUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ChatCreateManyProductInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutProductInput | ChatUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutProductInput | ChatUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type RepostedProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<RepostedProductCreateWithoutProductInput, RepostedProductUncheckedCreateWithoutProductInput> | RepostedProductCreateWithoutProductInput[] | RepostedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: RepostedProductCreateOrConnectWithoutProductInput | RepostedProductCreateOrConnectWithoutProductInput[]
    upsert?: RepostedProductUpsertWithWhereUniqueWithoutProductInput | RepostedProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: RepostedProductCreateManyProductInputEnvelope
    set?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    disconnect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    delete?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    connect?: RepostedProductWhereUniqueInput | RepostedProductWhereUniqueInput[]
    update?: RepostedProductUpdateWithWhereUniqueWithoutProductInput | RepostedProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: RepostedProductUpdateManyWithWhereWithoutProductInput | RepostedProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: RepostedProductScalarWhereInput | RepostedProductScalarWhereInput[]
  }

  export type ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReOwnedProductCreateWithoutProductInput, ReOwnedProductUncheckedCreateWithoutProductInput> | ReOwnedProductCreateWithoutProductInput[] | ReOwnedProductUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReOwnedProductCreateOrConnectWithoutProductInput | ReOwnedProductCreateOrConnectWithoutProductInput[]
    upsert?: ReOwnedProductUpsertWithWhereUniqueWithoutProductInput | ReOwnedProductUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReOwnedProductCreateManyProductInputEnvelope
    set?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    disconnect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    delete?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    connect?: ReOwnedProductWhereUniqueInput | ReOwnedProductWhereUniqueInput[]
    update?: ReOwnedProductUpdateWithWhereUniqueWithoutProductInput | ReOwnedProductUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReOwnedProductUpdateManyWithWhereWithoutProductInput | ReOwnedProductUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReOwnedProductScalarWhereInput | ReOwnedProductScalarWhereInput[]
  }

  export type AdUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<AdCreateWithoutProductInput, AdUncheckedCreateWithoutProductInput> | AdCreateWithoutProductInput[] | AdUncheckedCreateWithoutProductInput[]
    connectOrCreate?: AdCreateOrConnectWithoutProductInput | AdCreateOrConnectWithoutProductInput[]
    upsert?: AdUpsertWithWhereUniqueWithoutProductInput | AdUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: AdCreateManyProductInputEnvelope
    set?: AdWhereUniqueInput | AdWhereUniqueInput[]
    disconnect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    delete?: AdWhereUniqueInput | AdWhereUniqueInput[]
    connect?: AdWhereUniqueInput | AdWhereUniqueInput[]
    update?: AdUpdateWithWhereUniqueWithoutProductInput | AdUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: AdUpdateManyWithWhereWithoutProductInput | AdUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: AdScalarWhereInput | AdScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutMediasInput = {
    create?: XOR<ProductCreateWithoutMediasInput, ProductUncheckedCreateWithoutMediasInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMediasInput
    connect?: ProductWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type ProductUpdateOneRequiredWithoutMediasNestedInput = {
    create?: XOR<ProductCreateWithoutMediasInput, ProductUncheckedCreateWithoutMediasInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMediasInput
    upsert?: ProductUpsertWithoutMediasInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMediasInput, ProductUpdateWithoutMediasInput>, ProductUncheckedUpdateWithoutMediasInput>
  }

  export type ClientCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    connect?: ClientWhereUniqueInput
  }

  export type OrderProductCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type PaymentTransactionCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput
    connect?: PaymentTransactionWhereUniqueInput
  }

  export type OrderProductUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput
    connect?: PaymentTransactionWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    upsert?: ClientUpsertWithoutOrdersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOrdersInput, ClientUpdateWithoutOrdersInput>, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderProductUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutOrderInput | OrderProductUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutOrderInput | OrderProductUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutOrderInput | OrderProductUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type PaymentTransactionUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput
    upsert?: PaymentTransactionUpsertWithoutOrderInput
    disconnect?: PaymentTransactionWhereInput | boolean
    delete?: PaymentTransactionWhereInput | boolean
    connect?: PaymentTransactionWhereUniqueInput
    update?: XOR<XOR<PaymentTransactionUpdateToOneWithWhereWithoutOrderInput, PaymentTransactionUpdateWithoutOrderInput>, PaymentTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type OrderProductUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput> | OrderProductCreateWithoutOrderInput[] | OrderProductUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderProductCreateOrConnectWithoutOrderInput | OrderProductCreateOrConnectWithoutOrderInput[]
    upsert?: OrderProductUpsertWithWhereUniqueWithoutOrderInput | OrderProductUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderProductCreateManyOrderInputEnvelope
    set?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    disconnect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    delete?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    connect?: OrderProductWhereUniqueInput | OrderProductWhereUniqueInput[]
    update?: OrderProductUpdateWithWhereUniqueWithoutOrderInput | OrderProductUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderProductUpdateManyWithWhereWithoutOrderInput | OrderProductUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutOrderInput
    upsert?: PaymentTransactionUpsertWithoutOrderInput
    disconnect?: PaymentTransactionWhereInput | boolean
    delete?: PaymentTransactionWhereInput | boolean
    connect?: PaymentTransactionWhereUniqueInput
    update?: XOR<XOR<PaymentTransactionUpdateToOneWithWhereWithoutOrderInput, PaymentTransactionUpdateWithoutOrderInput>, PaymentTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutProductsInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput
    connect?: OrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput
    connect?: ProductWhereUniqueInput
  }

  export type OrderUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutProductsInput
    upsert?: OrderUpsertWithoutProductsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutProductsInput, OrderUpdateWithoutProductsInput>, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrdersInput
    upsert?: ProductUpsertWithoutOrdersInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrdersInput, ProductUpdateWithoutOrdersInput>, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ClientCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    connect?: ClientWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type ClientUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReviewsInput
    upsert?: ClientUpsertWithoutReviewsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReviewsInput, ClientUpdateWithoutReviewsInput>, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientCreateNestedOneWithoutChatsInput = {
    create?: XOR<ClientCreateWithoutChatsInput, ClientUncheckedCreateWithoutChatsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutChatsInput
    connect?: ClientWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutChatsInput = {
    create?: XOR<ProductCreateWithoutChatsInput, ProductUncheckedCreateWithoutChatsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutChatsInput
    connect?: ProductWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutChatsInput = {
    create?: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutChatsInput
    connect?: BusinessWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutChatsInput = {
    create?: XOR<WorkerCreateWithoutChatsInput, WorkerUncheckedCreateWithoutChatsInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutChatsInput
    connect?: WorkerWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutChatInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ClientUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<ClientCreateWithoutChatsInput, ClientUncheckedCreateWithoutChatsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutChatsInput
    upsert?: ClientUpsertWithoutChatsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutChatsInput, ClientUpdateWithoutChatsInput>, ClientUncheckedUpdateWithoutChatsInput>
  }

  export type ProductUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<ProductCreateWithoutChatsInput, ProductUncheckedCreateWithoutChatsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutChatsInput
    upsert?: ProductUpsertWithoutChatsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutChatsInput, ProductUpdateWithoutChatsInput>, ProductUncheckedUpdateWithoutChatsInput>
  }

  export type BusinessUpdateOneWithoutChatsNestedInput = {
    create?: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutChatsInput
    upsert?: BusinessUpsertWithoutChatsInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutChatsInput, BusinessUpdateWithoutChatsInput>, BusinessUncheckedUpdateWithoutChatsInput>
  }

  export type WorkerUpdateOneWithoutChatsNestedInput = {
    create?: XOR<WorkerCreateWithoutChatsInput, WorkerUncheckedCreateWithoutChatsInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutChatsInput
    upsert?: WorkerUpsertWithoutChatsInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutChatsInput, WorkerUpdateWithoutChatsInput>, WorkerUncheckedUpdateWithoutChatsInput>
  }

  export type ChatMessageUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatNestedInput = {
    create?: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput> | ChatMessageCreateWithoutChatInput[] | ChatMessageUncheckedCreateWithoutChatInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutChatInput | ChatMessageCreateOrConnectWithoutChatInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutChatInput | ChatMessageUpsertWithWhereUniqueWithoutChatInput[]
    createMany?: ChatMessageCreateManyChatInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutChatInput | ChatMessageUpdateWithWhereUniqueWithoutChatInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutChatInput | ChatMessageUpdateManyWithWhereWithoutChatInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    connect?: ChatWhereUniqueInput
  }

  export type ChatUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatCreateOrConnectWithoutMessagesInput
    upsert?: ChatUpsertWithoutMessagesInput
    connect?: ChatWhereUniqueInput
    update?: XOR<XOR<ChatUpdateToOneWithWhereWithoutMessagesInput, ChatUpdateWithoutMessagesInput>, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type BusinessCreateNestedOneWithoutRepostedItemsInput = {
    create?: XOR<BusinessCreateWithoutRepostedItemsInput, BusinessUncheckedCreateWithoutRepostedItemsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRepostedItemsInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutRepostsInput = {
    create?: XOR<ProductCreateWithoutRepostsInput, ProductUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRepostsInput
    connect?: ProductWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutRepostedItemsNestedInput = {
    create?: XOR<BusinessCreateWithoutRepostedItemsInput, BusinessUncheckedCreateWithoutRepostedItemsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRepostedItemsInput
    upsert?: BusinessUpsertWithoutRepostedItemsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutRepostedItemsInput, BusinessUpdateWithoutRepostedItemsInput>, BusinessUncheckedUpdateWithoutRepostedItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutRepostsNestedInput = {
    create?: XOR<ProductCreateWithoutRepostsInput, ProductUncheckedCreateWithoutRepostsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutRepostsInput
    upsert?: ProductUpsertWithoutRepostsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutRepostsInput, ProductUpdateWithoutRepostsInput>, ProductUncheckedUpdateWithoutRepostsInput>
  }

  export type BusinessCreateNestedOneWithoutReownedItemsInput = {
    create?: XOR<BusinessCreateWithoutReownedItemsInput, BusinessUncheckedCreateWithoutReownedItemsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReownedItemsInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReownsInput = {
    create?: XOR<ProductCreateWithoutReownsInput, ProductUncheckedCreateWithoutReownsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReownsInput
    connect?: ProductWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutReownedItemsNestedInput = {
    create?: XOR<BusinessCreateWithoutReownedItemsInput, BusinessUncheckedCreateWithoutReownedItemsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReownedItemsInput
    upsert?: BusinessUpsertWithoutReownedItemsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutReownedItemsInput, BusinessUpdateWithoutReownedItemsInput>, BusinessUncheckedUpdateWithoutReownedItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutReownsNestedInput = {
    create?: XOR<ProductCreateWithoutReownsInput, ProductUncheckedCreateWithoutReownsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReownsInput
    upsert?: ProductUpsertWithoutReownsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReownsInput, ProductUpdateWithoutReownsInput>, ProductUncheckedUpdateWithoutReownsInput>
  }

  export type BusinessCreateNestedOneWithoutKycInput = {
    create?: XOR<BusinessCreateWithoutKycInput, BusinessUncheckedCreateWithoutKycInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutKycInput
    connect?: BusinessWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutKycInput = {
    create?: XOR<ClientCreateWithoutKycInput, ClientUncheckedCreateWithoutKycInput>
    connectOrCreate?: ClientCreateOrConnectWithoutKycInput
    connect?: ClientWhereUniqueInput
  }

  export type WorkerCreateNestedOneWithoutKycInput = {
    create?: XOR<WorkerCreateWithoutKycInput, WorkerUncheckedCreateWithoutKycInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutKycInput
    connect?: WorkerWhereUniqueInput
  }

  export type EnumKycStatusFieldUpdateOperationsInput = {
    set?: $Enums.KycStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BusinessUpdateOneWithoutKycNestedInput = {
    create?: XOR<BusinessCreateWithoutKycInput, BusinessUncheckedCreateWithoutKycInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutKycInput
    upsert?: BusinessUpsertWithoutKycInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutKycInput, BusinessUpdateWithoutKycInput>, BusinessUncheckedUpdateWithoutKycInput>
  }

  export type ClientUpdateOneWithoutKycNestedInput = {
    create?: XOR<ClientCreateWithoutKycInput, ClientUncheckedCreateWithoutKycInput>
    connectOrCreate?: ClientCreateOrConnectWithoutKycInput
    upsert?: ClientUpsertWithoutKycInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutKycInput, ClientUpdateWithoutKycInput>, ClientUncheckedUpdateWithoutKycInput>
  }

  export type WorkerUpdateOneWithoutKycNestedInput = {
    create?: XOR<WorkerCreateWithoutKycInput, WorkerUncheckedCreateWithoutKycInput>
    connectOrCreate?: WorkerCreateOrConnectWithoutKycInput
    upsert?: WorkerUpsertWithoutKycInput
    disconnect?: WorkerWhereInput | boolean
    delete?: WorkerWhereInput | boolean
    connect?: WorkerWhereUniqueInput
    update?: XOR<XOR<WorkerUpdateToOneWithWhereWithoutKycInput, WorkerUpdateWithoutKycInput>, WorkerUncheckedUpdateWithoutKycInput>
  }

  export type BusinessCreateNestedOneWithoutRechargesInput = {
    create?: XOR<BusinessCreateWithoutRechargesInput, BusinessUncheckedCreateWithoutRechargesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRechargesInput
    connect?: BusinessWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutRechargesInput = {
    create?: XOR<ClientCreateWithoutRechargesInput, ClientUncheckedCreateWithoutRechargesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRechargesInput
    connect?: ClientWhereUniqueInput
  }

  export type EnumRechargeMethodFieldUpdateOperationsInput = {
    set?: $Enums.RechargeMethod
  }

  export type EnumCountryFieldUpdateOperationsInput = {
    set?: $Enums.Country
  }

  export type BusinessUpdateOneWithoutRechargesNestedInput = {
    create?: XOR<BusinessCreateWithoutRechargesInput, BusinessUncheckedCreateWithoutRechargesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutRechargesInput
    upsert?: BusinessUpsertWithoutRechargesInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutRechargesInput, BusinessUpdateWithoutRechargesInput>, BusinessUncheckedUpdateWithoutRechargesInput>
  }

  export type ClientUpdateOneWithoutRechargesNestedInput = {
    create?: XOR<ClientCreateWithoutRechargesInput, ClientUncheckedCreateWithoutRechargesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutRechargesInput
    upsert?: ClientUpsertWithoutRechargesInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutRechargesInput, ClientUpdateWithoutRechargesInput>, ClientUncheckedUpdateWithoutRechargesInput>
  }

  export type OrderCreateNestedOneWithoutPaymentInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    connect?: OrderWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type OrderUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: OrderCreateOrConnectWithoutPaymentInput
    upsert?: OrderUpsertWithoutPaymentInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutPaymentInput, OrderUpdateWithoutPaymentInput>, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type BusinessCreateNestedOneWithoutAdsInput = {
    create?: XOR<BusinessCreateWithoutAdsInput, BusinessUncheckedCreateWithoutAdsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutAdsInput
    connect?: BusinessWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutAdsInput = {
    create?: XOR<ProductCreateWithoutAdsInput, ProductUncheckedCreateWithoutAdsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdsInput
    connect?: ProductWhereUniqueInput
  }

  export type BusinessUpdateOneRequiredWithoutAdsNestedInput = {
    create?: XOR<BusinessCreateWithoutAdsInput, BusinessUncheckedCreateWithoutAdsInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutAdsInput
    upsert?: BusinessUpsertWithoutAdsInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutAdsInput, BusinessUpdateWithoutAdsInput>, BusinessUncheckedUpdateWithoutAdsInput>
  }

  export type ProductUpdateOneRequiredWithoutAdsNestedInput = {
    create?: XOR<ProductCreateWithoutAdsInput, ProductUncheckedCreateWithoutAdsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutAdsInput
    upsert?: ProductUpsertWithoutAdsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutAdsInput, ProductUpdateWithoutAdsInput>, ProductUncheckedUpdateWithoutAdsInput>
  }

  export type BusinessCreateNestedOneWithoutFreelanceServicesInput = {
    create?: XOR<BusinessCreateWithoutFreelanceServicesInput, BusinessUncheckedCreateWithoutFreelanceServicesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutFreelanceServicesInput
    connect?: BusinessWhereUniqueInput
  }

  export type FreelanceOrderCreateNestedManyWithoutServiceInput = {
    create?: XOR<FreelanceOrderCreateWithoutServiceInput, FreelanceOrderUncheckedCreateWithoutServiceInput> | FreelanceOrderCreateWithoutServiceInput[] | FreelanceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutServiceInput | FreelanceOrderCreateOrConnectWithoutServiceInput[]
    createMany?: FreelanceOrderCreateManyServiceInputEnvelope
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
  }

  export type FreelanceOrderUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<FreelanceOrderCreateWithoutServiceInput, FreelanceOrderUncheckedCreateWithoutServiceInput> | FreelanceOrderCreateWithoutServiceInput[] | FreelanceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutServiceInput | FreelanceOrderCreateOrConnectWithoutServiceInput[]
    createMany?: FreelanceOrderCreateManyServiceInputEnvelope
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
  }

  export type BusinessUpdateOneRequiredWithoutFreelanceServicesNestedInput = {
    create?: XOR<BusinessCreateWithoutFreelanceServicesInput, BusinessUncheckedCreateWithoutFreelanceServicesInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutFreelanceServicesInput
    upsert?: BusinessUpsertWithoutFreelanceServicesInput
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutFreelanceServicesInput, BusinessUpdateWithoutFreelanceServicesInput>, BusinessUncheckedUpdateWithoutFreelanceServicesInput>
  }

  export type FreelanceOrderUpdateManyWithoutServiceNestedInput = {
    create?: XOR<FreelanceOrderCreateWithoutServiceInput, FreelanceOrderUncheckedCreateWithoutServiceInput> | FreelanceOrderCreateWithoutServiceInput[] | FreelanceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutServiceInput | FreelanceOrderCreateOrConnectWithoutServiceInput[]
    upsert?: FreelanceOrderUpsertWithWhereUniqueWithoutServiceInput | FreelanceOrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: FreelanceOrderCreateManyServiceInputEnvelope
    set?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    disconnect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    delete?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    update?: FreelanceOrderUpdateWithWhereUniqueWithoutServiceInput | FreelanceOrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: FreelanceOrderUpdateManyWithWhereWithoutServiceInput | FreelanceOrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
  }

  export type FreelanceOrderUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<FreelanceOrderCreateWithoutServiceInput, FreelanceOrderUncheckedCreateWithoutServiceInput> | FreelanceOrderCreateWithoutServiceInput[] | FreelanceOrderUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: FreelanceOrderCreateOrConnectWithoutServiceInput | FreelanceOrderCreateOrConnectWithoutServiceInput[]
    upsert?: FreelanceOrderUpsertWithWhereUniqueWithoutServiceInput | FreelanceOrderUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: FreelanceOrderCreateManyServiceInputEnvelope
    set?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    disconnect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    delete?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    connect?: FreelanceOrderWhereUniqueInput | FreelanceOrderWhereUniqueInput[]
    update?: FreelanceOrderUpdateWithWhereUniqueWithoutServiceInput | FreelanceOrderUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: FreelanceOrderUpdateManyWithWhereWithoutServiceInput | FreelanceOrderUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
  }

  export type ClientCreateNestedOneWithoutFreelanceOrdersInput = {
    create?: XOR<ClientCreateWithoutFreelanceOrdersInput, ClientUncheckedCreateWithoutFreelanceOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFreelanceOrdersInput
    connect?: ClientWhereUniqueInput
  }

  export type FreelanceServiceCreateNestedOneWithoutOrdersInput = {
    create?: XOR<FreelanceServiceCreateWithoutOrdersInput, FreelanceServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: FreelanceServiceCreateOrConnectWithoutOrdersInput
    connect?: FreelanceServiceWhereUniqueInput
  }

  export type BusinessCreateNestedManyWithoutFreelanceOrdersInput = {
    create?: XOR<BusinessCreateWithoutFreelanceOrdersInput, BusinessUncheckedCreateWithoutFreelanceOrdersInput> | BusinessCreateWithoutFreelanceOrdersInput[] | BusinessUncheckedCreateWithoutFreelanceOrdersInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutFreelanceOrdersInput | BusinessCreateOrConnectWithoutFreelanceOrdersInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type BusinessUncheckedCreateNestedManyWithoutFreelanceOrdersInput = {
    create?: XOR<BusinessCreateWithoutFreelanceOrdersInput, BusinessUncheckedCreateWithoutFreelanceOrdersInput> | BusinessCreateWithoutFreelanceOrdersInput[] | BusinessUncheckedCreateWithoutFreelanceOrdersInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutFreelanceOrdersInput | BusinessCreateOrConnectWithoutFreelanceOrdersInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
  }

  export type EnumFreelanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.FreelanceStatus
  }

  export type ClientUpdateOneRequiredWithoutFreelanceOrdersNestedInput = {
    create?: XOR<ClientCreateWithoutFreelanceOrdersInput, ClientUncheckedCreateWithoutFreelanceOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutFreelanceOrdersInput
    upsert?: ClientUpsertWithoutFreelanceOrdersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutFreelanceOrdersInput, ClientUpdateWithoutFreelanceOrdersInput>, ClientUncheckedUpdateWithoutFreelanceOrdersInput>
  }

  export type FreelanceServiceUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<FreelanceServiceCreateWithoutOrdersInput, FreelanceServiceUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: FreelanceServiceCreateOrConnectWithoutOrdersInput
    upsert?: FreelanceServiceUpsertWithoutOrdersInput
    connect?: FreelanceServiceWhereUniqueInput
    update?: XOR<XOR<FreelanceServiceUpdateToOneWithWhereWithoutOrdersInput, FreelanceServiceUpdateWithoutOrdersInput>, FreelanceServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type BusinessUpdateManyWithoutFreelanceOrdersNestedInput = {
    create?: XOR<BusinessCreateWithoutFreelanceOrdersInput, BusinessUncheckedCreateWithoutFreelanceOrdersInput> | BusinessCreateWithoutFreelanceOrdersInput[] | BusinessUncheckedCreateWithoutFreelanceOrdersInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutFreelanceOrdersInput | BusinessCreateOrConnectWithoutFreelanceOrdersInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutFreelanceOrdersInput | BusinessUpsertWithWhereUniqueWithoutFreelanceOrdersInput[]
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutFreelanceOrdersInput | BusinessUpdateWithWhereUniqueWithoutFreelanceOrdersInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutFreelanceOrdersInput | BusinessUpdateManyWithWhereWithoutFreelanceOrdersInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BusinessUncheckedUpdateManyWithoutFreelanceOrdersNestedInput = {
    create?: XOR<BusinessCreateWithoutFreelanceOrdersInput, BusinessUncheckedCreateWithoutFreelanceOrdersInput> | BusinessCreateWithoutFreelanceOrdersInput[] | BusinessUncheckedCreateWithoutFreelanceOrdersInput[]
    connectOrCreate?: BusinessCreateOrConnectWithoutFreelanceOrdersInput | BusinessCreateOrConnectWithoutFreelanceOrdersInput[]
    upsert?: BusinessUpsertWithWhereUniqueWithoutFreelanceOrdersInput | BusinessUpsertWithWhereUniqueWithoutFreelanceOrdersInput[]
    set?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    disconnect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    delete?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    connect?: BusinessWhereUniqueInput | BusinessWhereUniqueInput[]
    update?: BusinessUpdateWithWhereUniqueWithoutFreelanceOrdersInput | BusinessUpdateWithWhereUniqueWithoutFreelanceOrdersInput[]
    updateMany?: BusinessUpdateManyWithWhereWithoutFreelanceOrdersInput | BusinessUpdateManyWithWhereWithoutFreelanceOrdersInput[]
    deleteMany?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
  }

  export type BusinessCreateNestedOneWithoutReferralsMadeInput = {
    create?: XOR<BusinessCreateWithoutReferralsMadeInput, BusinessUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReferralsMadeInput
    connect?: BusinessWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReferralsMadeInput = {
    create?: XOR<ClientCreateWithoutReferralsMadeInput, ClientUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReferralsMadeInput
    connect?: ClientWhereUniqueInput
  }

  export type BusinessCreateNestedOneWithoutReferralsReceivedInput = {
    create?: XOR<BusinessCreateWithoutReferralsReceivedInput, BusinessUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReferralsReceivedInput
    connect?: BusinessWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReferralsReceivedInput = {
    create?: XOR<ClientCreateWithoutReferralsReceivedInput, ClientUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReferralsReceivedInput
    connect?: ClientWhereUniqueInput
  }

  export type BusinessUpdateOneWithoutReferralsMadeNestedInput = {
    create?: XOR<BusinessCreateWithoutReferralsMadeInput, BusinessUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReferralsMadeInput
    upsert?: BusinessUpsertWithoutReferralsMadeInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutReferralsMadeInput, BusinessUpdateWithoutReferralsMadeInput>, BusinessUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type ClientUpdateOneWithoutReferralsMadeNestedInput = {
    create?: XOR<ClientCreateWithoutReferralsMadeInput, ClientUncheckedCreateWithoutReferralsMadeInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReferralsMadeInput
    upsert?: ClientUpsertWithoutReferralsMadeInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReferralsMadeInput, ClientUpdateWithoutReferralsMadeInput>, ClientUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type BusinessUpdateOneWithoutReferralsReceivedNestedInput = {
    create?: XOR<BusinessCreateWithoutReferralsReceivedInput, BusinessUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: BusinessCreateOrConnectWithoutReferralsReceivedInput
    upsert?: BusinessUpsertWithoutReferralsReceivedInput
    disconnect?: BusinessWhereInput | boolean
    delete?: BusinessWhereInput | boolean
    connect?: BusinessWhereUniqueInput
    update?: XOR<XOR<BusinessUpdateToOneWithWhereWithoutReferralsReceivedInput, BusinessUpdateWithoutReferralsReceivedInput>, BusinessUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type ClientUpdateOneWithoutReferralsReceivedNestedInput = {
    create?: XOR<ClientCreateWithoutReferralsReceivedInput, ClientUncheckedCreateWithoutReferralsReceivedInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReferralsReceivedInput
    upsert?: ClientUpsertWithoutReferralsReceivedInput
    disconnect?: ClientWhereInput | boolean
    delete?: ClientWhereInput | boolean
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReferralsReceivedInput, ClientUpdateWithoutReferralsReceivedInput>, ClientUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumKycStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusFilter<$PrismaModel> | $Enums.KycStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumKycStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KycStatus | EnumKycStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KycStatus[] | ListEnumKycStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKycStatusWithAggregatesFilter<$PrismaModel> | $Enums.KycStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKycStatusFilter<$PrismaModel>
    _max?: NestedEnumKycStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumRechargeMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeMethod | EnumRechargeMethodFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumRechargeMethodFilter<$PrismaModel> | $Enums.RechargeMethod
  }

  export type NestedEnumCountryFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryFilter<$PrismaModel> | $Enums.Country
  }

  export type NestedEnumRechargeMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RechargeMethod | EnumRechargeMethodFieldRefInput<$PrismaModel>
    in?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.RechargeMethod[] | ListEnumRechargeMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumRechargeMethodWithAggregatesFilter<$PrismaModel> | $Enums.RechargeMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRechargeMethodFilter<$PrismaModel>
    _max?: NestedEnumRechargeMethodFilter<$PrismaModel>
  }

  export type NestedEnumCountryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Country | EnumCountryFieldRefInput<$PrismaModel>
    in?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Country[] | ListEnumCountryFieldRefInput<$PrismaModel>
    not?: NestedEnumCountryWithAggregatesFilter<$PrismaModel> | $Enums.Country
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCountryFilter<$PrismaModel>
    _max?: NestedEnumCountryFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumFreelanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FreelanceStatus | EnumFreelanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFreelanceStatusFilter<$PrismaModel> | $Enums.FreelanceStatus
  }

  export type NestedEnumFreelanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FreelanceStatus | EnumFreelanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FreelanceStatus[] | ListEnumFreelanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFreelanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.FreelanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFreelanceStatusFilter<$PrismaModel>
    _max?: NestedEnumFreelanceStatusFilter<$PrismaModel>
  }

  export type KYCCreateWithoutBusinessInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    client?: ClientCreateNestedOneWithoutKycInput
    worker?: WorkerCreateNestedOneWithoutKycInput
  }

  export type KYCUncheckedCreateWithoutBusinessInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    clientId?: string | null
    workerId?: string | null
  }

  export type KYCCreateOrConnectWithoutBusinessInput = {
    where: KYCWhereUniqueInput
    create: XOR<KYCCreateWithoutBusinessInput, KYCUncheckedCreateWithoutBusinessInput>
  }

  export type ProductCreateWithoutBusinessInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBusinessInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBusinessInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBusinessInput, ProductUncheckedCreateWithoutBusinessInput>
  }

  export type ProductCreateManyBusinessInputEnvelope = {
    data: ProductCreateManyBusinessInput | ProductCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type WorkerCreateWithoutBusinessInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutWorkerInput
    chats?: ChatCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutBusinessInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutWorkerInput
    chats?: ChatUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutBusinessInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutBusinessInput, WorkerUncheckedCreateWithoutBusinessInput>
  }

  export type WorkerCreateManyBusinessInputEnvelope = {
    data: WorkerCreateManyBusinessInput | WorkerCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type RepostedProductCreateWithoutBusinessInput = {
    id?: string
    earnPercentage?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutRepostsInput
  }

  export type RepostedProductUncheckedCreateWithoutBusinessInput = {
    id?: string
    productId: string
    earnPercentage?: number
    createdAt?: Date | string
  }

  export type RepostedProductCreateOrConnectWithoutBusinessInput = {
    where: RepostedProductWhereUniqueInput
    create: XOR<RepostedProductCreateWithoutBusinessInput, RepostedProductUncheckedCreateWithoutBusinessInput>
  }

  export type RepostedProductCreateManyBusinessInputEnvelope = {
    data: RepostedProductCreateManyBusinessInput | RepostedProductCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ReOwnedProductCreateWithoutBusinessInput = {
    id?: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutReownsInput
  }

  export type ReOwnedProductUncheckedCreateWithoutBusinessInput = {
    id?: string
    productId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
  }

  export type ReOwnedProductCreateOrConnectWithoutBusinessInput = {
    where: ReOwnedProductWhereUniqueInput
    create: XOR<ReOwnedProductCreateWithoutBusinessInput, ReOwnedProductUncheckedCreateWithoutBusinessInput>
  }

  export type ReOwnedProductCreateManyBusinessInputEnvelope = {
    data: ReOwnedProductCreateManyBusinessInput | ReOwnedProductCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type AccountRechargeCreateWithoutBusinessInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    createdAt?: Date | string
    client?: ClientCreateNestedOneWithoutRechargesInput
  }

  export type AccountRechargeUncheckedCreateWithoutBusinessInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    clientId?: string | null
    createdAt?: Date | string
  }

  export type AccountRechargeCreateOrConnectWithoutBusinessInput = {
    where: AccountRechargeWhereUniqueInput
    create: XOR<AccountRechargeCreateWithoutBusinessInput, AccountRechargeUncheckedCreateWithoutBusinessInput>
  }

  export type AccountRechargeCreateManyBusinessInputEnvelope = {
    data: AccountRechargeCreateManyBusinessInput | AccountRechargeCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type AdCreateWithoutBusinessInput = {
    id?: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
    product: ProductCreateNestedOneWithoutAdsInput
  }

  export type AdUncheckedCreateWithoutBusinessInput = {
    id?: string
    productId: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type AdCreateOrConnectWithoutBusinessInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutBusinessInput, AdUncheckedCreateWithoutBusinessInput>
  }

  export type AdCreateManyBusinessInputEnvelope = {
    data: AdCreateManyBusinessInput | AdCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceServiceCreateWithoutBusinessInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: FreelanceOrderCreateNestedManyWithoutServiceInput
  }

  export type FreelanceServiceUncheckedCreateWithoutBusinessInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: FreelanceOrderUncheckedCreateNestedManyWithoutServiceInput
  }

  export type FreelanceServiceCreateOrConnectWithoutBusinessInput = {
    where: FreelanceServiceWhereUniqueInput
    create: XOR<FreelanceServiceCreateWithoutBusinessInput, FreelanceServiceUncheckedCreateWithoutBusinessInput>
  }

  export type FreelanceServiceCreateManyBusinessInputEnvelope = {
    data: FreelanceServiceCreateManyBusinessInput | FreelanceServiceCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceOrderCreateWithoutBusinessesInput = {
    id?: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutFreelanceOrdersInput
    service: FreelanceServiceCreateNestedOneWithoutOrdersInput
  }

  export type FreelanceOrderUncheckedCreateWithoutBusinessesInput = {
    id?: string
    clientId: string
    serviceId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceOrderCreateOrConnectWithoutBusinessesInput = {
    where: FreelanceOrderWhereUniqueInput
    create: XOR<FreelanceOrderCreateWithoutBusinessesInput, FreelanceOrderUncheckedCreateWithoutBusinessesInput>
  }

  export type ReferralCreateWithoutAffiliateBusinessInput = {
    id?: string
    verifiedPurchase?: boolean
    createdAt?: Date | string
    affiliateClient?: ClientCreateNestedOneWithoutReferralsMadeInput
    referredBusiness?: BusinessCreateNestedOneWithoutReferralsReceivedInput
    referredClient?: ClientCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateWithoutAffiliateBusinessInput = {
    id?: string
    affiliateClientId?: string | null
    referredBusinessId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutAffiliateBusinessInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutAffiliateBusinessInput, ReferralUncheckedCreateWithoutAffiliateBusinessInput>
  }

  export type ReferralCreateManyAffiliateBusinessInputEnvelope = {
    data: ReferralCreateManyAffiliateBusinessInput | ReferralCreateManyAffiliateBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredBusinessInput = {
    id?: string
    verifiedPurchase?: boolean
    createdAt?: Date | string
    affiliateBusiness?: BusinessCreateNestedOneWithoutReferralsMadeInput
    affiliateClient?: ClientCreateNestedOneWithoutReferralsMadeInput
    referredClient?: ClientCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateWithoutReferredBusinessInput = {
    id?: string
    affiliateBusinessId?: string | null
    affiliateClientId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferredBusinessInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredBusinessInput, ReferralUncheckedCreateWithoutReferredBusinessInput>
  }

  export type ReferralCreateManyReferredBusinessInputEnvelope = {
    data: ReferralCreateManyReferredBusinessInput | ReferralCreateManyReferredBusinessInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutBusinessInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutChatsInput
    product: ProductCreateNestedOneWithoutChatsInput
    worker?: WorkerCreateNestedOneWithoutChatsInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutBusinessInput = {
    id?: string
    clientId: string
    productId: string
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutBusinessInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput>
  }

  export type ChatCreateManyBusinessInputEnvelope = {
    data: ChatCreateManyBusinessInput | ChatCreateManyBusinessInput[]
    skipDuplicates?: boolean
  }

  export type KYCUpsertWithoutBusinessInput = {
    update: XOR<KYCUpdateWithoutBusinessInput, KYCUncheckedUpdateWithoutBusinessInput>
    create: XOR<KYCCreateWithoutBusinessInput, KYCUncheckedCreateWithoutBusinessInput>
    where?: KYCWhereInput
  }

  export type KYCUpdateToOneWithWhereWithoutBusinessInput = {
    where?: KYCWhereInput
    data: XOR<KYCUpdateWithoutBusinessInput, KYCUncheckedUpdateWithoutBusinessInput>
  }

  export type KYCUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientUpdateOneWithoutKycNestedInput
    worker?: WorkerUpdateOneWithoutKycNestedInput
  }

  export type KYCUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBusinessInput, ProductUncheckedUpdateWithoutBusinessInput>
    create: XOR<ProductCreateWithoutBusinessInput, ProductUncheckedCreateWithoutBusinessInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBusinessInput, ProductUncheckedUpdateWithoutBusinessInput>
  }

  export type ProductUpdateManyWithWhereWithoutBusinessInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    title?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    businessId?: StringFilter<"Product"> | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type WorkerUpsertWithWhereUniqueWithoutBusinessInput = {
    where: WorkerWhereUniqueInput
    update: XOR<WorkerUpdateWithoutBusinessInput, WorkerUncheckedUpdateWithoutBusinessInput>
    create: XOR<WorkerCreateWithoutBusinessInput, WorkerUncheckedCreateWithoutBusinessInput>
  }

  export type WorkerUpdateWithWhereUniqueWithoutBusinessInput = {
    where: WorkerWhereUniqueInput
    data: XOR<WorkerUpdateWithoutBusinessInput, WorkerUncheckedUpdateWithoutBusinessInput>
  }

  export type WorkerUpdateManyWithWhereWithoutBusinessInput = {
    where: WorkerScalarWhereInput
    data: XOR<WorkerUpdateManyMutationInput, WorkerUncheckedUpdateManyWithoutBusinessInput>
  }

  export type WorkerScalarWhereInput = {
    AND?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    OR?: WorkerScalarWhereInput[]
    NOT?: WorkerScalarWhereInput | WorkerScalarWhereInput[]
    id?: StringFilter<"Worker"> | string
    email?: StringFilter<"Worker"> | string
    fullName?: StringNullableFilter<"Worker"> | string | null
    role?: StringNullableFilter<"Worker"> | string | null
    phone?: StringNullableFilter<"Worker"> | string | null
    businessId?: StringFilter<"Worker"> | string
    createdAt?: DateTimeFilter<"Worker"> | Date | string
    updatedAt?: DateTimeFilter<"Worker"> | Date | string
  }

  export type RepostedProductUpsertWithWhereUniqueWithoutBusinessInput = {
    where: RepostedProductWhereUniqueInput
    update: XOR<RepostedProductUpdateWithoutBusinessInput, RepostedProductUncheckedUpdateWithoutBusinessInput>
    create: XOR<RepostedProductCreateWithoutBusinessInput, RepostedProductUncheckedCreateWithoutBusinessInput>
  }

  export type RepostedProductUpdateWithWhereUniqueWithoutBusinessInput = {
    where: RepostedProductWhereUniqueInput
    data: XOR<RepostedProductUpdateWithoutBusinessInput, RepostedProductUncheckedUpdateWithoutBusinessInput>
  }

  export type RepostedProductUpdateManyWithWhereWithoutBusinessInput = {
    where: RepostedProductScalarWhereInput
    data: XOR<RepostedProductUpdateManyMutationInput, RepostedProductUncheckedUpdateManyWithoutBusinessInput>
  }

  export type RepostedProductScalarWhereInput = {
    AND?: RepostedProductScalarWhereInput | RepostedProductScalarWhereInput[]
    OR?: RepostedProductScalarWhereInput[]
    NOT?: RepostedProductScalarWhereInput | RepostedProductScalarWhereInput[]
    id?: StringFilter<"RepostedProduct"> | string
    businessId?: StringFilter<"RepostedProduct"> | string
    productId?: StringFilter<"RepostedProduct"> | string
    earnPercentage?: FloatFilter<"RepostedProduct"> | number
    createdAt?: DateTimeFilter<"RepostedProduct"> | Date | string
  }

  export type ReOwnedProductUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ReOwnedProductWhereUniqueInput
    update: XOR<ReOwnedProductUpdateWithoutBusinessInput, ReOwnedProductUncheckedUpdateWithoutBusinessInput>
    create: XOR<ReOwnedProductCreateWithoutBusinessInput, ReOwnedProductUncheckedCreateWithoutBusinessInput>
  }

  export type ReOwnedProductUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ReOwnedProductWhereUniqueInput
    data: XOR<ReOwnedProductUpdateWithoutBusinessInput, ReOwnedProductUncheckedUpdateWithoutBusinessInput>
  }

  export type ReOwnedProductUpdateManyWithWhereWithoutBusinessInput = {
    where: ReOwnedProductScalarWhereInput
    data: XOR<ReOwnedProductUpdateManyMutationInput, ReOwnedProductUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ReOwnedProductScalarWhereInput = {
    AND?: ReOwnedProductScalarWhereInput | ReOwnedProductScalarWhereInput[]
    OR?: ReOwnedProductScalarWhereInput[]
    NOT?: ReOwnedProductScalarWhereInput | ReOwnedProductScalarWhereInput[]
    id?: StringFilter<"ReOwnedProduct"> | string
    businessId?: StringFilter<"ReOwnedProduct"> | string
    productId?: StringFilter<"ReOwnedProduct"> | string
    oldOwnerId?: StringFilter<"ReOwnedProduct"> | string
    oldPrice?: FloatFilter<"ReOwnedProduct"> | number
    newPrice?: FloatFilter<"ReOwnedProduct"> | number
    markupPercentage?: FloatFilter<"ReOwnedProduct"> | number
    agreedViaChatId?: StringFilter<"ReOwnedProduct"> | string
    createdAt?: DateTimeFilter<"ReOwnedProduct"> | Date | string
  }

  export type AccountRechargeUpsertWithWhereUniqueWithoutBusinessInput = {
    where: AccountRechargeWhereUniqueInput
    update: XOR<AccountRechargeUpdateWithoutBusinessInput, AccountRechargeUncheckedUpdateWithoutBusinessInput>
    create: XOR<AccountRechargeCreateWithoutBusinessInput, AccountRechargeUncheckedCreateWithoutBusinessInput>
  }

  export type AccountRechargeUpdateWithWhereUniqueWithoutBusinessInput = {
    where: AccountRechargeWhereUniqueInput
    data: XOR<AccountRechargeUpdateWithoutBusinessInput, AccountRechargeUncheckedUpdateWithoutBusinessInput>
  }

  export type AccountRechargeUpdateManyWithWhereWithoutBusinessInput = {
    where: AccountRechargeScalarWhereInput
    data: XOR<AccountRechargeUpdateManyMutationInput, AccountRechargeUncheckedUpdateManyWithoutBusinessInput>
  }

  export type AccountRechargeScalarWhereInput = {
    AND?: AccountRechargeScalarWhereInput | AccountRechargeScalarWhereInput[]
    OR?: AccountRechargeScalarWhereInput[]
    NOT?: AccountRechargeScalarWhereInput | AccountRechargeScalarWhereInput[]
    id?: StringFilter<"AccountRecharge"> | string
    amount?: FloatFilter<"AccountRecharge"> | number
    method?: EnumRechargeMethodFilter<"AccountRecharge"> | $Enums.RechargeMethod
    origin?: EnumCountryFilter<"AccountRecharge"> | $Enums.Country
    businessId?: StringNullableFilter<"AccountRecharge"> | string | null
    clientId?: StringNullableFilter<"AccountRecharge"> | string | null
    createdAt?: DateTimeFilter<"AccountRecharge"> | Date | string
  }

  export type AdUpsertWithWhereUniqueWithoutBusinessInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutBusinessInput, AdUncheckedUpdateWithoutBusinessInput>
    create: XOR<AdCreateWithoutBusinessInput, AdUncheckedCreateWithoutBusinessInput>
  }

  export type AdUpdateWithWhereUniqueWithoutBusinessInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutBusinessInput, AdUncheckedUpdateWithoutBusinessInput>
  }

  export type AdUpdateManyWithWhereWithoutBusinessInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutBusinessInput>
  }

  export type AdScalarWhereInput = {
    AND?: AdScalarWhereInput | AdScalarWhereInput[]
    OR?: AdScalarWhereInput[]
    NOT?: AdScalarWhereInput | AdScalarWhereInput[]
    id?: StringFilter<"Ad"> | string
    businessId?: StringFilter<"Ad"> | string
    productId?: StringFilter<"Ad"> | string
    price?: FloatFilter<"Ad"> | number
    periodDays?: IntFilter<"Ad"> | number
    createdAt?: DateTimeFilter<"Ad"> | Date | string
    endedAt?: DateTimeNullableFilter<"Ad"> | Date | string | null
  }

  export type FreelanceServiceUpsertWithWhereUniqueWithoutBusinessInput = {
    where: FreelanceServiceWhereUniqueInput
    update: XOR<FreelanceServiceUpdateWithoutBusinessInput, FreelanceServiceUncheckedUpdateWithoutBusinessInput>
    create: XOR<FreelanceServiceCreateWithoutBusinessInput, FreelanceServiceUncheckedCreateWithoutBusinessInput>
  }

  export type FreelanceServiceUpdateWithWhereUniqueWithoutBusinessInput = {
    where: FreelanceServiceWhereUniqueInput
    data: XOR<FreelanceServiceUpdateWithoutBusinessInput, FreelanceServiceUncheckedUpdateWithoutBusinessInput>
  }

  export type FreelanceServiceUpdateManyWithWhereWithoutBusinessInput = {
    where: FreelanceServiceScalarWhereInput
    data: XOR<FreelanceServiceUpdateManyMutationInput, FreelanceServiceUncheckedUpdateManyWithoutBusinessInput>
  }

  export type FreelanceServiceScalarWhereInput = {
    AND?: FreelanceServiceScalarWhereInput | FreelanceServiceScalarWhereInput[]
    OR?: FreelanceServiceScalarWhereInput[]
    NOT?: FreelanceServiceScalarWhereInput | FreelanceServiceScalarWhereInput[]
    id?: StringFilter<"FreelanceService"> | string
    title?: StringFilter<"FreelanceService"> | string
    description?: StringNullableFilter<"FreelanceService"> | string | null
    isHourly?: BoolFilter<"FreelanceService"> | boolean
    rate?: FloatFilter<"FreelanceService"> | number
    businessId?: StringFilter<"FreelanceService"> | string
    createdAt?: DateTimeFilter<"FreelanceService"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceService"> | Date | string
  }

  export type FreelanceOrderUpsertWithWhereUniqueWithoutBusinessesInput = {
    where: FreelanceOrderWhereUniqueInput
    update: XOR<FreelanceOrderUpdateWithoutBusinessesInput, FreelanceOrderUncheckedUpdateWithoutBusinessesInput>
    create: XOR<FreelanceOrderCreateWithoutBusinessesInput, FreelanceOrderUncheckedCreateWithoutBusinessesInput>
  }

  export type FreelanceOrderUpdateWithWhereUniqueWithoutBusinessesInput = {
    where: FreelanceOrderWhereUniqueInput
    data: XOR<FreelanceOrderUpdateWithoutBusinessesInput, FreelanceOrderUncheckedUpdateWithoutBusinessesInput>
  }

  export type FreelanceOrderUpdateManyWithWhereWithoutBusinessesInput = {
    where: FreelanceOrderScalarWhereInput
    data: XOR<FreelanceOrderUpdateManyMutationInput, FreelanceOrderUncheckedUpdateManyWithoutBusinessesInput>
  }

  export type FreelanceOrderScalarWhereInput = {
    AND?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
    OR?: FreelanceOrderScalarWhereInput[]
    NOT?: FreelanceOrderScalarWhereInput | FreelanceOrderScalarWhereInput[]
    id?: StringFilter<"FreelanceOrder"> | string
    clientId?: StringFilter<"FreelanceOrder"> | string
    serviceId?: StringFilter<"FreelanceOrder"> | string
    status?: EnumFreelanceStatusFilter<"FreelanceOrder"> | $Enums.FreelanceStatus
    quantity?: IntFilter<"FreelanceOrder"> | number
    totalAmount?: FloatFilter<"FreelanceOrder"> | number
    escrowAmount?: FloatFilter<"FreelanceOrder"> | number
    commissionPercent?: FloatFilter<"FreelanceOrder"> | number
    createdAt?: DateTimeFilter<"FreelanceOrder"> | Date | string
    updatedAt?: DateTimeFilter<"FreelanceOrder"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutAffiliateBusinessInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutAffiliateBusinessInput, ReferralUncheckedUpdateWithoutAffiliateBusinessInput>
    create: XOR<ReferralCreateWithoutAffiliateBusinessInput, ReferralUncheckedCreateWithoutAffiliateBusinessInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutAffiliateBusinessInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutAffiliateBusinessInput, ReferralUncheckedUpdateWithoutAffiliateBusinessInput>
  }

  export type ReferralUpdateManyWithWhereWithoutAffiliateBusinessInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutAffiliateBusinessInput>
  }

  export type ReferralScalarWhereInput = {
    AND?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    OR?: ReferralScalarWhereInput[]
    NOT?: ReferralScalarWhereInput | ReferralScalarWhereInput[]
    id?: StringFilter<"Referral"> | string
    affiliateBusinessId?: StringNullableFilter<"Referral"> | string | null
    affiliateClientId?: StringNullableFilter<"Referral"> | string | null
    referredBusinessId?: StringNullableFilter<"Referral"> | string | null
    referredClientId?: StringNullableFilter<"Referral"> | string | null
    verifiedPurchase?: BoolFilter<"Referral"> | boolean
    createdAt?: DateTimeFilter<"Referral"> | Date | string
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferredBusinessInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferredBusinessInput, ReferralUncheckedUpdateWithoutReferredBusinessInput>
    create: XOR<ReferralCreateWithoutReferredBusinessInput, ReferralUncheckedCreateWithoutReferredBusinessInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferredBusinessInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferredBusinessInput, ReferralUncheckedUpdateWithoutReferredBusinessInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferredBusinessInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferredBusinessInput>
  }

  export type ChatUpsertWithWhereUniqueWithoutBusinessInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutBusinessInput, ChatUncheckedUpdateWithoutBusinessInput>
    create: XOR<ChatCreateWithoutBusinessInput, ChatUncheckedCreateWithoutBusinessInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutBusinessInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutBusinessInput, ChatUncheckedUpdateWithoutBusinessInput>
  }

  export type ChatUpdateManyWithWhereWithoutBusinessInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutBusinessInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    clientId?: StringFilter<"Chat"> | string
    productId?: StringFilter<"Chat"> | string
    businessId?: StringNullableFilter<"Chat"> | string | null
    workerId?: StringNullableFilter<"Chat"> | string | null
    status?: StringFilter<"Chat"> | string
    createdAt?: DateTimeFilter<"Chat"> | Date | string
    updatedAt?: DateTimeFilter<"Chat"> | Date | string
  }

  export type KYCCreateWithoutClientInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    business?: BusinessCreateNestedOneWithoutKycInput
    worker?: WorkerCreateNestedOneWithoutKycInput
  }

  export type KYCUncheckedCreateWithoutClientInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    businessId?: string | null
    workerId?: string | null
  }

  export type KYCCreateOrConnectWithoutClientInput = {
    where: KYCWhereUniqueInput
    create: XOR<KYCCreateWithoutClientInput, KYCUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateWithoutClientInput = {
    id?: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: OrderProductCreateNestedManyWithoutOrderInput
    payment?: PaymentTransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutClientInput = {
    id?: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
    payment?: PaymentTransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutClientInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateManyClientInputEnvelope = {
    data: OrderCreateManyClientInput | OrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutClientInput = {
    id?: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutClientInput = {
    id?: string
    productId: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutClientInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewCreateManyClientInputEnvelope = {
    data: ReviewCreateManyClientInput | ReviewCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutClientInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutChatsInput
    business?: BusinessCreateNestedOneWithoutChatsInput
    worker?: WorkerCreateNestedOneWithoutChatsInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutClientInput = {
    id?: string
    productId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutClientInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutClientInput, ChatUncheckedCreateWithoutClientInput>
  }

  export type ChatCreateManyClientInputEnvelope = {
    data: ChatCreateManyClientInput | ChatCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type AccountRechargeCreateWithoutClientInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    createdAt?: Date | string
    business?: BusinessCreateNestedOneWithoutRechargesInput
  }

  export type AccountRechargeUncheckedCreateWithoutClientInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    businessId?: string | null
    createdAt?: Date | string
  }

  export type AccountRechargeCreateOrConnectWithoutClientInput = {
    where: AccountRechargeWhereUniqueInput
    create: XOR<AccountRechargeCreateWithoutClientInput, AccountRechargeUncheckedCreateWithoutClientInput>
  }

  export type AccountRechargeCreateManyClientInputEnvelope = {
    data: AccountRechargeCreateManyClientInput | AccountRechargeCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type FreelanceOrderCreateWithoutClientInput = {
    id?: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    service: FreelanceServiceCreateNestedOneWithoutOrdersInput
    businesses?: BusinessCreateNestedManyWithoutFreelanceOrdersInput
  }

  export type FreelanceOrderUncheckedCreateWithoutClientInput = {
    id?: string
    serviceId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessUncheckedCreateNestedManyWithoutFreelanceOrdersInput
  }

  export type FreelanceOrderCreateOrConnectWithoutClientInput = {
    where: FreelanceOrderWhereUniqueInput
    create: XOR<FreelanceOrderCreateWithoutClientInput, FreelanceOrderUncheckedCreateWithoutClientInput>
  }

  export type FreelanceOrderCreateManyClientInputEnvelope = {
    data: FreelanceOrderCreateManyClientInput | FreelanceOrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutAffiliateClientInput = {
    id?: string
    verifiedPurchase?: boolean
    createdAt?: Date | string
    affiliateBusiness?: BusinessCreateNestedOneWithoutReferralsMadeInput
    referredBusiness?: BusinessCreateNestedOneWithoutReferralsReceivedInput
    referredClient?: ClientCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateWithoutAffiliateClientInput = {
    id?: string
    affiliateBusinessId?: string | null
    referredBusinessId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutAffiliateClientInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutAffiliateClientInput, ReferralUncheckedCreateWithoutAffiliateClientInput>
  }

  export type ReferralCreateManyAffiliateClientInputEnvelope = {
    data: ReferralCreateManyAffiliateClientInput | ReferralCreateManyAffiliateClientInput[]
    skipDuplicates?: boolean
  }

  export type ReferralCreateWithoutReferredClientInput = {
    id?: string
    verifiedPurchase?: boolean
    createdAt?: Date | string
    affiliateBusiness?: BusinessCreateNestedOneWithoutReferralsMadeInput
    affiliateClient?: ClientCreateNestedOneWithoutReferralsMadeInput
    referredBusiness?: BusinessCreateNestedOneWithoutReferralsReceivedInput
  }

  export type ReferralUncheckedCreateWithoutReferredClientInput = {
    id?: string
    affiliateBusinessId?: string | null
    affiliateClientId?: string | null
    referredBusinessId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateOrConnectWithoutReferredClientInput = {
    where: ReferralWhereUniqueInput
    create: XOR<ReferralCreateWithoutReferredClientInput, ReferralUncheckedCreateWithoutReferredClientInput>
  }

  export type ReferralCreateManyReferredClientInputEnvelope = {
    data: ReferralCreateManyReferredClientInput | ReferralCreateManyReferredClientInput[]
    skipDuplicates?: boolean
  }

  export type KYCUpsertWithoutClientInput = {
    update: XOR<KYCUpdateWithoutClientInput, KYCUncheckedUpdateWithoutClientInput>
    create: XOR<KYCCreateWithoutClientInput, KYCUncheckedCreateWithoutClientInput>
    where?: KYCWhereInput
  }

  export type KYCUpdateToOneWithWhereWithoutClientInput = {
    where?: KYCWhereInput
    data: XOR<KYCUpdateWithoutClientInput, KYCUncheckedUpdateWithoutClientInput>
  }

  export type KYCUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneWithoutKycNestedInput
    worker?: WorkerUpdateOneWithoutKycNestedInput
  }

  export type KYCUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUpsertWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithWhereWithoutClientInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutClientInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    deliveryFee?: FloatFilter<"Order"> | number
    deliveryAddress?: StringNullableFilter<"Order"> | string | null
    qrCode?: StringNullableFilter<"Order"> | string | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
    create: XOR<ReviewCreateWithoutClientInput, ReviewUncheckedCreateWithoutClientInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutClientInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutClientInput, ReviewUncheckedUpdateWithoutClientInput>
  }

  export type ReviewUpdateManyWithWhereWithoutClientInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutClientInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    clientId?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ChatUpsertWithWhereUniqueWithoutClientInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutClientInput, ChatUncheckedUpdateWithoutClientInput>
    create: XOR<ChatCreateWithoutClientInput, ChatUncheckedCreateWithoutClientInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutClientInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutClientInput, ChatUncheckedUpdateWithoutClientInput>
  }

  export type ChatUpdateManyWithWhereWithoutClientInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutClientInput>
  }

  export type AccountRechargeUpsertWithWhereUniqueWithoutClientInput = {
    where: AccountRechargeWhereUniqueInput
    update: XOR<AccountRechargeUpdateWithoutClientInput, AccountRechargeUncheckedUpdateWithoutClientInput>
    create: XOR<AccountRechargeCreateWithoutClientInput, AccountRechargeUncheckedCreateWithoutClientInput>
  }

  export type AccountRechargeUpdateWithWhereUniqueWithoutClientInput = {
    where: AccountRechargeWhereUniqueInput
    data: XOR<AccountRechargeUpdateWithoutClientInput, AccountRechargeUncheckedUpdateWithoutClientInput>
  }

  export type AccountRechargeUpdateManyWithWhereWithoutClientInput = {
    where: AccountRechargeScalarWhereInput
    data: XOR<AccountRechargeUpdateManyMutationInput, AccountRechargeUncheckedUpdateManyWithoutClientInput>
  }

  export type FreelanceOrderUpsertWithWhereUniqueWithoutClientInput = {
    where: FreelanceOrderWhereUniqueInput
    update: XOR<FreelanceOrderUpdateWithoutClientInput, FreelanceOrderUncheckedUpdateWithoutClientInput>
    create: XOR<FreelanceOrderCreateWithoutClientInput, FreelanceOrderUncheckedCreateWithoutClientInput>
  }

  export type FreelanceOrderUpdateWithWhereUniqueWithoutClientInput = {
    where: FreelanceOrderWhereUniqueInput
    data: XOR<FreelanceOrderUpdateWithoutClientInput, FreelanceOrderUncheckedUpdateWithoutClientInput>
  }

  export type FreelanceOrderUpdateManyWithWhereWithoutClientInput = {
    where: FreelanceOrderScalarWhereInput
    data: XOR<FreelanceOrderUpdateManyMutationInput, FreelanceOrderUncheckedUpdateManyWithoutClientInput>
  }

  export type ReferralUpsertWithWhereUniqueWithoutAffiliateClientInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutAffiliateClientInput, ReferralUncheckedUpdateWithoutAffiliateClientInput>
    create: XOR<ReferralCreateWithoutAffiliateClientInput, ReferralUncheckedCreateWithoutAffiliateClientInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutAffiliateClientInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutAffiliateClientInput, ReferralUncheckedUpdateWithoutAffiliateClientInput>
  }

  export type ReferralUpdateManyWithWhereWithoutAffiliateClientInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutAffiliateClientInput>
  }

  export type ReferralUpsertWithWhereUniqueWithoutReferredClientInput = {
    where: ReferralWhereUniqueInput
    update: XOR<ReferralUpdateWithoutReferredClientInput, ReferralUncheckedUpdateWithoutReferredClientInput>
    create: XOR<ReferralCreateWithoutReferredClientInput, ReferralUncheckedCreateWithoutReferredClientInput>
  }

  export type ReferralUpdateWithWhereUniqueWithoutReferredClientInput = {
    where: ReferralWhereUniqueInput
    data: XOR<ReferralUpdateWithoutReferredClientInput, ReferralUncheckedUpdateWithoutReferredClientInput>
  }

  export type ReferralUpdateManyWithWhereWithoutReferredClientInput = {
    where: ReferralScalarWhereInput
    data: XOR<ReferralUpdateManyMutationInput, ReferralUncheckedUpdateManyWithoutReferredClientInput>
  }

  export type BusinessCreateWithoutWorkersInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutWorkersInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutWorkersInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutWorkersInput, BusinessUncheckedCreateWithoutWorkersInput>
  }

  export type KYCCreateWithoutWorkerInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    business?: BusinessCreateNestedOneWithoutKycInput
    client?: ClientCreateNestedOneWithoutKycInput
  }

  export type KYCUncheckedCreateWithoutWorkerInput = {
    id?: string
    status?: $Enums.KycStatus
    documentUrl: string
    submittedAt?: Date | string
    verifiedAt?: Date | string | null
    businessId?: string | null
    clientId?: string | null
  }

  export type KYCCreateOrConnectWithoutWorkerInput = {
    where: KYCWhereUniqueInput
    create: XOR<KYCCreateWithoutWorkerInput, KYCUncheckedCreateWithoutWorkerInput>
  }

  export type ChatCreateWithoutWorkerInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutChatsInput
    product: ProductCreateNestedOneWithoutChatsInput
    business?: BusinessCreateNestedOneWithoutChatsInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutWorkerInput = {
    id?: string
    clientId: string
    productId: string
    businessId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutWorkerInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutWorkerInput, ChatUncheckedCreateWithoutWorkerInput>
  }

  export type ChatCreateManyWorkerInputEnvelope = {
    data: ChatCreateManyWorkerInput | ChatCreateManyWorkerInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutWorkersInput = {
    update: XOR<BusinessUpdateWithoutWorkersInput, BusinessUncheckedUpdateWithoutWorkersInput>
    create: XOR<BusinessCreateWithoutWorkersInput, BusinessUncheckedCreateWithoutWorkersInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutWorkersInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutWorkersInput, BusinessUncheckedUpdateWithoutWorkersInput>
  }

  export type BusinessUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutWorkersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type KYCUpsertWithoutWorkerInput = {
    update: XOR<KYCUpdateWithoutWorkerInput, KYCUncheckedUpdateWithoutWorkerInput>
    create: XOR<KYCCreateWithoutWorkerInput, KYCUncheckedCreateWithoutWorkerInput>
    where?: KYCWhereInput
  }

  export type KYCUpdateToOneWithWhereWithoutWorkerInput = {
    where?: KYCWhereInput
    data: XOR<KYCUpdateWithoutWorkerInput, KYCUncheckedUpdateWithoutWorkerInput>
  }

  export type KYCUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneWithoutKycNestedInput
    client?: ClientUpdateOneWithoutKycNestedInput
  }

  export type KYCUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumKycStatusFieldUpdateOperationsInput | $Enums.KycStatus
    documentUrl?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatUpsertWithWhereUniqueWithoutWorkerInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutWorkerInput, ChatUncheckedUpdateWithoutWorkerInput>
    create: XOR<ChatCreateWithoutWorkerInput, ChatUncheckedCreateWithoutWorkerInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutWorkerInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutWorkerInput, ChatUncheckedUpdateWithoutWorkerInput>
  }

  export type ChatUpdateManyWithWhereWithoutWorkerInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutWorkerInput>
  }

  export type BusinessCreateWithoutProductsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutProductsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
  }

  export type MediaCreateWithoutProductInput = {
    id?: string
    url: string
    type: $Enums.MediaType
    createdAt?: Date | string
  }

  export type MediaUncheckedCreateWithoutProductInput = {
    id?: string
    url: string
    type: $Enums.MediaType
    createdAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutProductInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput>
  }

  export type MediaCreateManyProductInputEnvelope = {
    data: MediaCreateManyProductInput | MediaCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
    client: ClientCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    clientId: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type OrderProductCreateWithoutProductInput = {
    id?: string
    quantity?: number
    order: OrderCreateNestedOneWithoutProductsInput
  }

  export type OrderProductUncheckedCreateWithoutProductInput = {
    id?: string
    orderId: string
    quantity?: number
  }

  export type OrderProductCreateOrConnectWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput>
  }

  export type OrderProductCreateManyProductInputEnvelope = {
    data: OrderProductCreateManyProductInput | OrderProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ChatCreateWithoutProductInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutChatsInput
    business?: BusinessCreateNestedOneWithoutChatsInput
    worker?: WorkerCreateNestedOneWithoutChatsInput
    messages?: ChatMessageCreateNestedManyWithoutChatInput
  }

  export type ChatUncheckedCreateWithoutProductInput = {
    id?: string
    clientId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutChatInput
  }

  export type ChatCreateOrConnectWithoutProductInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutProductInput, ChatUncheckedCreateWithoutProductInput>
  }

  export type ChatCreateManyProductInputEnvelope = {
    data: ChatCreateManyProductInput | ChatCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type RepostedProductCreateWithoutProductInput = {
    id?: string
    earnPercentage?: number
    createdAt?: Date | string
    business: BusinessCreateNestedOneWithoutRepostedItemsInput
  }

  export type RepostedProductUncheckedCreateWithoutProductInput = {
    id?: string
    businessId: string
    earnPercentage?: number
    createdAt?: Date | string
  }

  export type RepostedProductCreateOrConnectWithoutProductInput = {
    where: RepostedProductWhereUniqueInput
    create: XOR<RepostedProductCreateWithoutProductInput, RepostedProductUncheckedCreateWithoutProductInput>
  }

  export type RepostedProductCreateManyProductInputEnvelope = {
    data: RepostedProductCreateManyProductInput | RepostedProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReOwnedProductCreateWithoutProductInput = {
    id?: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
    business: BusinessCreateNestedOneWithoutReownedItemsInput
  }

  export type ReOwnedProductUncheckedCreateWithoutProductInput = {
    id?: string
    businessId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
  }

  export type ReOwnedProductCreateOrConnectWithoutProductInput = {
    where: ReOwnedProductWhereUniqueInput
    create: XOR<ReOwnedProductCreateWithoutProductInput, ReOwnedProductUncheckedCreateWithoutProductInput>
  }

  export type ReOwnedProductCreateManyProductInputEnvelope = {
    data: ReOwnedProductCreateManyProductInput | ReOwnedProductCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type AdCreateWithoutProductInput = {
    id?: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
    business: BusinessCreateNestedOneWithoutAdsInput
  }

  export type AdUncheckedCreateWithoutProductInput = {
    id?: string
    businessId: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type AdCreateOrConnectWithoutProductInput = {
    where: AdWhereUniqueInput
    create: XOR<AdCreateWithoutProductInput, AdUncheckedCreateWithoutProductInput>
  }

  export type AdCreateManyProductInputEnvelope = {
    data: AdCreateManyProductInput | AdCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutProductsInput = {
    update: XOR<BusinessUpdateWithoutProductsInput, BusinessUncheckedUpdateWithoutProductsInput>
    create: XOR<BusinessCreateWithoutProductsInput, BusinessUncheckedCreateWithoutProductsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutProductsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutProductsInput, BusinessUncheckedUpdateWithoutProductsInput>
  }

  export type BusinessUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type MediaUpsertWithWhereUniqueWithoutProductInput = {
    where: MediaWhereUniqueInput
    update: XOR<MediaUpdateWithoutProductInput, MediaUncheckedUpdateWithoutProductInput>
    create: XOR<MediaCreateWithoutProductInput, MediaUncheckedCreateWithoutProductInput>
  }

  export type MediaUpdateWithWhereUniqueWithoutProductInput = {
    where: MediaWhereUniqueInput
    data: XOR<MediaUpdateWithoutProductInput, MediaUncheckedUpdateWithoutProductInput>
  }

  export type MediaUpdateManyWithWhereWithoutProductInput = {
    where: MediaScalarWhereInput
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyWithoutProductInput>
  }

  export type MediaScalarWhereInput = {
    AND?: MediaScalarWhereInput | MediaScalarWhereInput[]
    OR?: MediaScalarWhereInput[]
    NOT?: MediaScalarWhereInput | MediaScalarWhereInput[]
    id?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    type?: EnumMediaTypeFilter<"Media"> | $Enums.MediaType
    productId?: StringFilter<"Media"> | string
    createdAt?: DateTimeFilter<"Media"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderProductUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutProductInput, OrderProductUncheckedUpdateWithoutProductInput>
    create: XOR<OrderProductCreateWithoutProductInput, OrderProductUncheckedCreateWithoutProductInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutProductInput, OrderProductUncheckedUpdateWithoutProductInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutProductInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderProductScalarWhereInput = {
    AND?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
    OR?: OrderProductScalarWhereInput[]
    NOT?: OrderProductScalarWhereInput | OrderProductScalarWhereInput[]
    id?: StringFilter<"OrderProduct"> | string
    orderId?: StringFilter<"OrderProduct"> | string
    productId?: StringFilter<"OrderProduct"> | string
    quantity?: IntFilter<"OrderProduct"> | number
  }

  export type ChatUpsertWithWhereUniqueWithoutProductInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutProductInput, ChatUncheckedUpdateWithoutProductInput>
    create: XOR<ChatCreateWithoutProductInput, ChatUncheckedCreateWithoutProductInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutProductInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutProductInput, ChatUncheckedUpdateWithoutProductInput>
  }

  export type ChatUpdateManyWithWhereWithoutProductInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutProductInput>
  }

  export type RepostedProductUpsertWithWhereUniqueWithoutProductInput = {
    where: RepostedProductWhereUniqueInput
    update: XOR<RepostedProductUpdateWithoutProductInput, RepostedProductUncheckedUpdateWithoutProductInput>
    create: XOR<RepostedProductCreateWithoutProductInput, RepostedProductUncheckedCreateWithoutProductInput>
  }

  export type RepostedProductUpdateWithWhereUniqueWithoutProductInput = {
    where: RepostedProductWhereUniqueInput
    data: XOR<RepostedProductUpdateWithoutProductInput, RepostedProductUncheckedUpdateWithoutProductInput>
  }

  export type RepostedProductUpdateManyWithWhereWithoutProductInput = {
    where: RepostedProductScalarWhereInput
    data: XOR<RepostedProductUpdateManyMutationInput, RepostedProductUncheckedUpdateManyWithoutProductInput>
  }

  export type ReOwnedProductUpsertWithWhereUniqueWithoutProductInput = {
    where: ReOwnedProductWhereUniqueInput
    update: XOR<ReOwnedProductUpdateWithoutProductInput, ReOwnedProductUncheckedUpdateWithoutProductInput>
    create: XOR<ReOwnedProductCreateWithoutProductInput, ReOwnedProductUncheckedCreateWithoutProductInput>
  }

  export type ReOwnedProductUpdateWithWhereUniqueWithoutProductInput = {
    where: ReOwnedProductWhereUniqueInput
    data: XOR<ReOwnedProductUpdateWithoutProductInput, ReOwnedProductUncheckedUpdateWithoutProductInput>
  }

  export type ReOwnedProductUpdateManyWithWhereWithoutProductInput = {
    where: ReOwnedProductScalarWhereInput
    data: XOR<ReOwnedProductUpdateManyMutationInput, ReOwnedProductUncheckedUpdateManyWithoutProductInput>
  }

  export type AdUpsertWithWhereUniqueWithoutProductInput = {
    where: AdWhereUniqueInput
    update: XOR<AdUpdateWithoutProductInput, AdUncheckedUpdateWithoutProductInput>
    create: XOR<AdCreateWithoutProductInput, AdUncheckedCreateWithoutProductInput>
  }

  export type AdUpdateWithWhereUniqueWithoutProductInput = {
    where: AdWhereUniqueInput
    data: XOR<AdUpdateWithoutProductInput, AdUncheckedUpdateWithoutProductInput>
  }

  export type AdUpdateManyWithWhereWithoutProductInput = {
    where: AdScalarWhereInput
    data: XOR<AdUpdateManyMutationInput, AdUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductCreateWithoutMediasInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMediasInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutMediasInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMediasInput, ProductUncheckedCreateWithoutMediasInput>
  }

  export type ProductUpsertWithoutMediasInput = {
    update: XOR<ProductUpdateWithoutMediasInput, ProductUncheckedUpdateWithoutMediasInput>
    create: XOR<ProductCreateWithoutMediasInput, ProductUncheckedCreateWithoutMediasInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMediasInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMediasInput, ProductUncheckedUpdateWithoutMediasInput>
  }

  export type ProductUpdateWithoutMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMediasInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ClientCreateWithoutOrdersInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutOrdersInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutOrdersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
  }

  export type OrderProductCreateWithoutOrderInput = {
    id?: string
    quantity?: number
    product: ProductCreateNestedOneWithoutOrdersInput
  }

  export type OrderProductUncheckedCreateWithoutOrderInput = {
    id?: string
    productId: string
    quantity?: number
  }

  export type OrderProductCreateOrConnectWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    create: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput>
  }

  export type OrderProductCreateManyOrderInputEnvelope = {
    data: OrderProductCreateManyOrderInput | OrderProductCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.PaymentStatus
    method?: $Enums.PaymentMethod
    amount: number
    transactionDate?: Date | string
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type PaymentTransactionUncheckedCreateWithoutOrderInput = {
    id?: string
    status?: $Enums.PaymentStatus
    method?: $Enums.PaymentMethod
    amount: number
    transactionDate?: Date | string
    qrCode?: string | null
    createdAt?: Date | string
  }

  export type PaymentTransactionCreateOrConnectWithoutOrderInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
  }

  export type ClientUpsertWithoutOrdersInput = {
    update: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type ClientUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type OrderProductUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    update: XOR<OrderProductUpdateWithoutOrderInput, OrderProductUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderProductCreateWithoutOrderInput, OrderProductUncheckedCreateWithoutOrderInput>
  }

  export type OrderProductUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderProductWhereUniqueInput
    data: XOR<OrderProductUpdateWithoutOrderInput, OrderProductUncheckedUpdateWithoutOrderInput>
  }

  export type OrderProductUpdateManyWithWhereWithoutOrderInput = {
    where: OrderProductScalarWhereInput
    data: XOR<OrderProductUpdateManyMutationInput, OrderProductUncheckedUpdateManyWithoutOrderInput>
  }

  export type PaymentTransactionUpsertWithoutOrderInput = {
    update: XOR<PaymentTransactionUpdateWithoutOrderInput, PaymentTransactionUncheckedUpdateWithoutOrderInput>
    create: XOR<PaymentTransactionCreateWithoutOrderInput, PaymentTransactionUncheckedCreateWithoutOrderInput>
    where?: PaymentTransactionWhereInput
  }

  export type PaymentTransactionUpdateToOneWithWhereWithoutOrderInput = {
    where?: PaymentTransactionWhereInput
    data: XOR<PaymentTransactionUpdateWithoutOrderInput, PaymentTransactionUncheckedUpdateWithoutOrderInput>
  }

  export type PaymentTransactionUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: FloatFieldUpdateOperationsInput | number
    transactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateWithoutProductsInput = {
    id?: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutOrdersInput
    payment?: PaymentTransactionCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutProductsInput = {
    id?: string
    clientId: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentTransactionUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutProductsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
  }

  export type ProductCreateWithoutOrdersInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrdersInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrdersInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
  }

  export type OrderUpsertWithoutProductsInput = {
    update: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
    create: XOR<OrderCreateWithoutProductsInput, OrderUncheckedCreateWithoutProductsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutProductsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutProductsInput, OrderUncheckedUpdateWithoutProductsInput>
  }

  export type OrderUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    payment?: PaymentTransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentTransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ProductUpsertWithoutOrdersInput = {
    update: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProductCreateWithoutOrdersInput, ProductUncheckedCreateWithoutOrdersInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrdersInput, ProductUncheckedUpdateWithoutOrdersInput>
  }

  export type ProductUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ClientCreateWithoutReviewsInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutReviewsInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutReviewsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type ClientUpsertWithoutReviewsInput = {
    update: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
    create: XOR<ClientCreateWithoutReviewsInput, ClientUncheckedCreateWithoutReviewsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReviewsInput, ClientUncheckedUpdateWithoutReviewsInput>
  }

  export type ClientUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ClientCreateWithoutChatsInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutChatsInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutChatsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutChatsInput, ClientUncheckedCreateWithoutChatsInput>
  }

  export type ProductCreateWithoutChatsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutChatsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutChatsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutChatsInput, ProductUncheckedCreateWithoutChatsInput>
  }

  export type BusinessCreateWithoutChatsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
  }

  export type BusinessUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
  }

  export type BusinessCreateOrConnectWithoutChatsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
  }

  export type WorkerCreateWithoutChatsInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutWorkersInput
    kyc?: KYCCreateNestedOneWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutChatsInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutChatsInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutChatsInput, WorkerUncheckedCreateWithoutChatsInput>
  }

  export type ChatMessageCreateWithoutChatInput = {
    id?: string
    message: string
    senderId?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutChatInput = {
    id?: string
    message: string
    senderId?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageCreateManyChatInputEnvelope = {
    data: ChatMessageCreateManyChatInput | ChatMessageCreateManyChatInput[]
    skipDuplicates?: boolean
  }

  export type ClientUpsertWithoutChatsInput = {
    update: XOR<ClientUpdateWithoutChatsInput, ClientUncheckedUpdateWithoutChatsInput>
    create: XOR<ClientCreateWithoutChatsInput, ClientUncheckedCreateWithoutChatsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutChatsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutChatsInput, ClientUncheckedUpdateWithoutChatsInput>
  }

  export type ClientUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type ProductUpsertWithoutChatsInput = {
    update: XOR<ProductUpdateWithoutChatsInput, ProductUncheckedUpdateWithoutChatsInput>
    create: XOR<ProductCreateWithoutChatsInput, ProductUncheckedCreateWithoutChatsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutChatsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutChatsInput, ProductUncheckedUpdateWithoutChatsInput>
  }

  export type ProductUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BusinessUpsertWithoutChatsInput = {
    update: XOR<BusinessUpdateWithoutChatsInput, BusinessUncheckedUpdateWithoutChatsInput>
    create: XOR<BusinessCreateWithoutChatsInput, BusinessUncheckedCreateWithoutChatsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutChatsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutChatsInput, BusinessUncheckedUpdateWithoutChatsInput>
  }

  export type BusinessUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
  }

  export type WorkerUpsertWithoutChatsInput = {
    update: XOR<WorkerUpdateWithoutChatsInput, WorkerUncheckedUpdateWithoutChatsInput>
    create: XOR<WorkerCreateWithoutChatsInput, WorkerUncheckedCreateWithoutChatsInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutChatsInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutChatsInput, WorkerUncheckedUpdateWithoutChatsInput>
  }

  export type WorkerUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutWorkersNestedInput
    kyc?: KYCUpdateOneWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutWorkerNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
    create: XOR<ChatMessageCreateWithoutChatInput, ChatMessageUncheckedCreateWithoutChatInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutChatInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutChatInput, ChatMessageUncheckedUpdateWithoutChatInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutChatInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutChatInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    chatId?: StringFilter<"ChatMessage"> | string
    message?: StringFilter<"ChatMessage"> | string
    senderId?: StringNullableFilter<"ChatMessage"> | string | null
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatCreateWithoutMessagesInput = {
    id?: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutChatsInput
    product: ProductCreateNestedOneWithoutChatsInput
    business?: BusinessCreateNestedOneWithoutChatsInput
    worker?: WorkerCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutMessagesInput = {
    id?: string
    clientId: string
    productId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatCreateOrConnectWithoutMessagesInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
  }

  export type ChatUpsertWithoutMessagesInput = {
    update: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatCreateWithoutMessagesInput, ChatUncheckedCreateWithoutMessagesInput>
    where?: ChatWhereInput
  }

  export type ChatUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatWhereInput
    data: XOR<ChatUpdateWithoutMessagesInput, ChatUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutChatsNestedInput
    product?: ProductUpdateOneRequiredWithoutChatsNestedInput
    business?: BusinessUpdateOneWithoutChatsNestedInput
    worker?: WorkerUpdateOneWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessCreateWithoutRepostedItemsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutRepostedItemsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutRepostedItemsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutRepostedItemsInput, BusinessUncheckedCreateWithoutRepostedItemsInput>
  }

  export type ProductCreateWithoutRepostsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutRepostsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutRepostsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutRepostsInput, ProductUncheckedCreateWithoutRepostsInput>
  }

  export type BusinessUpsertWithoutRepostedItemsInput = {
    update: XOR<BusinessUpdateWithoutRepostedItemsInput, BusinessUncheckedUpdateWithoutRepostedItemsInput>
    create: XOR<BusinessCreateWithoutRepostedItemsInput, BusinessUncheckedCreateWithoutRepostedItemsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutRepostedItemsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutRepostedItemsInput, BusinessUncheckedUpdateWithoutRepostedItemsInput>
  }

  export type BusinessUpdateWithoutRepostedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutRepostedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductUpsertWithoutRepostsInput = {
    update: XOR<ProductUpdateWithoutRepostsInput, ProductUncheckedUpdateWithoutRepostsInput>
    create: XOR<ProductCreateWithoutRepostsInput, ProductUncheckedCreateWithoutRepostsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutRepostsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutRepostsInput, ProductUncheckedUpdateWithoutRepostsInput>
  }

  export type ProductUpdateWithoutRepostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutRepostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BusinessCreateWithoutReownedItemsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutReownedItemsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutReownedItemsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutReownedItemsInput, BusinessUncheckedCreateWithoutReownedItemsInput>
  }

  export type ProductCreateWithoutReownsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    ads?: AdCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReownsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    ads?: AdUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReownsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReownsInput, ProductUncheckedCreateWithoutReownsInput>
  }

  export type BusinessUpsertWithoutReownedItemsInput = {
    update: XOR<BusinessUpdateWithoutReownedItemsInput, BusinessUncheckedUpdateWithoutReownedItemsInput>
    create: XOR<BusinessCreateWithoutReownedItemsInput, BusinessUncheckedCreateWithoutReownedItemsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutReownedItemsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutReownedItemsInput, BusinessUncheckedUpdateWithoutReownedItemsInput>
  }

  export type BusinessUpdateWithoutReownedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutReownedItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductUpsertWithoutReownsInput = {
    update: XOR<ProductUpdateWithoutReownsInput, ProductUncheckedUpdateWithoutReownsInput>
    create: XOR<ProductCreateWithoutReownsInput, ProductUncheckedCreateWithoutReownsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReownsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReownsInput, ProductUncheckedUpdateWithoutReownsInput>
  }

  export type ProductUpdateWithoutReownsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReownsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BusinessCreateWithoutKycInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutKycInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutKycInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutKycInput, BusinessUncheckedCreateWithoutKycInput>
  }

  export type ClientCreateWithoutKycInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutKycInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutKycInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutKycInput, ClientUncheckedCreateWithoutKycInput>
  }

  export type WorkerCreateWithoutKycInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutWorkersInput
    chats?: ChatCreateNestedManyWithoutWorkerInput
  }

  export type WorkerUncheckedCreateWithoutKycInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    chats?: ChatUncheckedCreateNestedManyWithoutWorkerInput
  }

  export type WorkerCreateOrConnectWithoutKycInput = {
    where: WorkerWhereUniqueInput
    create: XOR<WorkerCreateWithoutKycInput, WorkerUncheckedCreateWithoutKycInput>
  }

  export type BusinessUpsertWithoutKycInput = {
    update: XOR<BusinessUpdateWithoutKycInput, BusinessUncheckedUpdateWithoutKycInput>
    create: XOR<BusinessCreateWithoutKycInput, BusinessUncheckedCreateWithoutKycInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutKycInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutKycInput, BusinessUncheckedUpdateWithoutKycInput>
  }

  export type BusinessUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ClientUpsertWithoutKycInput = {
    update: XOR<ClientUpdateWithoutKycInput, ClientUncheckedUpdateWithoutKycInput>
    create: XOR<ClientCreateWithoutKycInput, ClientUncheckedCreateWithoutKycInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutKycInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutKycInput, ClientUncheckedUpdateWithoutKycInput>
  }

  export type ClientUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type WorkerUpsertWithoutKycInput = {
    update: XOR<WorkerUpdateWithoutKycInput, WorkerUncheckedUpdateWithoutKycInput>
    create: XOR<WorkerCreateWithoutKycInput, WorkerUncheckedCreateWithoutKycInput>
    where?: WorkerWhereInput
  }

  export type WorkerUpdateToOneWithWhereWithoutKycInput = {
    where?: WorkerWhereInput
    data: XOR<WorkerUpdateWithoutKycInput, WorkerUncheckedUpdateWithoutKycInput>
  }

  export type WorkerUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutWorkersNestedInput
    chats?: ChatUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutKycInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    chats?: ChatUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type BusinessCreateWithoutRechargesInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutRechargesInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutRechargesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutRechargesInput, BusinessUncheckedCreateWithoutRechargesInput>
  }

  export type ClientCreateWithoutRechargesInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutRechargesInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutRechargesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutRechargesInput, ClientUncheckedCreateWithoutRechargesInput>
  }

  export type BusinessUpsertWithoutRechargesInput = {
    update: XOR<BusinessUpdateWithoutRechargesInput, BusinessUncheckedUpdateWithoutRechargesInput>
    create: XOR<BusinessCreateWithoutRechargesInput, BusinessUncheckedCreateWithoutRechargesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutRechargesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutRechargesInput, BusinessUncheckedUpdateWithoutRechargesInput>
  }

  export type BusinessUpdateWithoutRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ClientUpsertWithoutRechargesInput = {
    update: XOR<ClientUpdateWithoutRechargesInput, ClientUncheckedUpdateWithoutRechargesInput>
    create: XOR<ClientCreateWithoutRechargesInput, ClientUncheckedCreateWithoutRechargesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutRechargesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutRechargesInput, ClientUncheckedUpdateWithoutRechargesInput>
  }

  export type ClientUpdateWithoutRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutRechargesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type OrderCreateWithoutPaymentInput = {
    id?: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutOrdersInput
    products?: OrderProductCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutPaymentInput = {
    id?: string
    clientId: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: OrderProductUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutPaymentInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
  }

  export type OrderUpsertWithoutPaymentInput = {
    update: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
    create: XOR<OrderCreateWithoutPaymentInput, OrderUncheckedCreateWithoutPaymentInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutPaymentInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutPaymentInput, OrderUncheckedUpdateWithoutPaymentInput>
  }

  export type OrderUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    products?: OrderProductUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type BusinessCreateWithoutAdsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutAdsInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutAdsInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutAdsInput, BusinessUncheckedCreateWithoutAdsInput>
  }

  export type ProductCreateWithoutAdsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutProductsInput
    medias?: MediaCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    orders?: OrderProductCreateNestedManyWithoutProductInput
    chats?: ChatCreateNestedManyWithoutProductInput
    reposts?: RepostedProductCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutAdsInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: MediaUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    orders?: OrderProductUncheckedCreateNestedManyWithoutProductInput
    chats?: ChatUncheckedCreateNestedManyWithoutProductInput
    reposts?: RepostedProductUncheckedCreateNestedManyWithoutProductInput
    reowns?: ReOwnedProductUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutAdsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutAdsInput, ProductUncheckedCreateWithoutAdsInput>
  }

  export type BusinessUpsertWithoutAdsInput = {
    update: XOR<BusinessUpdateWithoutAdsInput, BusinessUncheckedUpdateWithoutAdsInput>
    create: XOR<BusinessCreateWithoutAdsInput, BusinessUncheckedCreateWithoutAdsInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutAdsInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutAdsInput, BusinessUncheckedUpdateWithoutAdsInput>
  }

  export type BusinessUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ProductUpsertWithoutAdsInput = {
    update: XOR<ProductUpdateWithoutAdsInput, ProductUncheckedUpdateWithoutAdsInput>
    create: XOR<ProductCreateWithoutAdsInput, ProductUncheckedCreateWithoutAdsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutAdsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutAdsInput, ProductUncheckedUpdateWithoutAdsInput>
  }

  export type ProductUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutProductsNestedInput
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutAdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
  }

  export type BusinessCreateWithoutFreelanceServicesInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutFreelanceServicesInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutFreelanceServicesInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutFreelanceServicesInput, BusinessUncheckedCreateWithoutFreelanceServicesInput>
  }

  export type FreelanceOrderCreateWithoutServiceInput = {
    id?: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutFreelanceOrdersInput
    businesses?: BusinessCreateNestedManyWithoutFreelanceOrdersInput
  }

  export type FreelanceOrderUncheckedCreateWithoutServiceInput = {
    id?: string
    clientId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
    businesses?: BusinessUncheckedCreateNestedManyWithoutFreelanceOrdersInput
  }

  export type FreelanceOrderCreateOrConnectWithoutServiceInput = {
    where: FreelanceOrderWhereUniqueInput
    create: XOR<FreelanceOrderCreateWithoutServiceInput, FreelanceOrderUncheckedCreateWithoutServiceInput>
  }

  export type FreelanceOrderCreateManyServiceInputEnvelope = {
    data: FreelanceOrderCreateManyServiceInput | FreelanceOrderCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUpsertWithoutFreelanceServicesInput = {
    update: XOR<BusinessUpdateWithoutFreelanceServicesInput, BusinessUncheckedUpdateWithoutFreelanceServicesInput>
    create: XOR<BusinessCreateWithoutFreelanceServicesInput, BusinessUncheckedCreateWithoutFreelanceServicesInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutFreelanceServicesInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutFreelanceServicesInput, BusinessUncheckedUpdateWithoutFreelanceServicesInput>
  }

  export type BusinessUpdateWithoutFreelanceServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutFreelanceServicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type FreelanceOrderUpsertWithWhereUniqueWithoutServiceInput = {
    where: FreelanceOrderWhereUniqueInput
    update: XOR<FreelanceOrderUpdateWithoutServiceInput, FreelanceOrderUncheckedUpdateWithoutServiceInput>
    create: XOR<FreelanceOrderCreateWithoutServiceInput, FreelanceOrderUncheckedCreateWithoutServiceInput>
  }

  export type FreelanceOrderUpdateWithWhereUniqueWithoutServiceInput = {
    where: FreelanceOrderWhereUniqueInput
    data: XOR<FreelanceOrderUpdateWithoutServiceInput, FreelanceOrderUncheckedUpdateWithoutServiceInput>
  }

  export type FreelanceOrderUpdateManyWithWhereWithoutServiceInput = {
    where: FreelanceOrderScalarWhereInput
    data: XOR<FreelanceOrderUpdateManyMutationInput, FreelanceOrderUncheckedUpdateManyWithoutServiceInput>
  }

  export type ClientCreateWithoutFreelanceOrdersInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutFreelanceOrdersInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutFreelanceOrdersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutFreelanceOrdersInput, ClientUncheckedCreateWithoutFreelanceOrdersInput>
  }

  export type FreelanceServiceCreateWithoutOrdersInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
    business: BusinessCreateNestedOneWithoutFreelanceServicesInput
  }

  export type FreelanceServiceUncheckedCreateWithoutOrdersInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    businessId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceServiceCreateOrConnectWithoutOrdersInput = {
    where: FreelanceServiceWhereUniqueInput
    create: XOR<FreelanceServiceCreateWithoutOrdersInput, FreelanceServiceUncheckedCreateWithoutOrdersInput>
  }

  export type BusinessCreateWithoutFreelanceOrdersInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutFreelanceOrdersInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutFreelanceOrdersInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutFreelanceOrdersInput, BusinessUncheckedCreateWithoutFreelanceOrdersInput>
  }

  export type ClientUpsertWithoutFreelanceOrdersInput = {
    update: XOR<ClientUpdateWithoutFreelanceOrdersInput, ClientUncheckedUpdateWithoutFreelanceOrdersInput>
    create: XOR<ClientCreateWithoutFreelanceOrdersInput, ClientUncheckedCreateWithoutFreelanceOrdersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutFreelanceOrdersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutFreelanceOrdersInput, ClientUncheckedUpdateWithoutFreelanceOrdersInput>
  }

  export type ClientUpdateWithoutFreelanceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutFreelanceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type FreelanceServiceUpsertWithoutOrdersInput = {
    update: XOR<FreelanceServiceUpdateWithoutOrdersInput, FreelanceServiceUncheckedUpdateWithoutOrdersInput>
    create: XOR<FreelanceServiceCreateWithoutOrdersInput, FreelanceServiceUncheckedCreateWithoutOrdersInput>
    where?: FreelanceServiceWhereInput
  }

  export type FreelanceServiceUpdateToOneWithWhereWithoutOrdersInput = {
    where?: FreelanceServiceWhereInput
    data: XOR<FreelanceServiceUpdateWithoutOrdersInput, FreelanceServiceUncheckedUpdateWithoutOrdersInput>
  }

  export type FreelanceServiceUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutFreelanceServicesNestedInput
  }

  export type FreelanceServiceUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    businessId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUpsertWithWhereUniqueWithoutFreelanceOrdersInput = {
    where: BusinessWhereUniqueInput
    update: XOR<BusinessUpdateWithoutFreelanceOrdersInput, BusinessUncheckedUpdateWithoutFreelanceOrdersInput>
    create: XOR<BusinessCreateWithoutFreelanceOrdersInput, BusinessUncheckedCreateWithoutFreelanceOrdersInput>
  }

  export type BusinessUpdateWithWhereUniqueWithoutFreelanceOrdersInput = {
    where: BusinessWhereUniqueInput
    data: XOR<BusinessUpdateWithoutFreelanceOrdersInput, BusinessUncheckedUpdateWithoutFreelanceOrdersInput>
  }

  export type BusinessUpdateManyWithWhereWithoutFreelanceOrdersInput = {
    where: BusinessScalarWhereInput
    data: XOR<BusinessUpdateManyMutationInput, BusinessUncheckedUpdateManyWithoutFreelanceOrdersInput>
  }

  export type BusinessScalarWhereInput = {
    AND?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    OR?: BusinessScalarWhereInput[]
    NOT?: BusinessScalarWhereInput | BusinessScalarWhereInput[]
    id?: StringFilter<"Business"> | string
    name?: StringFilter<"Business"> | string
    email?: StringFilter<"Business"> | string
    description?: StringNullableFilter<"Business"> | string | null
    address?: StringNullableFilter<"Business"> | string | null
    phone?: StringNullableFilter<"Business"> | string | null
    isVerified?: BoolFilter<"Business"> | boolean
    createdAt?: DateTimeFilter<"Business"> | Date | string
    updatedAt?: DateTimeFilter<"Business"> | Date | string
  }

  export type BusinessCreateWithoutReferralsMadeInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutReferralsMadeInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutReferralsMadeInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutReferralsMadeInput, BusinessUncheckedCreateWithoutReferralsMadeInput>
  }

  export type ClientCreateWithoutReferralsMadeInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsReceived?: ReferralCreateNestedManyWithoutReferredClientInput
  }

  export type ClientUncheckedCreateWithoutReferralsMadeInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsReceived?: ReferralUncheckedCreateNestedManyWithoutReferredClientInput
  }

  export type ClientCreateOrConnectWithoutReferralsMadeInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReferralsMadeInput, ClientUncheckedCreateWithoutReferralsMadeInput>
  }

  export type BusinessCreateWithoutReferralsReceivedInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutBusinessInput
    products?: ProductCreateNestedManyWithoutBusinessInput
    workers?: WorkerCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeCreateNestedManyWithoutBusinessInput
    ads?: AdCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateBusinessInput
    chats?: ChatCreateNestedManyWithoutBusinessInput
  }

  export type BusinessUncheckedCreateWithoutReferralsReceivedInput = {
    id?: string
    name: string
    email: string
    description?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutBusinessInput
    products?: ProductUncheckedCreateNestedManyWithoutBusinessInput
    workers?: WorkerUncheckedCreateNestedManyWithoutBusinessInput
    repostedItems?: RepostedProductUncheckedCreateNestedManyWithoutBusinessInput
    reownedItems?: ReOwnedProductUncheckedCreateNestedManyWithoutBusinessInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutBusinessInput
    ads?: AdUncheckedCreateNestedManyWithoutBusinessInput
    freelanceServices?: FreelanceServiceUncheckedCreateNestedManyWithoutBusinessInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutBusinessesInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateBusinessInput
    chats?: ChatUncheckedCreateNestedManyWithoutBusinessInput
  }

  export type BusinessCreateOrConnectWithoutReferralsReceivedInput = {
    where: BusinessWhereUniqueInput
    create: XOR<BusinessCreateWithoutReferralsReceivedInput, BusinessUncheckedCreateWithoutReferralsReceivedInput>
  }

  export type ClientCreateWithoutReferralsReceivedInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCCreateNestedOneWithoutClientInput
    orders?: OrderCreateNestedManyWithoutClientInput
    reviews?: ReviewCreateNestedManyWithoutClientInput
    chats?: ChatCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderCreateNestedManyWithoutClientInput
    referralsMade?: ReferralCreateNestedManyWithoutAffiliateClientInput
  }

  export type ClientUncheckedCreateWithoutReferralsReceivedInput = {
    id?: string
    username: string
    email: string
    fullName?: string | null
    address?: string | null
    phone?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    kyc?: KYCUncheckedCreateNestedOneWithoutClientInput
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutClientInput
    chats?: ChatUncheckedCreateNestedManyWithoutClientInput
    recharges?: AccountRechargeUncheckedCreateNestedManyWithoutClientInput
    freelanceOrders?: FreelanceOrderUncheckedCreateNestedManyWithoutClientInput
    referralsMade?: ReferralUncheckedCreateNestedManyWithoutAffiliateClientInput
  }

  export type ClientCreateOrConnectWithoutReferralsReceivedInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReferralsReceivedInput, ClientUncheckedCreateWithoutReferralsReceivedInput>
  }

  export type BusinessUpsertWithoutReferralsMadeInput = {
    update: XOR<BusinessUpdateWithoutReferralsMadeInput, BusinessUncheckedUpdateWithoutReferralsMadeInput>
    create: XOR<BusinessCreateWithoutReferralsMadeInput, BusinessUncheckedCreateWithoutReferralsMadeInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutReferralsMadeInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutReferralsMadeInput, BusinessUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type BusinessUpdateWithoutReferralsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutReferralsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ClientUpsertWithoutReferralsMadeInput = {
    update: XOR<ClientUpdateWithoutReferralsMadeInput, ClientUncheckedUpdateWithoutReferralsMadeInput>
    create: XOR<ClientCreateWithoutReferralsMadeInput, ClientUncheckedCreateWithoutReferralsMadeInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReferralsMadeInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReferralsMadeInput, ClientUncheckedUpdateWithoutReferralsMadeInput>
  }

  export type ClientUpdateWithoutReferralsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReferralsMadeInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredClientNestedInput
  }

  export type BusinessUpsertWithoutReferralsReceivedInput = {
    update: XOR<BusinessUpdateWithoutReferralsReceivedInput, BusinessUncheckedUpdateWithoutReferralsReceivedInput>
    create: XOR<BusinessCreateWithoutReferralsReceivedInput, BusinessUncheckedCreateWithoutReferralsReceivedInput>
    where?: BusinessWhereInput
  }

  export type BusinessUpdateToOneWithWhereWithoutReferralsReceivedInput = {
    where?: BusinessWhereInput
    data: XOR<BusinessUpdateWithoutReferralsReceivedInput, BusinessUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type BusinessUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutBusinessesNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type ClientUpsertWithoutReferralsReceivedInput = {
    update: XOR<ClientUpdateWithoutReferralsReceivedInput, ClientUncheckedUpdateWithoutReferralsReceivedInput>
    create: XOR<ClientCreateWithoutReferralsReceivedInput, ClientUncheckedCreateWithoutReferralsReceivedInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReferralsReceivedInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReferralsReceivedInput, ClientUncheckedUpdateWithoutReferralsReceivedInput>
  }

  export type ClientUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutClientNestedInput
    orders?: OrderUpdateManyWithoutClientNestedInput
    reviews?: ReviewUpdateManyWithoutClientNestedInput
    chats?: ChatUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReferralsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutClientNestedInput
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutClientNestedInput
    chats?: ChatUncheckedUpdateManyWithoutClientNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutClientNestedInput
    freelanceOrders?: FreelanceOrderUncheckedUpdateManyWithoutClientNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateClientNestedInput
  }

  export type ProductCreateManyBusinessInput = {
    id?: string
    title: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkerCreateManyBusinessInput = {
    id?: string
    email: string
    fullName?: string | null
    role?: string | null
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepostedProductCreateManyBusinessInput = {
    id?: string
    productId: string
    earnPercentage?: number
    createdAt?: Date | string
  }

  export type ReOwnedProductCreateManyBusinessInput = {
    id?: string
    productId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
  }

  export type AccountRechargeCreateManyBusinessInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    clientId?: string | null
    createdAt?: Date | string
  }

  export type AdCreateManyBusinessInput = {
    id?: string
    productId: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type FreelanceServiceCreateManyBusinessInput = {
    id?: string
    title: string
    description?: string | null
    isHourly?: boolean
    rate: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyAffiliateBusinessInput = {
    id?: string
    affiliateClientId?: string | null
    referredBusinessId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateManyReferredBusinessInput = {
    id?: string
    affiliateBusinessId?: string | null
    affiliateClientId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ChatCreateManyBusinessInput = {
    id?: string
    clientId: string
    productId: string
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    orders?: OrderProductUpdateManyWithoutProductNestedInput
    chats?: ChatUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUpdateManyWithoutProductNestedInput
    ads?: AdUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: MediaUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    orders?: OrderProductUncheckedUpdateManyWithoutProductNestedInput
    chats?: ChatUncheckedUpdateManyWithoutProductNestedInput
    reposts?: RepostedProductUncheckedUpdateManyWithoutProductNestedInput
    reowns?: ReOwnedProductUncheckedUpdateManyWithoutProductNestedInput
    ads?: AdUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkerUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutWorkerNestedInput
    chats?: ChatUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutWorkerNestedInput
    chats?: ChatUncheckedUpdateManyWithoutWorkerNestedInput
  }

  export type WorkerUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutRepostsNestedInput
  }

  export type RepostedProductUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReownsNestedInput
  }

  export type ReOwnedProductUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountRechargeUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneWithoutRechargesNestedInput
  }

  export type AccountRechargeUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountRechargeUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    product?: ProductUpdateOneRequiredWithoutAdsNestedInput
  }

  export type AdUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FreelanceServiceUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: FreelanceOrderUpdateManyWithoutServiceNestedInput
  }

  export type FreelanceServiceUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: FreelanceOrderUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type FreelanceServiceUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isHourly?: BoolFieldUpdateOperationsInput | boolean
    rate?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceOrderUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutFreelanceOrdersNestedInput
    service?: FreelanceServiceUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type FreelanceOrderUncheckedUpdateWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceOrderUncheckedUpdateManyWithoutBusinessesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutAffiliateBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliateClient?: ClientUpdateOneWithoutReferralsMadeNestedInput
    referredBusiness?: BusinessUpdateOneWithoutReferralsReceivedNestedInput
    referredClient?: ClientUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutAffiliateBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutAffiliateBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferredBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliateBusiness?: BusinessUpdateOneWithoutReferralsMadeNestedInput
    affiliateClient?: ClientUpdateOneWithoutReferralsMadeNestedInput
    referredClient?: ClientUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferredBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutChatsNestedInput
    product?: ProductUpdateOneRequiredWithoutChatsNestedInput
    worker?: WorkerUpdateOneWithoutChatsNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutBusinessInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyClientInput = {
    id?: string
    deliveryFee?: number
    deliveryAddress?: string | null
    qrCode?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyClientInput = {
    id?: string
    productId: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ChatCreateManyClientInput = {
    id?: string
    productId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountRechargeCreateManyClientInput = {
    id?: string
    amount: number
    method: $Enums.RechargeMethod
    origin: $Enums.Country
    businessId?: string | null
    createdAt?: Date | string
  }

  export type FreelanceOrderCreateManyClientInput = {
    id?: string
    serviceId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReferralCreateManyAffiliateClientInput = {
    id?: string
    affiliateBusinessId?: string | null
    referredBusinessId?: string | null
    referredClientId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type ReferralCreateManyReferredClientInput = {
    id?: string
    affiliateBusinessId?: string | null
    affiliateClientId?: string | null
    referredBusinessId?: string | null
    verifiedPurchase?: boolean
    createdAt?: Date | string
  }

  export type OrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: OrderProductUpdateManyWithoutOrderNestedInput
    payment?: PaymentTransactionUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: OrderProductUncheckedUpdateManyWithoutOrderNestedInput
    payment?: PaymentTransactionUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    deliveryFee?: FloatFieldUpdateOperationsInput | number
    deliveryAddress?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutChatsNestedInput
    business?: BusinessUpdateOneWithoutChatsNestedInput
    worker?: WorkerUpdateOneWithoutChatsNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountRechargeUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneWithoutRechargesNestedInput
  }

  export type AccountRechargeUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountRechargeUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    method?: EnumRechargeMethodFieldUpdateOperationsInput | $Enums.RechargeMethod
    origin?: EnumCountryFieldUpdateOperationsInput | $Enums.Country
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceOrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: FreelanceServiceUpdateOneRequiredWithoutOrdersNestedInput
    businesses?: BusinessUpdateManyWithoutFreelanceOrdersNestedInput
  }

  export type FreelanceOrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUncheckedUpdateManyWithoutFreelanceOrdersNestedInput
  }

  export type FreelanceOrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutAffiliateClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliateBusiness?: BusinessUpdateOneWithoutReferralsMadeNestedInput
    referredBusiness?: BusinessUpdateOneWithoutReferralsReceivedNestedInput
    referredClient?: ClientUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutAffiliateClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutAffiliateClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    referredClientId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUpdateWithoutReferredClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    affiliateBusiness?: BusinessUpdateOneWithoutReferralsMadeNestedInput
    affiliateClient?: ClientUpdateOneWithoutReferralsMadeNestedInput
    referredBusiness?: BusinessUpdateOneWithoutReferralsReceivedNestedInput
  }

  export type ReferralUncheckedUpdateWithoutReferredClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReferralUncheckedUpdateManyWithoutReferredClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    affiliateBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    affiliateClientId?: NullableStringFieldUpdateOperationsInput | string | null
    referredBusinessId?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedPurchase?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateManyWorkerInput = {
    id?: string
    clientId: string
    productId: string
    businessId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutChatsNestedInput
    product?: ProductUpdateOneRequiredWithoutChatsNestedInput
    business?: BusinessUpdateOneWithoutChatsNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutWorkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaCreateManyProductInput = {
    id?: string
    url: string
    type: $Enums.MediaType
    createdAt?: Date | string
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    clientId: string
    rating?: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type OrderProductCreateManyProductInput = {
    id?: string
    orderId: string
    quantity?: number
  }

  export type ChatCreateManyProductInput = {
    id?: string
    clientId: string
    businessId?: string | null
    workerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RepostedProductCreateManyProductInput = {
    id?: string
    businessId: string
    earnPercentage?: number
    createdAt?: Date | string
  }

  export type ReOwnedProductCreateManyProductInput = {
    id?: string
    businessId: string
    oldOwnerId: string
    oldPrice: number
    newPrice: number
    markupPercentage: number
    agreedViaChatId: string
    createdAt?: Date | string
  }

  export type AdCreateManyProductInput = {
    id?: string
    businessId: string
    price: number
    periodDays: number
    createdAt?: Date | string
    endedAt?: Date | string | null
  }

  export type MediaUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    order?: OrderUpdateOneRequiredWithoutProductsNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ChatUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutChatsNestedInput
    business?: BusinessUpdateOneWithoutChatsNestedInput
    worker?: WorkerUpdateOneWithoutChatsNestedInput
    messages?: ChatMessageUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutChatNestedInput
  }

  export type ChatUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    businessId?: NullableStringFieldUpdateOperationsInput | string | null
    workerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutRepostedItemsNestedInput
  }

  export type RepostedProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RepostedProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    earnPercentage?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    business?: BusinessUpdateOneRequiredWithoutReownedItemsNestedInput
  }

  export type ReOwnedProductUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReOwnedProductUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    oldOwnerId?: StringFieldUpdateOperationsInput | string
    oldPrice?: FloatFieldUpdateOperationsInput | number
    newPrice?: FloatFieldUpdateOperationsInput | number
    markupPercentage?: FloatFieldUpdateOperationsInput | number
    agreedViaChatId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    business?: BusinessUpdateOneRequiredWithoutAdsNestedInput
  }

  export type AdUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AdUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    periodDays?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrderProductCreateManyOrderInput = {
    id?: string
    productId: string
    quantity?: number
  }

  export type OrderProductUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrderProductUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderProductUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type ChatMessageCreateManyChatInput = {
    id?: string
    message: string
    senderId?: string | null
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutChatInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FreelanceOrderCreateManyServiceInput = {
    id?: string
    clientId: string
    status?: $Enums.FreelanceStatus
    quantity?: number
    totalAmount: number
    escrowAmount: number
    commissionPercent: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FreelanceOrderUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutFreelanceOrdersNestedInput
    businesses?: BusinessUpdateManyWithoutFreelanceOrdersNestedInput
  }

  export type FreelanceOrderUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businesses?: BusinessUncheckedUpdateManyWithoutFreelanceOrdersNestedInput
  }

  export type FreelanceOrderUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    status?: EnumFreelanceStatusFieldUpdateOperationsInput | $Enums.FreelanceStatus
    quantity?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    escrowAmount?: FloatFieldUpdateOperationsInput | number
    commissionPercent?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUpdateWithoutFreelanceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUpdateOneWithoutBusinessNestedInput
    products?: ProductUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUpdateManyWithoutBusinessNestedInput
    ads?: AdUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUpdateManyWithoutBusinessNestedInput
    referralsMade?: ReferralUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateWithoutFreelanceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kyc?: KYCUncheckedUpdateOneWithoutBusinessNestedInput
    products?: ProductUncheckedUpdateManyWithoutBusinessNestedInput
    workers?: WorkerUncheckedUpdateManyWithoutBusinessNestedInput
    repostedItems?: RepostedProductUncheckedUpdateManyWithoutBusinessNestedInput
    reownedItems?: ReOwnedProductUncheckedUpdateManyWithoutBusinessNestedInput
    recharges?: AccountRechargeUncheckedUpdateManyWithoutBusinessNestedInput
    ads?: AdUncheckedUpdateManyWithoutBusinessNestedInput
    freelanceServices?: FreelanceServiceUncheckedUpdateManyWithoutBusinessNestedInput
    referralsMade?: ReferralUncheckedUpdateManyWithoutAffiliateBusinessNestedInput
    referralsReceived?: ReferralUncheckedUpdateManyWithoutReferredBusinessNestedInput
    chats?: ChatUncheckedUpdateManyWithoutBusinessNestedInput
  }

  export type BusinessUncheckedUpdateManyWithoutFreelanceOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}